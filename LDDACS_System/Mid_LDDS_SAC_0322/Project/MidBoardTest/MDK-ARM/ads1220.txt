; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\ads1220.o --asm_dir=.\ --list_dir=.\ --depend=.\ads1220.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\RTD -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\ads1220.crf ..\RTD\ADS1220.c]
                          THUMB

                          AREA ||i.ADS1220_Get_Conversion_Data||, CODE, READONLY, ALIGN=2

                  ADS1220_Get_Conversion_Data PROC
;;;329    **************************************************************************************************************************************************/
;;;330    void ADS1220_Get_Conversion_Data (unsigned char *conversionData, uint8_t chip)
000000  b508              PUSH     {r3,lr}
;;;331    {
;;;332      
;;;333      unsigned char outData[3] = {0xff, 0xff, 0xff};
000002  a205              ADR      r2,|L1.24|
;;;334      
;;;335      USCIB0_SPI_write (outData, conversionData, 3, chip);    // 3 Bytes of Conversion Data
000004  460b              MOV      r3,r1
000006  6812              LDR      r2,[r2,#0]            ;333
000008  9200              STR      r2,[sp,#0]
00000a  4601              MOV      r1,r0
00000c  2203              MOVS     r2,#3
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       USCIB0_SPI_write
;;;336      
;;;337    }
000014  bd08              POP      {r3,pc}
;;;338    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
000018  ffffff00          DCB      255,255,255,0

                          AREA ||i.ADS1220_Get_Conversion_Data_Calibrated||, CODE, READONLY, ALIGN=2

                  ADS1220_Get_Conversion_Data_Calibrated PROC
;;;357    **************************************************************************************************************************************************/
;;;358    void ADS1220_Get_Conversion_Data_Calibrated (unsigned char *conversionData, uint8_t chip)
000000  b57c              PUSH     {r2-r6,lr}
;;;359    {
000002  4605              MOV      r5,r0
;;;360      unsigned char outData[3] = {0xff, 0xff, 0xff};
000004  a01f              ADR      r0,|L2.132|
000006  460e              MOV      r6,r1                 ;359
000008  6800              LDR      r0,[r0,#0]
;;;361      unsigned char tempData[3];
;;;362      int32_t temp_voltage;
;;;363      
;;;364      USCIB0_SPI_write (outData, tempData, 3, chip);    // 3 Bytes of Conversion Data
00000a  460b              MOV      r3,r1
00000c  9001              STR      r0,[sp,#4]
00000e  2203              MOVS     r2,#3
000010  4669              MOV      r1,sp
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       USCIB0_SPI_write
;;;365      if(chip == 1){
000018  2e01              CMP      r6,#1
00001a  d002              BEQ      |L2.34|
;;;366        temp_voltage = (((int32_t)tempData[0] << 16) + ((int32_t)tempData[1] << 8) + (int32_t)tempData[2]);
;;;367        temp_voltage = temp_voltage - OffsetCalibrateValue_1;
;;;368        rawData_1 =  temp_voltage;
;;;369        
;;;370        // Make sure that there is a value in place for the Gain
;;;371        //if (*(unsigned long *)&ADS1220GainCorrection_1 != 0xffffffff)
;;;372        temp_voltage = (int32_t) ((float)temp_voltage * ADS1220GainCorrection_1);
;;;373      }
;;;374      else
;;;375        if(chip == 2){
00001c  2e02              CMP      r6,#2
00001e  d013              BEQ      |L2.72|
000020  e02a              B        |L2.120|
                  |L2.34|
000022  f89d0000          LDRB     r0,[sp,#0]            ;366
000026  f89d1001          LDRB     r1,[sp,#1]            ;366
00002a  0400              LSLS     r0,r0,#16             ;366
00002c  eb002001          ADD      r0,r0,r1,LSL #8       ;366
000030  f89d1002          LDRB     r1,[sp,#2]            ;366
000034  4408              ADD      r0,r0,r1              ;366
000036  4914              LDR      r1,|L2.136|
000038  6809              LDR      r1,[r1,#0]            ;367  ; OffsetCalibrateValue_1
00003a  1a40              SUBS     r0,r0,r1              ;367
00003c  4913              LDR      r1,|L2.140|
00003e  6008              STR      r0,[r1,#0]            ;372  ; rawData_1
000040  f7fffffe          BL       __aeabi_i2f
000044  4912              LDR      r1,|L2.144|
000046  e011              B        |L2.108|
                  |L2.72|
;;;376          temp_voltage = (((int32_t)tempData[0] << 16) + ((int32_t)tempData[1] << 8) + (int32_t)tempData[2]);
000048  f89d0000          LDRB     r0,[sp,#0]
00004c  f89d1001          LDRB     r1,[sp,#1]
000050  0400              LSLS     r0,r0,#16
000052  eb002001          ADD      r0,r0,r1,LSL #8
000056  f89d1002          LDRB     r1,[sp,#2]
00005a  4408              ADD      r0,r0,r1
;;;377          temp_voltage = temp_voltage - OffsetCalibrateValue_2;
00005c  490d              LDR      r1,|L2.148|
00005e  6809              LDR      r1,[r1,#0]  ; OffsetCalibrateValue_2
000060  1a40              SUBS     r0,r0,r1
;;;378          rawData_2 =  temp_voltage;
000062  490d              LDR      r1,|L2.152|
;;;379          
;;;380          // Make sure that there is a value in place for the Gain
;;;381          //if (*(unsigned long *)&ADS1220GainCorrection_2 != 0xffffffff)
;;;382          temp_voltage = (int32_t) ((float)temp_voltage * ADS1220GainCorrection_2);
000064  6008              STR      r0,[r1,#0]  ; rawData_2
000066  f7fffffe          BL       __aeabi_i2f
00006a  490c              LDR      r1,|L2.156|
                  |L2.108|
00006c  6809              LDR      r1,[r1,#0]  ; ADS1220GainCorrection_2
00006e  f7fffffe          BL       __aeabi_fmul
000072  f7fffffe          BL       __aeabi_f2iz
000076  4604              MOV      r4,r0
                  |L2.120|
;;;383        }
;;;384      conversionData[0] = (temp_voltage >> 16) & 0xff;
000078  0c20              LSRS     r0,r4,#16
00007a  7028              STRB     r0,[r5,#0]
;;;385      conversionData[1] = (temp_voltage >> 8) & 0xff;
00007c  0a20              LSRS     r0,r4,#8
00007e  7068              STRB     r0,[r5,#1]
;;;386      conversionData[2] = temp_voltage & 0xff;
000080  70ac              STRB     r4,[r5,#2]
;;;387    }
000082  bd7c              POP      {r2-r6,pc}
;;;388    
                          ENDP

                  |L2.132|
000084  ffffff00          DCB      255,255,255,0
                  |L2.136|
                          DCD      OffsetCalibrateValue_1
                  |L2.140|
                          DCD      rawData_1
                  |L2.144|
                          DCD      ADS1220GainCorrection_1
                  |L2.148|
                          DCD      OffsetCalibrateValue_2
                  |L2.152|
                          DCD      rawData_2
                  |L2.156|
                          DCD      ADS1220GainCorrection_2

                          AREA ||i.ADS1220_Offset_Calibrate_Data||, CODE, READONLY, ALIGN=2

                  ADS1220_Offset_Calibrate_Data PROC
;;;149    **************************************************************************************************************************************************/
;;;150    void ADS1220_Offset_Calibrate_Data (unsigned char *tempData, uint8_t chip)
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152      int32_t temp;
;;;153      
;;;154      temp = tempData[0];
000002  7802              LDRB     r2,[r0,#0]
;;;155      temp <<= 8;
;;;156      temp |= tempData[1];
000004  7843              LDRB     r3,[r0,#1]
;;;157      temp <<= 8;
;;;158      temp |= tempData[2];
000006  7880              LDRB     r0,[r0,#2]
000008  ea432302          ORR      r3,r3,r2,LSL #8       ;156
00000c  ea402003          ORR      r0,r0,r3,LSL #8
;;;159      
;;;160      // Was temp negative?
;;;161      if (tempData[0] & 0x80)
000010  0612              LSLS     r2,r2,#24
000012  d501              BPL      |L3.24|
;;;162        temp |= (0xff000000);              // Sign extend
000014  f040407f          ORR      r0,r0,#0xff000000
                  |L3.24|
;;;163      
;;;164      if(chip == 1){
000018  2901              CMP      r1,#1
00001a  d00f              BEQ      |L3.60|
;;;165        OffsetCalibrateData_1 += temp;
;;;166        OffsetCalibrateCount_1++;
;;;167        OffsetCalibrateValue_1 = OffsetCalibrateData_1 / OffsetCalibrateCount_1;
;;;168      }
;;;169      else
;;;170        if(chip == 2)
00001c  2902              CMP      r1,#2
00001e  d10c              BNE      |L3.58|
;;;171        {
;;;172          OffsetCalibrateData_2 += temp;
000020  4a0d              LDR      r2,|L3.88|
000022  6811              LDR      r1,[r2,#0]  ; OffsetCalibrateData_2
000024  4401              ADD      r1,r1,r0
;;;173          OffsetCalibrateCount_2++;
000026  6011              STR      r1,[r2,#0]  ; OffsetCalibrateData_2
000028  4a0c              LDR      r2,|L3.92|
00002a  7810              LDRB     r0,[r2,#0]  ; OffsetCalibrateCount_2
00002c  1c40              ADDS     r0,r0,#1
00002e  b2c0              UXTB     r0,r0
000030  7010              STRB     r0,[r2,#0]
;;;174          OffsetCalibrateValue_2 = OffsetCalibrateData_2 / OffsetCalibrateCount_2;
000032  fb91f0f0          SDIV     r0,r1,r0
000036  490a              LDR      r1,|L3.96|
                  |L3.56|
000038  6008              STR      r0,[r1,#0]            ;167  ; OffsetCalibrateValue_1
                  |L3.58|
;;;175        }
;;;176    }
00003a  bd10              POP      {r4,pc}
                  |L3.60|
00003c  4a09              LDR      r2,|L3.100|
00003e  6811              LDR      r1,[r2,#0]            ;165  ; OffsetCalibrateData_1
000040  4401              ADD      r1,r1,r0              ;165
000042  6011              STR      r1,[r2,#0]            ;166  ; OffsetCalibrateData_1
000044  4a08              LDR      r2,|L3.104|
000046  7810              LDRB     r0,[r2,#0]            ;166  ; OffsetCalibrateCount_1
000048  1c40              ADDS     r0,r0,#1              ;166
00004a  b2c0              UXTB     r0,r0                 ;166
00004c  7010              STRB     r0,[r2,#0]            ;166
00004e  fb91f0f0          SDIV     r0,r1,r0              ;167
000052  4906              LDR      r1,|L3.108|
000054  e7f0              B        |L3.56|
;;;177    
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      OffsetCalibrateData_2
                  |L3.92|
                          DCD      OffsetCalibrateCount_2
                  |L3.96|
                          DCD      OffsetCalibrateValue_2
                  |L3.100|
                          DCD      OffsetCalibrateData_1
                  |L3.104|
                          DCD      OffsetCalibrateCount_1
                  |L3.108|
                          DCD      OffsetCalibrateValue_1

                          AREA ||i.ADS1220_Powerdown||, CODE, READONLY, ALIGN=2

                  ADS1220_Powerdown PROC
;;;228    **************************************************************************************************************************************************/
;;;229    void ADS1220_Powerdown (void)
000000  b508              PUSH     {r3,lr}
;;;230    {
;;;231      unsigned char cmd = ADS1220_POWERDOWN_CMD;
000002  2002              MOVS     r0,#2
000004  f88d0000          STRB     r0,[sp,#0]
;;;232      USCIB0_SPI_write (&cmd, RcvData, 1, 1);
000008  2301              MOVS     r3,#1
00000a  461a              MOV      r2,r3
00000c  4905              LDR      r1,|L4.36|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       USCIB0_SPI_write
;;;233      USCIB0_SPI_write (&cmd, RcvData, 1, 2);
000014  2302              MOVS     r3,#2
000016  2201              MOVS     r2,#1
000018  4902              LDR      r1,|L4.36|
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       USCIB0_SPI_write
;;;234    }
000020  bd08              POP      {r3,pc}
;;;235    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      RcvData

                          AREA ||i.ADS1220_Read_Regs||, CODE, READONLY, ALIGN=2

                  ADS1220_Read_Regs PROC
;;;284    **************************************************************************************************************************************************/
;;;285    void ADS1220_Read_Regs (unsigned char *readValues, unsigned char startReg, unsigned char length, uint8_t chip)
000000  b57c              PUSH     {r2-r6,lr}
;;;286    {
;;;287      unsigned char outData[5] = {0x55, 0x55, 0x55, 0x55, 0x55};
000002  a508              ADR      r5,|L5.36|
;;;288      
;;;289      outData[0] = ADS1220_READ_CMD(startReg,length);
000004  eb020181          ADD      r1,r2,r1,LSL #2
000008  e9d54500          LDRD     r4,r5,[r5,#0]         ;287
00000c  e9cd4500          STRD     r4,r5,[sp,#0]
000010  311f              ADDS     r1,r1,#0x1f
000012  f88d1000          STRB     r1,[sp,#0]
000016  1c52              ADDS     r2,r2,#1
;;;290      
;;;291      USCIB0_SPI_write (outData, readValues, length+1, chip);    // Add 1 to length for command byte
000018  4601              MOV      r1,r0
00001a  b2d2              UXTB     r2,r2
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       USCIB0_SPI_write
;;;292      
;;;293    }
000022  bd7c              POP      {r2-r6,pc}
;;;294    
                          ENDP

                  |L5.36|
000024  55555555          DCB      "UUUUU",0
000028  5500    
00002a  00                DCB      0
00002b  00                DCB      0

                          AREA ||i.ADS1220_Reset||, CODE, READONLY, ALIGN=2

                  ADS1220_Reset PROC
;;;189    **************************************************************************************************************************************************/
;;;190    void ADS1220_Reset (uint8_t chip)
000000  b508              PUSH     {r3,lr}
;;;191    {
;;;192      unsigned char cmd = ADS1220_RESET_CMD;
000002  2106              MOVS     r1,#6
000004  f88d1000          STRB     r1,[sp,#0]
;;;193      USCIB0_SPI_write (&cmd, RcvData, 1, chip);
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4902              LDR      r1,|L6.24|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       USCIB0_SPI_write
;;;194    }
000014  bd08              POP      {r3,pc}
;;;195    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      RcvData

                          AREA ||i.ADS1220_Send_Read_Data_Command||, CODE, READONLY, ALIGN=2

                  ADS1220_Send_Read_Data_Command PROC
;;;305    **************************************************************************************************************************************************/
;;;306    void ADS1220_Send_Read_Data_Command (uint8_t chip)
000000  b508              PUSH     {r3,lr}
;;;307    {
;;;308      unsigned char cmd = ADS1220_RDATA_CMD;
000002  2110              MOVS     r1,#0x10
000004  f88d1000          STRB     r1,[sp,#0]
;;;309      USCIB0_SPI_write (&cmd, RcvData, 1, chip);
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4902              LDR      r1,|L7.24|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       USCIB0_SPI_write
;;;310    }
000014  bd08              POP      {r3,pc}
;;;311    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      RcvData

                          AREA ||i.ADS1220_Start||, CODE, READONLY, ALIGN=2

                  ADS1220_Start PROC
;;;206    **************************************************************************************************************************************************/
;;;207    void ADS1220_Start (uint8_t chip)
000000  b508              PUSH     {r3,lr}
;;;208    {
;;;209      unsigned char cmd = ADS1220_START_CMD;
000002  2108              MOVS     r1,#8
000004  f88d1000          STRB     r1,[sp,#0]
;;;210      USCIB0_SPI_write (&cmd, RcvData, 1, chip);
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4902              LDR      r1,|L8.24|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       USCIB0_SPI_write
;;;211    }
000014  bd08              POP      {r3,pc}
;;;212    
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      RcvData

                          AREA ||i.ADS1220_Write_Regs||, CODE, READONLY, ALIGN=2

                  ADS1220_Write_Regs PROC
;;;251    **************************************************************************************************************************************************/
;;;252    void ADS1220_Write_Regs (unsigned char *writeValues, unsigned char startReg, unsigned char length, uint8_t chip)
000000  b57c              PUSH     {r2-r6,lr}
;;;253    {
;;;254      unsigned char outData[5];
;;;255      unsigned char i;
;;;256      
;;;257      outData[0] = ADS1220_WRITE_CMD(startReg,length);
000002  eb020181          ADD      r1,r2,r1,LSL #2
000006  313f              ADDS     r1,r1,#0x3f
000008  f88d1000          STRB     r1,[sp,#0]
;;;258      
;;;259      for (i=0; i<length; i++)
00000c  2100              MOVS     r1,#0
00000e  466c              MOV      r4,sp                 ;254
000010  e004              B        |L9.28|
                  |L9.18|
;;;260      {
;;;261        outData[i+1] = writeValues[i];
000012  5c45              LDRB     r5,[r0,r1]
000014  1866              ADDS     r6,r4,r1
000016  1c49              ADDS     r1,r1,#1
000018  7075              STRB     r5,[r6,#1]
00001a  b2c9              UXTB     r1,r1                 ;259
                  |L9.28|
00001c  4291              CMP      r1,r2                 ;259
00001e  d3f8              BCC      |L9.18|
000020  1c52              ADDS     r2,r2,#1              ;259
;;;262      }
;;;263      
;;;264      USCIB0_SPI_write (outData, RcvData, length+1, chip);    // Add 1 to length for command byte
000022  b2d2              UXTB     r2,r2
000024  4902              LDR      r1,|L9.48|
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       USCIB0_SPI_write
;;;265      
;;;266    }
00002c  bd7c              POP      {r2-r6,pc}
;;;267    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      RcvData

                          AREA ||i.Setup_ADS1220||, CODE, READONLY, ALIGN=2

                  Setup_ADS1220 PROC
;;;75     **************************************************************************************************************************************************/
;;;76     void Setup_ADS1220 (unsigned char inputMux, unsigned char opMode,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;77                         unsigned char conversionMode, unsigned char dataRate, unsigned char gainLevel, unsigned char pgaBypass,
;;;78                         unsigned char routeIDAC1, unsigned char routeIDAC2, unsigned char idacCurrent, uint8_t chip)
;;;79     
;;;80     {
000004  4682              MOV      r10,r0
000006  e9dd850e          LDRD     r8,r5,[sp,#0x38]
00000a  e9dd6b0a          LDRD     r6,r11,[sp,#0x28]
00000e  461f              MOV      r7,r3
000010  4614              MOV      r4,r2
000012  4689              MOV      r9,r1
;;;81       float PgaGainLevel;
;;;82       unsigned char config[4];
;;;83       // Reset the ADS1220
;;;84       ADS1220_Reset(chip);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       ADS1220_Reset
;;;85       delay_ms(1);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       delay_ms
;;;86       config[0] = inputMux + gainLevel + pgaBypass;
000020  eb0a0106          ADD      r1,r10,r6
000024  eb01000b          ADD      r0,r1,r11
000028  f88d0000          STRB     r0,[sp,#0]
;;;87       config[1] = dataRate + opMode + conversionMode + ADS1220_TEMP_SENSOR_OFF + ADS1220_BURN_OUT_CURRENT_OFF;
00002c  eb070109          ADD      r1,r7,r9
000030  1908              ADDS     r0,r1,r4
000032  f88d0001          STRB     r0,[sp,#1]
;;;88       config[2] = ADS1220_FIR_50_60 + ADS1220_VREF_EXT_REF0_PINS + ADS1220_LOW_SIDE_POWER_OPEN + idacCurrent;
000036  e9dd010c          LDRD     r0,r1,[sp,#0x30]
00003a  f1080850          ADD      r8,r8,#0x50           ;87
00003e  f88d8002          STRB     r8,[sp,#2]
;;;89       config[3] = routeIDAC1 + routeIDAC2 + ADS1220_DRDY_ON_DRDY_ONLY;
000042  4408              ADD      r0,r0,r1
000044  f88d0003          STRB     r0,[sp,#3]
;;;90       
;;;91       
;;;92       switch (gainLevel)
000048  2e0f              CMP      r6,#0xf
00004a  d220              BCS      |L10.142|
00004c  e8dff006          TBB      [pc,r6]
000050  081f0b1f          DCB      0x08,0x1f,0x0b,0x1f
000054  0e1f111f          DCB      0x0e,0x1f,0x11,0x1f
000058  141f171f          DCB      0x14,0x1f,0x17,0x1f
00005c  1a1f1d00          DCB      0x1a,0x1f,0x1d,0x00
;;;93       {
;;;94       case ADS1220_GAIN_1:
;;;95         PgaGainLevel = 1.0;
000060  f04f547e          MOV      r4,#0x3f800000
;;;96         break;
000064  e013              B        |L10.142|
;;;97       case ADS1220_GAIN_2:
;;;98         PgaGainLevel = 2.0;
000066  f04f4480          MOV      r4,#0x40000000
;;;99         break;
00006a  e010              B        |L10.142|
;;;100      case ADS1220_GAIN_4:
;;;101        PgaGainLevel = 4.0;
00006c  f04f4481          MOV      r4,#0x40800000
;;;102        break;
000070  e00d              B        |L10.142|
;;;103      case ADS1220_GAIN_8:
;;;104        PgaGainLevel = 8.0;
000072  f04f4482          MOV      r4,#0x41000000
;;;105        break;
000076  e00a              B        |L10.142|
;;;106      case ADS1220_GAIN_16:
;;;107        PgaGainLevel = 16.0;
000078  f04f4483          MOV      r4,#0x41800000
;;;108        break;
00007c  e007              B        |L10.142|
;;;109      case ADS1220_GAIN_32:
;;;110        PgaGainLevel = 32.0;
00007e  f04f4484          MOV      r4,#0x42000000
;;;111        break;
000082  e004              B        |L10.142|
;;;112      case ADS1220_GAIN_64:
;;;113        PgaGainLevel = 64.0;
000084  f04f4485          MOV      r4,#0x42800000
;;;114        break;
000088  e001              B        |L10.142|
;;;115      case ADS1220_GAIN_128:
;;;116        PgaGainLevel = 128.0;
00008a  f04f4486          MOV      r4,#0x43000000
                  |L10.142|
;;;117        break;
;;;118      }
;;;119      if(chip == 1){
00008e  2d01              CMP      r5,#1
000090  d002              BEQ      |L10.152|
;;;120        PgaGainLevel_1 = PgaGainLevel;
;;;121      }
;;;122      else
;;;123        if(chip == 2){
000092  2d02              CMP      r5,#2
000094  d002              BEQ      |L10.156|
000096  e003              B        |L10.160|
                  |L10.152|
000098  4805              LDR      r0,|L10.176|
00009a  e000              B        |L10.158|
                  |L10.156|
;;;124          PgaGainLevel_2 = PgaGainLevel;
00009c  4805              LDR      r0,|L10.180|
                  |L10.158|
00009e  6004              STR      r4,[r0,#0]  ; PgaGainLevel_2
                  |L10.160|
;;;125        }
;;;126           
;;;127      ADS1220_Write_Regs (config, ADS1220_CONFIG_0_REG, 4, chip);
0000a0  462b              MOV      r3,r5
0000a2  2204              MOVS     r2,#4
0000a4  2100              MOVS     r1,#0
0000a6  4668              MOV      r0,sp
0000a8  f7fffffe          BL       ADS1220_Write_Regs
;;;128      
;;;129    }
0000ac  e8bd8ff8          POP      {r3-r11,pc}
;;;130    
                          ENDP

                  |L10.176|
                          DCD      PgaGainLevel_1
                  |L10.180|
                          DCD      PgaGainLevel_2

                          AREA ||i.USCIB0_SPI_write||, CODE, READONLY, ALIGN=2

                  USCIB0_SPI_write PROC
;;;455    }
;;;456    void USCIB0_SPI_write (unsigned char *outData, unsigned char *inData, unsigned char length, uint8_t chip)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;457    {
;;;458      unsigned char i;
;;;459      
;;;460      // CS Active Low
;;;461      if(chip == 1){
;;;462        IO_SPI_DRIVE_CSN_1_LOW();
000004  f8dfa064          LDR      r10,|L11.108|
000008  461d              MOV      r5,r3                 ;457
00000a  4616              MOV      r6,r2                 ;457
00000c  460f              MOV      r7,r1                 ;457
00000e  4680              MOV      r8,r0                 ;457
000010  f44f7900          MOV      r9,#0x200
;;;463      }
;;;464      else
;;;465        if(chip == 2)    
;;;466        {
;;;467          IO_SPI_DRIVE_CSN_2_LOW();
000014  f44f6b80          MOV      r11,#0x400
000018  2b01              CMP      r3,#1                 ;461
00001a  d002              BEQ      |L11.34|
00001c  2d02              CMP      r5,#2                 ;465
00001e  d002              BEQ      |L11.38|
000020  e005              B        |L11.46|
                  |L11.34|
000022  4649              MOV      r1,r9                 ;462
000024  e000              B        |L11.40|
                  |L11.38|
000026  4659              MOV      r1,r11
                  |L11.40|
000028  4650              MOV      r0,r10
00002a  f7fffffe          BL       GPIO_ResetBits
                  |L11.46|
;;;468        }
;;;469        
;;;470      delay10um();
00002e  f7fffffe          BL       delay10um
;;;471      
;;;472      for (i=0; i<length; i++)
000032  2400              MOVS     r4,#0
000034  e007              B        |L11.70|
;;;473      {
;;;474        inData[i] = IO_SPI_read_write_data (outData[i]);
000036  bf00              NOP      
                  |L11.56|
000038  f8180004          LDRB     r0,[r8,r4]
00003c  f7fffffe          BL       IO_SPI_read_write_data
000040  5538              STRB     r0,[r7,r4]
000042  1c64              ADDS     r4,r4,#1
000044  b2e4              UXTB     r4,r4                 ;472
                  |L11.70|
000046  42b4              CMP      r4,r6                 ;472
000048  d3f6              BCC      |L11.56|
;;;475      }
;;;476      
;;;477      delay10um();
00004a  f7fffffe          BL       delay10um
;;;478      if(chip == 1){
00004e  2d01              CMP      r5,#1
000050  d007              BEQ      |L11.98|
;;;479        IO_SPI_DRIVE_CSN_1_HIGH();
;;;480      }
;;;481      else
;;;482        if(chip == 2)    
000052  2d02              CMP      r5,#2
000054  d107              BNE      |L11.102|
;;;483        {
;;;484          IO_SPI_DRIVE_CSN_2_HIGH();
000056  4659              MOV      r1,r11
                  |L11.88|
000058  4650              MOV      r0,r10
00005a  e8bd5ff0          POP      {r4-r12,lr}
00005e  f7ffbffe          B.W      GPIO_SetBits
                  |L11.98|
000062  4649              MOV      r1,r9                 ;479
000064  e7f8              B        |L11.88|
                  |L11.102|
;;;485        }
;;;486    }
000066  e8bd9ff0          POP      {r4-r12,pc}
;;;487    
                          ENDP

00006a  0000              DCW      0x0000
                  |L11.108|
                          DCD      0x40011000

                          AREA ||i.USCIB0_SPI_writeByte||, CODE, READONLY, ALIGN=1

                  USCIB0_SPI_writeByte PROC
;;;503    **************************************************************************************************************************************************/
;;;504    unsigned char USCIB0_SPI_writeByte (unsigned char data)
000000  f7ffbffe          B.W      IO_SPI_read_write_data
;;;505    {
;;;506      return ((unsigned char)IO_SPI_read_write_data(data));            // Return the received byte from RX Buffer
;;;507    }
                          ENDP


                          AREA ||i.USCIB0_setupMasterSPI||, CODE, READONLY, ALIGN=1

                  USCIB0_setupMasterSPI PROC
;;;391    **************************************************************************************************************************************************/
;;;392    void USCIB0_setupMasterSPI(void)
000000  f7ffbffe          B.W      IO_SpiInit
;;;393    {
;;;394      
;;;395      //    P1SEL1  |= USCIB0_SIMO + USCIB0_SOMI;
;;;396      //    P2SEL1  |= USCIB0_CLK;                                                     // Assign SPI pins to Primary Peripheral of USCI_B0
;;;397      //    ADS_CS_PORTOUT |= ADS_CS_N;                                                // Active Low, so set high
;;;398      //    ADS_CS_PORTDIR |= ADS_CS_N;
;;;399      //
;;;400      //    UCB0CTL1  |= UCSWRST;                                                      // Enable SW reset
;;;401      //    UCB0CTLW0 = (UCMST + UCSSEL_2 + UCMSB + UCSYNC + UCSWRST);                            // SPI Master, 3 wire, synchronous mode
;;;402      //    UCB0BR0 = 8;                                                               // SMCLK/8 = SCLK (1MHz)
;;;403      //    UCB0BR1 = 0;
;;;404      //    UCB0CTL1 &= ~UCSWRST;                                                      // Clear SW reset, resume operation
;;;405      IO_SpiInit();
;;;406    }
;;;407    
                          ENDP


                          AREA ||i.delay10um||, CODE, READONLY, ALIGN=1

                  delay10um PROC
;;;444    //}
;;;445    void delay10um(void)
000000  2000              MOVS     r0,#0
                  |L14.2|
;;;446    {
;;;447    	int i,j;
;;;448    	for(i=0;i<20;i++)
;;;449    	{
;;;450    		for(j=0;j<20;j++)
000002  2102              MOVS     r1,#2
                  |L14.4|
000004  1c49              ADDS     r1,r1,#1
000006  2914              CMP      r1,#0x14
000008  dbfc              BLT      |L14.4|
00000a  1c40              ADDS     r0,r0,#1
00000c  2814              CMP      r0,#0x14              ;448
00000e  dbf8              BLT      |L14.2|
;;;451    		{
;;;452    			
;;;453    		}
;;;454    	}
;;;455    }
000010  4770              BX       lr
;;;456    void USCIB0_SPI_write (unsigned char *outData, unsigned char *inData, unsigned char length, uint8_t chip)
                          ENDP

