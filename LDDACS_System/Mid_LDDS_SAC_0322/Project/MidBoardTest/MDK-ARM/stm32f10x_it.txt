; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -ostm32f10x_it.o --asm_dir=.\ --list_dir=.\ --depend=stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\RTD -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=stm32f10x_it.crf ..\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
                  |L1.0|
;;;111      */
;;;112    void BusFault_Handler(void)
000000  e7fe              B        |L1.0|
;;;113    {
;;;114      /* Go to infinite loop when Bus Fault exception occurs */
;;;115      while (1)
;;;116      {
;;;117      }
;;;118    }
;;;119    
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;146      */
;;;147    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;148    {
;;;149    }
;;;150    
                          ENDP


                          AREA ||i.EXTI15_10_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI15_10_IRQHandler PROC
;;;278    
;;;279    void EXTI15_10_IRQHandler(void)
000000  4770              BX       lr
;;;280    {
;;;281    
;;;282    }
;;;283    /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L4.0|
;;;85       */
;;;86     void HardFault_Handler(void)
000000  e7fe              B        |L4.0|
;;;87     {
;;;88       /* Go to infinite loop when Hard Fault exception occurs */
;;;89       while (1)
;;;90       {
;;;91       }
;;;92     }
;;;93     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
                  |L5.0|
;;;98       */
;;;99     void MemManage_Handler(void)
000000  e7fe              B        |L5.0|
;;;100    {
;;;101      /* Go to infinite loop when Memory Manage exception occurs */
;;;102      while (1)
;;;103      {
;;;104      }
;;;105    }
;;;106    
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;76       */
;;;77     void NMI_Handler(void)
000000  4770              BX       lr
;;;78     {
;;;79     }
;;;80     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;155      */
;;;156    void PendSV_Handler(void)
000000  4770              BX       lr
;;;157    {
;;;158    }
;;;159    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;137      */
;;;138    void SVC_Handler(void)
000000  4770              BX       lr
;;;139    {
;;;140    }
;;;141    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;164      */
;;;165    void SysTick_Handler(void)
000000  4770              BX       lr
;;;166    {
;;;167    }
;;;168    
                          ENDP


                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=1

                  TIM2_IRQHandler PROC
;;;189    
;;;190    void TIM2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;191    {
;;;192    				 
;;;193      if(TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
000002  2101              MOVS     r1,#1
000004  078c              LSLS     r4,r1,#30
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       TIM_GetITStatus
00000c  2800              CMP      r0,#0
00000e  d007              BEQ      |L10.32|
;;;194      { 
;;;195       	 TIM_ClearITPendingBit(TIM2, TIM_FLAG_Update); 
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_ClearITPendingBit
;;;196    	   DataProcess();
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      DataProcess
                  |L10.32|
;;;197    
;;;198      }	    	   
;;;199    
;;;200       
;;;201    }
000020  bd10              POP      {r4,pc}
;;;202    
                          ENDP


                          AREA ||i.TIM4_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM4_IRQHandler PROC
;;;203    /*定时器4中断处理，clean the receive buffer*/
;;;204    void TIM4_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;205    {     
;;;206       u8 i;
;;;207       if (TIM_GetITStatus(TIM4, TIM_IT_Update) == SET)
000002  4c12              LDR      r4,|L11.76|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       TIM_GetITStatus
00000c  2801              CMP      r0,#1
00000e  d11b              BNE      |L11.72|
;;;208       {
;;;209          TIM_ClearITPendingBit(TIM4,TIM_FLAG_Update); 
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_ClearITPendingBit
;;;210    	  
;;;211    	  mCount++;
000018  4a0d              LDR      r2,|L11.80|
00001a  7890              LDRB     r0,[r2,#2]  ; mCount
00001c  1c40              ADDS     r0,r0,#1
00001e  b2c0              UXTB     r0,r0
000020  7090              STRB     r0,[r2,#2]
;;;212    	  if(mCount==0x25)			  //22
000022  2825              CMP      r0,#0x25
000024  d110              BNE      |L11.72|
;;;213    	  {
;;;214    	     mCount=0;
000026  2300              MOVS     r3,#0
;;;215    	     for(i=0;i<24;i++)
;;;216    		 {
;;;217    		    ReceivedBufTemp[i]=0x00; 
000028  480a              LDR      r0,|L11.84|
00002a  7093              STRB     r3,[r2,#2]            ;214
00002c  4619              MOV      r1,r3                 ;215
                  |L11.46|
00002e  5443              STRB     r3,[r0,r1]
000030  1c49              ADDS     r1,r1,#1              ;215
000032  b2c9              UXTB     r1,r1                 ;215
000034  2918              CMP      r1,#0x18              ;215
000036  d3fa              BCC      |L11.46|
;;;218    		 }
;;;219             num=0;  		
000038  7013              STRB     r3,[r2,#0]
;;;220             TIM_ITConfig(TIM4, TIM_IT_Update, DISABLE); 
00003a  4620              MOV      r0,r4
00003c  2200              MOVS     r2,#0
00003e  e8bd4010          POP      {r4,lr}
000042  2101              MOVS     r1,#1
000044  f7ffbffe          B.W      TIM_ITConfig
                  |L11.72|
;;;221    	  }		
;;;222       }
;;;223    }
000048  bd10              POP      {r4,pc}
;;;224    
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      0x40000800
                  |L11.80|
                          DCD      ||area_number.26||
                  |L11.84|
                          DCD      ||.bss||+0x18

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;224    
;;;225    void USART1_IRQHandler(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;226    { 
;;;227         u8 i=0,isTrue=0;
;;;228    
;;;229        if(USART_GetFlagStatus(USART1,USART_FLAG_ORE)==SET)
000004  4d33              LDR      r5,|L12.212|
000006  2400              MOVS     r4,#0                 ;227
000008  4627              MOV      r7,r4                 ;227
00000a  2108              MOVS     r1,#8
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       USART_GetFlagStatus
000012  2801              CMP      r0,#1
000014  d106              BNE      |L12.36|
;;;230        {
;;;231            USART_ClearFlag(USART1,USART_FLAG_ORE); //读SR其实就是清除标志
000016  2108              MOVS     r1,#8
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       USART_ClearFlag
;;;232            USART_ReceiveData(USART1);		
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_ReceiveData
                  |L12.36|
;;;233        }
;;;234    
;;;235        if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET)
000024  f2405925          MOV      r9,#0x525
000028  4649              MOV      r1,r9
00002a  46aa              MOV      r10,r5
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       USART_GetITStatus
;;;236        {
;;;237            ReceivedBufTemp[num]=USART_ReceiveData(USART1);
000032  4d29              LDR      r5,|L12.216|
000034  f8df80a4          LDR      r8,|L12.220|
000038  b1a8              CBZ      r0,|L12.102|
00003a  4656              MOV      r6,r10
00003c  4650              MOV      r0,r10
00003e  f7fffffe          BL       USART_ReceiveData
000042  4601              MOV      r1,r0
000044  7828              LDRB     r0,[r5,#0]  ; num
000046  f8081000          STRB     r1,[r8,r0]
;;;238            num++;
00004a  1c40              ADDS     r0,r0,#1
00004c  b2c0              UXTB     r0,r0
00004e  7028              STRB     r0,[r5,#0]
;;;239            
;;;240    		if(num==1)
000050  2801              CMP      r0,#1
000052  d104              BNE      |L12.94|
;;;241            {
;;;242                TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);
000054  2201              MOVS     r2,#1
000056  4611              MOV      r1,r2
000058  4821              LDR      r0,|L12.224|
00005a  f7fffffe          BL       TIM_ITConfig
                  |L12.94|
;;;243            }
;;;244    		 USART_ClearITPendingBit(USART1,USART_IT_RXNE);
00005e  4649              MOV      r1,r9
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       USART_ClearITPendingBit
                  |L12.102|
;;;245        }     
;;;246        if(num==24)
000066  7828              LDRB     r0,[r5,#0]  ; num
000068  f04f0901          MOV      r9,#1                 ;237
00006c  2818              CMP      r0,#0x18
00006e  d124              BNE      |L12.186|
;;;247        {
;;;248            num=0;
000070  2600              MOVS     r6,#0
000072  702e              STRB     r6,[r5,#0]
;;;249            format=1;
000074  f8859001          STRB     r9,[r5,#1]
;;;250            if((ReceivedBufTemp[0]!=0x55)||(ReceivedBufTemp[2]!=0x08)||(ReceivedBufTemp[23]!=0x55))
000078  f8980000          LDRB     r0,[r8,#0]  ; ReceivedBufTemp
00007c  2855              CMP      r0,#0x55
00007e  d107              BNE      |L12.144|
000080  f8981002          LDRB     r1,[r8,#2]  ; ReceivedBufTemp
000084  2908              CMP      r1,#8
000086  d103              BNE      |L12.144|
000088  f8980017          LDRB     r0,[r8,#0x17]  ; ReceivedBufTemp
00008c  2855              CMP      r0,#0x55
00008e  d001              BEQ      |L12.148|
                  |L12.144|
;;;251                format=0;
000090  706e              STRB     r6,[r5,#1]
000092  e003              B        |L12.156|
                  |L12.148|
;;;252    
;;;253    		if(format==1)
;;;254    	        isTrue =  CheckReceivedData(ReceivedBufTemp);
000094  4811              LDR      r0,|L12.220|
000096  f7fffffe          BL       CheckReceivedData
00009a  b2c7              UXTB     r7,r0
                  |L12.156|
;;;255    
;;;256            if(format&isTrue)
00009c  7868              LDRB     r0,[r5,#1]  ; format
00009e  4238              TST      r0,r7
0000a0  d00a              BEQ      |L12.184|
;;;257            {
;;;258                for(i=0;i<24;i++) 
;;;259                    ReceivedBuffer[i]=ReceivedBufTemp[i];
0000a2  490e              LDR      r1,|L12.220|
0000a4  4640              MOV      r0,r8                 ;237
0000a6  3918              SUBS     r1,r1,#0x18
                  |L12.168|
0000a8  5d02              LDRB     r2,[r0,r4]
0000aa  550a              STRB     r2,[r1,r4]
0000ac  1c64              ADDS     r4,r4,#1              ;258
0000ae  b2e4              UXTB     r4,r4                 ;258
0000b0  2c18              CMP      r4,#0x18              ;258
0000b2  d3f9              BCC      |L12.168|
;;;260    		     	SendProcess();
0000b4  f7fffffe          BL       SendProcess
                  |L12.184|
;;;261    				num=0;
;;;262    				isTrue=0;
;;;263            }
;;;264    		else
;;;265    		num=0;
0000b8  702e              STRB     r6,[r5,#0]
                  |L12.186|
0000ba  490a              LDR      r1,|L12.228|
;;;266    
;;;267    }
;;;268           DE1=1;
0000bc  f8c19000          STR      r9,[r1,#0]
;;;269    	   USART_ITConfig(USART1,USART_IT_TXE,DISABLE);			  	//发送完成 关闭中断
0000c0  4650              MOV      r0,r10
0000c2  e8bd47f0          POP      {r4-r10,lr}
0000c6  f04f0200          MOV      r2,#0
0000ca  f2407127          MOV      r1,#0x727
0000ce  f7ffbffe          B.W      USART_ITConfig
;;;270    
;;;271    
;;;272    }
;;;273    void Usart_SendChar(char dat)
                          ENDP

0000d2  0000              DCW      0x0000
                  |L12.212|
                          DCD      0x40013800
                  |L12.216|
                          DCD      ||area_number.26||
                  |L12.220|
                          DCD      ||.bss||+0x18
                  |L12.224|
                          DCD      0x40000800
                  |L12.228|
                          DCD      0x422101ac

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
                  |L13.0|
;;;124      */
;;;125    void UsageFault_Handler(void)
000000  e7fe              B        |L13.0|
;;;126    {
;;;127      /* Go to infinite loop when Usage Fault exception occurs */
;;;128      while (1)
;;;129      {
;;;130      }
;;;131    }
;;;132    
                          ENDP


                          AREA ||i.Usart_SendChar||, CODE, READONLY, ALIGN=2

                  Usart_SendChar PROC
;;;272    }
;;;273    void Usart_SendChar(char dat)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
;;;275        while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);//等待上一个字节发送完毕
000002  4c07              LDR      r4,|L14.32|
000004  4605              MOV      r5,r0                 ;274
                  |L14.6|
000006  2140              MOVS     r1,#0x40
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L14.6|
;;;276        USART_SendData(USART1,dat);   
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  e8bd4070          POP      {r4-r6,lr}
00001a  f7ffbffe          B.W      USART_SendData
;;;277    }
;;;278    
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ReceivedBuffer
                          %        24
                  ReceivedBufTemp
                          %        24

                          AREA ||area_number.17||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.17||, ||.bss||
                  SentBuffer
                          %        24

                          AREA ||.data||, DATA, ALIGN=0

                  UIreceivedCount
000000  00                DCB      0x00

                          AREA ||area_number.20||, DATA, ALIGN=0

                          EXPORTAS ||area_number.20||, ||.data||
                  receivedCount
000000  00                DCB      0x00

                          AREA ||area_number.21||, DATA, ALIGN=0

                          EXPORTAS ||area_number.21||, ||.data||
                  receiveFlag
000000  00                DCB      0x00

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  UIreceiveFlag
000000  00                DCB      0x00

                          AREA ||area_number.23||, DATA, ALIGN=1

                          EXPORTAS ||area_number.23||, ||.data||
                  SumRec
000000  0000              DCW      0x0000

                          AREA ||area_number.24||, DATA, ALIGN=1

                          EXPORTAS ||area_number.24||, ||.data||
                  SumCal
000000  0000              DCW      0x0000

                          AREA ||area_number.25||, DATA, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.data||
                  timercnt
                          DCD      0x00000000

                          AREA ||area_number.26||, DATA, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.data||
                  num
000000  00                DCB      0x00
                  format
000001  00                DCB      0x00
                  mCount
000002  00                DCB      0x00

                          AREA ||area_number.27||, DATA, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.data||
                  ReceivedNum
                          DCD      0x00000000

                          AREA ||area_number.28||, DATA, ALIGN=0

                          EXPORTAS ||area_number.28||, ||.data||
                  nCount
000000  00                DCB      0x00
