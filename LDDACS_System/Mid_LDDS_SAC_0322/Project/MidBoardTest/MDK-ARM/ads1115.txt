; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\ads1115.o --asm_dir=.\ --list_dir=.\ --depend=.\ads1115.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\RTD -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\ads1115.crf ..\ADS1115.c]
                          THUMB

                          AREA ||i.AD_init||, CODE, READONLY, ALIGN=2

                  AD_init PROC
;;;30     //---------------------------------------------------------//
;;;31     void AD_init(unsigned char id,unsigned char write_address,unsigned char byte1,unsigned char byte2)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;32     {
000004  461d              MOV      r5,r3
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
00000a  4604              MOV      r4,r0
;;;33     	IIC_Start();
00000c  f7fffffe          BL       IIC_Start
;;;34     	//产生起始条件
;;;35     	IIC_Send_Byte(id);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       IIC_Send_Byte
;;;36     	//向设备发送设备地址
;;;37     	while( IIC_Wait_Ack());
000016  bf00              NOP      
                  |L1.24|
000018  f7fffffe          BL       IIC_Wait_Ack
00001c  2800              CMP      r0,#0
00001e  d1fb              BNE      |L1.24|
;;;38     	//等待ACK
;;;39     	IIC_Send_Byte(write_address) ;//配置寄存器
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       IIC_Send_Byte
;;;40     	//寄存器地址
;;;41     	while( IIC_Wait_Ack());
000026  bf00              NOP      
                  |L1.40|
000028  f7fffffe          BL       IIC_Wait_Ack
00002c  2800              CMP      r0,#0
00002e  d1fb              BNE      |L1.40|
;;;42     	delay_us(4);
000030  2004              MOVS     r0,#4
000032  f7fffffe          BL       delay_us
;;;43     	//等待ACK
;;;44     	IIC_Send_Byte(byte1) ;//c-an0 d-an1 e-an2 f-an3  0->6.144 2->4.096,高字节配置
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       IIC_Send_Byte
                  |L1.60|
;;;45     	//发送数据
;;;46     	while(IIC_Wait_Ack());
00003c  f7fffffe          BL       IIC_Wait_Ack
000040  2800              CMP      r0,#0
000042  d1fb              BNE      |L1.60|
;;;47     	//发送完成
;;;48     	IIC_Send_Byte(byte2);//低字节 最高转换速度
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       IIC_Send_Byte
;;;49     	while(IIC_Wait_Ack());
00004a  bf00              NOP      
                  |L1.76|
00004c  f7fffffe          BL       IIC_Wait_Ack
000050  2800              CMP      r0,#0
000052  d1fb              BNE      |L1.76|
;;;50     	//发送完成
;;;51     	IIC_Stop();
000054  e8bd41f0          POP      {r4-r8,lr}
000058  f7ffbffe          B.W      IIC_Stop
;;;52     	//产生结束信号
;;;53     }
;;;54     //----------------------------------------------------//
                          ENDP


                          AREA ||i.I2C_ADpoint||, CODE, READONLY, ALIGN=2

                  I2C_ADpoint PROC
;;;54     //----------------------------------------------------//
;;;55     void I2C_ADpoint(unsigned char id,unsigned char write_address)
000000  b570              PUSH     {r4-r6,lr}
;;;56     {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;57     	IIC_Start();
000006  f7fffffe          BL       IIC_Start
;;;58     	//产生起始条件
;;;59     	IIC_Send_Byte(id);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       IIC_Send_Byte
                  |L2.16|
;;;60     	//向设备发送设备地址
;;;61     	while(IIC_Wait_Ack());
000010  f7fffffe          BL       IIC_Wait_Ack
000014  2800              CMP      r0,#0
000016  d1fb              BNE      |L2.16|
;;;62     	//等待ACK
;;;63     	IIC_Send_Byte(write_address);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       IIC_Send_Byte
;;;64     	//寄存器地址
;;;65     	while(IIC_Wait_Ack());
00001e  bf00              NOP      
                  |L2.32|
000020  f7fffffe          BL       IIC_Wait_Ack
000024  2800              CMP      r0,#0
000026  d1fb              BNE      |L2.32|
;;;66     
;;;67     	IIC_Stop();
000028  e8bd4070          POP      {r4-r6,lr}
00002c  f7ffbffe          B.W      IIC_Stop
;;;68     	//产生结束信号
;;;69     }
;;;70     
                          ENDP


                          AREA ||i.I2C_Read2||, CODE, READONLY, ALIGN=2

                  I2C_Read2 PROC
;;;119    //----------------------------------------------------------//
;;;120    void I2C_Read2(unsigned char  id, unsigned char read_address)
000000  b510              PUSH     {r4,lr}
;;;121    {  
000002  4604              MOV      r4,r0
;;;122    	
;;;123      	IIC_Start();
000004  f7fffffe          BL       IIC_Start
;;;124      	//产生起始信号
;;;125      	IIC_Send_Byte(id);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       IIC_Send_Byte
;;;126    	//发送地址
;;;127      	while(IIC_Wait_Ack());
00000e  bf00              NOP      
                  |L3.16|
000010  f7fffffe          BL       IIC_Wait_Ack
000014  2800              CMP      r0,#0
000016  d1fb              BNE      |L3.16|
;;;128    	//等待ACK
;;;129      	//IIC_Send_Byte(read_address);
;;;130    	//发送读得地址
;;;131      	//while(IIC_Wait_Ack());
;;;132    	
;;;133      	 BUF[1] = IIC_Read_Byte(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       IIC_Read_Byte
00001e  4c06              LDR      r4,|L3.56|
000020  7060              STRB     r0,[r4,#1]
;;;134    	//重新发送
;;;135      	delay_us(5);
000022  2005              MOVS     r0,#5
000024  f7fffffe          BL       delay_us
;;;136    	BUF[2] = IIC_Read_Byte(1);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       IIC_Read_Byte
00002e  70a0              STRB     r0,[r4,#2]
;;;137    	IIC_Stop();
000030  e8bd4010          POP      {r4,lr}
000034  f7ffbffe          B.W      IIC_Stop
;;;138    		
;;;139        
;;;140    		
;;;141    }
;;;142    float ReadAdOfChannel(unsigned char  Channel,unsigned char CurrentFlag)
                          ENDP

                  |L3.56|
                          DCD      ||.data||+0x10

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=2

                  I2C_ReadByte PROC
;;;78     
;;;79     unsigned char I2C_ReadByte(unsigned char  id, unsigned char read_address)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;80     {  
;;;81     	unsigned char temp; 	
;;;82     
;;;83     	while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));
000004  4c31              LDR      r4,|L4.204|
000006  4688              MOV      r8,r1                 ;80
000008  4606              MOV      r6,r0                 ;80
00000a  f44f3500          MOV      r5,#0x20000
                  |L4.14|
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2C_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d1f9              BNE      |L4.14|
;;;84       	//等待I2C
;;;85       	I2C_GenerateSTART(I2C1, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       I2C_GenerateSTART
;;;86       	//产生起始信号
;;;87       	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
000022  4d2b              LDR      r5,|L4.208|
                  |L4.36|
000024  4620              MOV      r0,r4
000026  4629              MOV      r1,r5
000028  f7fffffe          BL       I2C_CheckEvent
00002c  2800              CMP      r0,#0
00002e  d0f9              BEQ      |L4.36|
;;;88         //EV5
;;;89       	I2C_Send7bitAddress(I2C1, id, I2C_Direction_Transmitter);
000030  2200              MOVS     r2,#0
000032  4631              MOV      r1,r6
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_Send7bitAddress
;;;90     	//发送地址
;;;91       	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
00003a  4f26              LDR      r7,|L4.212|
                  |L4.60|
00003c  4620              MOV      r0,r4
00003e  4639              MOV      r1,r7
000040  f7fffffe          BL       I2C_CheckEvent
000044  2800              CMP      r0,#0
000046  d0f9              BEQ      |L4.60|
;;;92       	//EV6
;;;93       	I2C_Cmd(I2C1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_Cmd
;;;94      	//重新设置可以清楚EV6
;;;95       	I2C_SendData(I2C1, read_address);  
000050  4641              MOV      r1,r8
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       I2C_SendData
;;;96     	//发送读地址
;;;97       	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
000058  4f1e              LDR      r7,|L4.212|
00005a  1cbf              ADDS     r7,r7,#2
                  |L4.92|
00005c  4639              MOV      r1,r7
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       I2C_CheckEvent
000064  2800              CMP      r0,#0
000066  d0f9              BEQ      |L4.92|
;;;98       	//EV8 
;;;99       	I2C_GenerateSTART(I2C1, ENABLE);
000068  2101              MOVS     r1,#1
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       I2C_GenerateSTART
                  |L4.112|
;;;100    	//重新发送
;;;101      	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
000070  4629              MOV      r1,r5
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       I2C_CheckEvent
000078  2800              CMP      r0,#0
00007a  d0f9              BEQ      |L4.112|
;;;102      	//EV5
;;;103      	I2C_Send7bitAddress(I2C1, id, I2C_Direction_Receiver);
00007c  2201              MOVS     r2,#1
00007e  4631              MOV      r1,r6
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       I2C_Send7bitAddress
;;;104      	//发送读地址
;;;105      	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
000086  4d12              LDR      r5,|L4.208|
000088  1c6d              ADDS     r5,r5,#1
                  |L4.138|
00008a  4629              MOV      r1,r5
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       I2C_CheckEvent
000092  2800              CMP      r0,#0
000094  d0f9              BEQ      |L4.138|
;;;106      	//EV6  
;;;107        I2C_AcknowledgeConfig(I2C1, DISABLE);
000096  2100              MOVS     r1,#0
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       I2C_AcknowledgeConfig
;;;108        I2C_GenerateSTOP(I2C1, ENABLE);
00009e  2101              MOVS     r1,#1
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       I2C_GenerateSTOP
;;;109    	//关闭应答和停止条件产生
;;;110        while(!(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)));
0000a6  4d0a              LDR      r5,|L4.208|
0000a8  353f              ADDS     r5,r5,#0x3f
                  |L4.170|
0000aa  4629              MOV      r1,r5
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       I2C_CheckEvent
0000b2  2800              CMP      r0,#0
0000b4  d0f9              BEQ      |L4.170|
;;;111    	      
;;;112        temp = I2C_ReceiveData(I2C1);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       I2C_ReceiveData
0000bc  4605              MOV      r5,r0
;;;113       
;;;114      	I2C_AcknowledgeConfig(I2C1, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       I2C_AcknowledgeConfig
;;;115    		
;;;116        return temp;
0000c6  4628              MOV      r0,r5
;;;117    }
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;118    
                          ENDP

                  |L4.204|
                          DCD      0x40005400
                  |L4.208|
                          DCD      0x00030001
                  |L4.212|
                          DCD      0x00070082

                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=2

                  I2C_WriteByte PROC
;;;10     
;;;11     void I2C_WriteByte(unsigned char id,unsigned char write_address,unsigned char byte)
000000  b570              PUSH     {r4-r6,lr}
;;;12     {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;13     	IIC_Start();
000008  f7fffffe          BL       IIC_Start
;;;14     	//产生起始条件
;;;15     	IIC_Send_Byte(id);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       IIC_Send_Byte
;;;16     	//向设备发送设备地址
;;;17     	while(IIC_Wait_Ack());
000012  bf00              NOP      
                  |L5.20|
000014  f7fffffe          BL       IIC_Wait_Ack
000018  2800              CMP      r0,#0
00001a  d1fb              BNE      |L5.20|
;;;18     	//等待ACK
;;;19     	IIC_Send_Byte(write_address);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       IIC_Send_Byte
;;;20     	//寄存器地址
;;;21     	while(IIC_Wait_Ack());
000022  bf00              NOP      
                  |L5.36|
000024  f7fffffe          BL       IIC_Wait_Ack
000028  2800              CMP      r0,#0
00002a  d1fb              BNE      |L5.36|
;;;22     	//等待ACK
;;;23     	IIC_Send_Byte(byte);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       IIC_Send_Byte
;;;24     	//发送数据
;;;25     	while(IIC_Wait_Ack());
000032  bf00              NOP      
                  |L5.52|
000034  f7fffffe          BL       IIC_Wait_Ack
000038  2800              CMP      r0,#0
00003a  d1fb              BNE      |L5.52|
;;;26     	//发送完成
;;;27     	IIC_Stop();
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f7ffbffe          B.W      IIC_Stop
;;;28     	//产生结束信号
;;;29     }
;;;30     //---------------------------------------------------------//
                          ENDP


                          AREA ||i.ReadAdOfChannel||, CODE, READONLY, ALIGN=2

                  ReadAdOfChannel PROC
;;;141    }
;;;142    float ReadAdOfChannel(unsigned char  Channel,unsigned char CurrentFlag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;143    {
000004  000f              MOVS     r7,r1
;;;144    	float resaultVoltageOrCurrent=0;
000006  f04f0500          MOV      r5,#0
;;;145    	
;;;146    	
;;;147    	int16_t CigH=0xc2;
00000a  f04f02c2          MOV      r2,#0xc2
00000e  d100              BNE      |L6.18|
;;;148    	switch(CurrentFlag)
;;;149    	{
;;;150    		case 0:CigH=0xce;break;  //FS=+-0.256
000010  22ce              MOVS     r2,#0xce
                  |L6.18|
;;;151    		case 1:CigH=0xc2;break;  //FS=+-4.096
;;;152    		default:break;
;;;153    	}
;;;154    	switch(Channel)
;;;155    	{
;;;156    		case 1:AD_init(0x90,0x01,CigH|0x00,0xe2);
;;;157    		       delay_ms(2);
;;;158    					 I2C_ADpoint(0x90,0x00);
;;;159    					 delay_ms(2);
;;;160    		       I2C_Read2(0x91,0x00);
;;;161    		       resault = (BUF[1] << 8) | BUF[2];
000012  4e28              LDR      r6,|L6.180|
000014  2801              CMP      r0,#1                 ;154
000016  f1a60410          SUB      r4,r6,#0x10
00001a  d006              BEQ      |L6.42|
00001c  2802              CMP      r0,#2                 ;154
00001e  d020              BEQ      |L6.98|
000020  2803              CMP      r0,#3                 ;154
000022  d021              BEQ      |L6.104|
000024  2804              CMP      r0,#4                 ;154
000026  d117              BNE      |L6.88|
000028  e021              B        |L6.110|
                  |L6.42|
00002a  23e2              MOVS     r3,#0xe2              ;156
00002c  2101              MOVS     r1,#1                 ;156
00002e  2090              MOVS     r0,#0x90              ;156
000030  f7fffffe          BL       AD_init
000034  2002              MOVS     r0,#2                 ;157
000036  f7fffffe          BL       delay_ms
00003a  2100              MOVS     r1,#0                 ;158
00003c  2090              MOVS     r0,#0x90              ;158
00003e  f7fffffe          BL       I2C_ADpoint
000042  2002              MOVS     r0,#2                 ;159
000044  f7fffffe          BL       delay_ms
000048  2100              MOVS     r1,#0                 ;160
00004a  2091              MOVS     r0,#0x91              ;160
00004c  f7fffffe          BL       I2C_Read2
000050  f8b60001          LDRH     r0,[r6,#1]  ; BUF
000054  ba40              REV16    r0,r0
000056  8020              STRH     r0,[r4,#0]
                  |L6.88|
;;;162    					 break;
;;;163    		case 2:AD_init(0x90,0x01,CigH|0x10,0xe2);
;;;164    		       delay_ms(2);
;;;165    					 I2C_ADpoint(0x90,0x00);
;;;166    					 delay_ms(2);
;;;167    		       I2C_Read2(0x91,0x00);
;;;168    		       resault = (BUF[1] << 8) | BUF[2];
;;;169    					 break;
;;;170    		case 3:AD_init(0x90,0x01,CigH|0x20,0xe2);
;;;171    		       delay_ms(2);
;;;172    					 I2C_ADpoint(0x90,0x00);
;;;173    					 delay_ms(2);
;;;174    		       I2C_Read2(0x91,0x00);
;;;175    		       resault = (BUF[1] << 8) | BUF[2];
;;;176    					 break;
;;;177    	  case 4:AD_init(0x90,0x01,CigH|0x30,0xe2);
;;;178    		       delay_ms(2);
;;;179    					 I2C_ADpoint(0x90,0x00);
;;;180    					 delay_ms(2);
;;;181    		       I2C_Read2(0x91,0x00);
;;;182    		       resault = (BUF[1] << 8) | BUF[2];
;;;183    					 break;
;;;184    		default:break;
;;;185    	}
;;;186    	switch(CurrentFlag)
;;;187    	{ 
;;;188    		case 0: resaultVoltageOrCurrent=0.256*51*resault/32767.0;break;    //FS=+-0.256
000058  4e17              LDR      r6,|L6.184|
00005a  b15f              CBZ      r7,|L6.116|
00005c  2f01              CMP      r7,#1                 ;186
00005e  d126              BNE      |L6.174|
000060  e013              B        |L6.138|
                  |L6.98|
000062  f0420210          ORR      r2,r2,#0x10           ;163
000066  e7e0              B        |L6.42|
                  |L6.104|
000068  f0420220          ORR      r2,r2,#0x20           ;170
00006c  e7dd              B        |L6.42|
                  |L6.110|
00006e  f0420230          ORR      r2,r2,#0x30           ;177
000072  e7da              B        |L6.42|
                  |L6.116|
000074  f9b40000          LDRSH    r0,[r4,#0]  ; resault
000078  f7fffffe          BL       __aeabi_i2d
00007c  4a0f              LDR      r2,|L6.188|
00007e  4b10              LDR      r3,|L6.192|
000080  f7fffffe          BL       __aeabi_dmul
000084  2200              MOVS     r2,#0
000086  4633              MOV      r3,r6
000088  e00c              B        |L6.164|
                  |L6.138|
;;;189    		case 1: resaultVoltageOrCurrent=4.096*1000*resault/32767.0/200.0;break;//FS=+-4.096
00008a  f9b40000          LDRSH    r0,[r4,#0]  ; resault
00008e  f7fffffe          BL       __aeabi_i2d
000092  220c              MOVS     r2,#0xc
000094  f7fffffe          BL       __ARM_scalbn
000098  2200              MOVS     r2,#0
00009a  4633              MOV      r3,r6
00009c  f7fffffe          BL       __aeabi_ddiv
0000a0  2200              MOVS     r2,#0
0000a2  4b08              LDR      r3,|L6.196|
                  |L6.164|
0000a4  f7fffffe          BL       __aeabi_ddiv
0000a8  f7fffffe          BL       __aeabi_d2f
0000ac  4605              MOV      r5,r0                 ;188
                  |L6.174|
;;;190    		default:resaultVoltageOrCurrent=0;break;
;;;191    	}
;;;192    	return resaultVoltageOrCurrent;
0000ae  4628              MOV      r0,r5
;;;193    }
0000b0  e8bd81f0          POP      {r4-r8,pc}
;;;194    //-----------------------------------------------//
                          ENDP

                  |L6.180|
                          DCD      ||.data||+0x10
                  |L6.184|
                          DCD      0x40dfffc0
                  |L6.188|
                          DCD      0x083126ea
                  |L6.192|
                          DCD      0x402a1cac
                  |L6.196|
                          DCD      0x40690000

                          AREA ||i.read_ADS1115_1||, CODE, READONLY, ALIGN=2

                  read_ADS1115_1 PROC
;;;194    //-----------------------------------------------//
;;;195    void read_ADS1115_1()
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;196    {
;;;197    	 /*******************************AD1***********************************************/
;;;198    	   AD_init(0x90,0x01,0xc2,0xe2);
000004  23e2              MOVS     r3,#0xe2
000006  22c2              MOVS     r2,#0xc2
000008  2101              MOVS     r1,#1
00000a  2090              MOVS     r0,#0x90
00000c  f7fffffe          BL       AD_init
;;;199    	   //器件地址90，配置寄存器01，寄存器高位，寄存器低位e2
;;;200    	   //高字节配置：c-an0 d-an1 e-an2 f-an3 ; 0->6.144 2->4.096 4->2.048
;;;201    	 delay_ms(1);	
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       delay_ms
;;;202    	   I2C_ADpoint(0x90,0x00);
000016  2100              MOVS     r1,#0
000018  2090              MOVS     r0,#0x90
00001a  f7fffffe          BL       I2C_ADpoint
;;;203         delay_ms(2);	
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       delay_ms
;;;204         I2C_Read2(0x91,0x00);
000024  2100              MOVS     r1,#0
000026  2091              MOVS     r0,#0x91
000028  f7fffffe          BL       I2C_Read2
;;;205    	 valu_stm32ads1115_1 = (BUF[1] << 8) | BUF[2]; 
00002c  4d30              LDR      r5,|L7.240|
;;;206    	 if(valu_stm32ads1115_1>32768)valu_stm32ads1115_1=valu_stm32ads1115_1-65536;
00002e  f44f4700          MOV      r7,#0x8000
000032  f1a50410          SUB      r4,r5,#0x10           ;205
000036  f8b50001          LDRH     r0,[r5,#1]            ;205  ; BUF
00003a  ba40              REV16    r0,r0                 ;205
00003c  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
00003e  42b8              CMP      r0,r7
000040  dd02              BLE      |L7.72|
000042  f5a03080          SUB      r0,r0,#0x10000
000046  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
                  |L7.72|
;;;207         s1 = ((float)valu_stm32ads1115_1/(float)0x7fff) *4.096*10.02/4.12;                //S1 AI1 通道电压值
000048  f7fffffe          BL       __aeabi_i2f
00004c  f8dfb0a4          LDR      r11,|L7.244|
000050  4659              MOV      r1,r11
000052  f7fffffe          BL       __aeabi_fdiv
000056  f7fffffe          BL       __aeabi_f2d
00005a  4e28              LDR      r6,|L7.252|
00005c  4a26              LDR      r2,|L7.248|
00005e  4633              MOV      r3,r6
000060  f7fffffe          BL       __aeabi_dmul
000064  f8df8098          LDR      r8,|L7.256|
000068  f8df9098          LDR      r9,|L7.260|
00006c  4642              MOV      r2,r8
00006e  464b              MOV      r3,r9
000070  f7fffffe          BL       __aeabi_dmul
000074  f8dfa090          LDR      r10,|L7.264|
000078  4b24              LDR      r3,|L7.268|
00007a  4652              MOV      r2,r10
00007c  f7fffffe          BL       __aeabi_ddiv
000080  f7fffffe          BL       __aeabi_d2f
;;;208        // if(valu_stm32ads1115_1>0x7fff)valu_stm32ads1115_1-=0xffff;	 
;;;209    	
;;;210    	/********************************AD2**********************************************/
;;;211    	AD_init(0x90,0x01,0xd2,0xe2);
000084  60a0              STR      r0,[r4,#8]  ; s1
000086  23e2              MOVS     r3,#0xe2
000088  22d2              MOVS     r2,#0xd2
00008a  2101              MOVS     r1,#1
00008c  2090              MOVS     r0,#0x90
00008e  f7fffffe          BL       AD_init
;;;212    	   //器件地址90，配置寄存器01，寄存器高位，寄存器低位e2
;;;213    	   //高字节配置：c-an0 d-an1 e-an2 f-an3 ; 0->6.144 2->4.096 4->2.048
;;;214    	 delay_ms(1);	
000092  2001              MOVS     r0,#1
000094  f7fffffe          BL       delay_ms
;;;215    	   I2C_ADpoint(0x90,0x00);
000098  2100              MOVS     r1,#0
00009a  2090              MOVS     r0,#0x90
00009c  f7fffffe          BL       I2C_ADpoint
;;;216         delay_ms(2);	
0000a0  2002              MOVS     r0,#2
0000a2  f7fffffe          BL       delay_ms
;;;217         I2C_Read2(0x91,0x00);
0000a6  2100              MOVS     r1,#0
0000a8  2091              MOVS     r0,#0x91
0000aa  f7fffffe          BL       I2C_Read2
;;;218    	 valu_stm32ads1115_1 = (BUF[1] << 8) | BUF[2]; 
0000ae  f8b50001          LDRH     r0,[r5,#1]  ; BUF
0000b2  ba40              REV16    r0,r0
;;;219    	 if(valu_stm32ads1115_1>32768)valu_stm32ads1115_1=valu_stm32ads1115_1-65536;
0000b4  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
0000b6  42b8              CMP      r0,r7
0000b8  dd02              BLE      |L7.192|
0000ba  f5a03080          SUB      r0,r0,#0x10000
0000be  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
                  |L7.192|
;;;220         s2 = ((float)valu_stm32ads1115_1/(float)0x7fff) *4.096*10.02/4.12;                 //S2 AI2 通道电压值
0000c0  f7fffffe          BL       __aeabi_i2f
0000c4  4659              MOV      r1,r11
0000c6  f7fffffe          BL       __aeabi_fdiv
0000ca  f7fffffe          BL       __aeabi_f2d
0000ce  4a0a              LDR      r2,|L7.248|
0000d0  4633              MOV      r3,r6
0000d2  f7fffffe          BL       __aeabi_dmul
0000d6  4642              MOV      r2,r8
0000d8  464b              MOV      r3,r9
0000da  f7fffffe          BL       __aeabi_dmul
0000de  4652              MOV      r2,r10
0000e0  4b0a              LDR      r3,|L7.268|
0000e2  f7fffffe          BL       __aeabi_ddiv
0000e6  f7fffffe          BL       __aeabi_d2f
0000ea  60e0              STR      r0,[r4,#0xc]  ; s2
;;;221        // if(valu_stm32ads1115_1>0x7fff)valu_stm32ads1115_1-=0xffff;	
;;;222    }
0000ec  e8bd9ff0          POP      {r4-r12,pc}
;;;223    
                          ENDP

                  |L7.240|
                          DCD      ||.data||+0x10
                  |L7.244|
                          DCD      0x46fffe00
                  |L7.248|
                          DCD      0xd2f1a9fc
                  |L7.252|
                          DCD      0x4010624d
                  |L7.256|
                          DCD      0x70a3d70a
                  |L7.260|
                          DCD      0x40240a3d
                  |L7.264|
                          DCD      0x47ae147b
                  |L7.268|
                          DCD      0x40107ae1

                          AREA ||i.stm32ads1115_1_init||, CODE, READONLY, ALIGN=1

                  stm32ads1115_1_init PROC
;;;223    
;;;224    void stm32ads1115_1_init(void)
000000  f7ffbffe          B.W      IIC_Init
;;;225    {
;;;226    	IIC_Init();
;;;227    }
;;;228    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  resault
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  valu_stm32ads1115_1
                          DCD      0x00000000
                  ||s1||
                          DCD      0x00000000
                  ||s2||
                          DCD      0x00000000
                  BUF
                          %        8
