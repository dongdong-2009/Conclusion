; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -ostm3210_config.o --asm_dir=.\ --list_dir=.\ --depend=stm3210_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\RTD -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=stm3210_config.crf ..\stm3210_config.c]
                          THUMB

                          AREA ||i.LedInit||, CODE, READONLY, ALIGN=2

                  LedInit PROC
;;;38     }
;;;39     void LedInit(void)
000000  b508              PUSH     {r3,lr}
;;;40     {
;;;41     	GPIO_InitTypeDef GPIO_InitStructure;
;;;42     	
;;;43     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB  , ENABLE);
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;44     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00000a  f44f7000          MOV      r0,#0x200
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;45       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;46       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000018  2010              MOVS     r0,#0x10
00001a  f88d0003          STRB     r0,[sp,#3]
;;;47       GPIO_Init(GPIOB, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L1.40|
000022  f7fffffe          BL       GPIO_Init
;;;48     }
000026  bd08              POP      {r3,pc}
;;;49     
                          ENDP

                  |L1.40|
                          DCD      0x40010c00

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;6      
;;;7      void NVIC_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;8      {
;;;9        NVIC_InitTypeDef NVIC_InitStructure;
;;;10       NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); //分组
000002  f44f7040          MOV      r0,#0x300
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;11       NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
;;;12       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  //先占优先级0级
000010  2400              MOVS     r4,#0
000012  f88d4001          STRB     r4,[sp,#1]
;;;13       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000016  2501              MOVS     r5,#1
000018  f88d5003          STRB     r5,[sp,#3]
;;;14       NVIC_Init(&NVIC_InitStructure);
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       NVIC_Init
;;;15       
;;;16       NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000022  2026              MOVS     r0,#0x26
000024  f88d0000          STRB     r0,[sp,#0]
;;;17       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  //先占优先级0级
000028  f88d4001          STRB     r4,[sp,#1]
;;;18       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00002c  f88d5003          STRB     r5,[sp,#3]
;;;19       NVIC_Init(&NVIC_InitStructure);
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       NVIC_Init
;;;20     
;;;21     
;;;22     
;;;23     //  NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;24     //  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;25     //  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;26     //  NVIC_Init(&NVIC_InitStructure);
;;;27     //	
;;;28     //	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
;;;29     //  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;30     //  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;31     //  NVIC_Init(&NVIC_InitStructure);
;;;32     	
;;;33     	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;     //选择中断通道2
000036  2028              MOVS     r0,#0x28
000038  f88d0000          STRB     r0,[sp,#0]
;;;34     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //抢占式中断优先级设置为0
00003c  f88d4001          STRB     r4,[sp,#1]
;;;35     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;        //响应式中断优先级设置为0
000040  f88d4002          STRB     r4,[sp,#2]
;;;36     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                                   //使能中断
000044  f88d5003          STRB     r5,[sp,#3]
;;;37     	NVIC_Init(&NVIC_InitStructure);
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       NVIC_Init
;;;38     }
00004e  bd38              POP      {r3-r5,pc}
;;;39     void LedInit(void)
                          ENDP


                          AREA ||i.TIM2_Int_Init||, CODE, READONLY, ALIGN=1

                  TIM2_Int_Init PROC
;;;171    
;;;172    void TIM2_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;173    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;174        TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;175    	NVIC_InitTypeDef NVIC_InitStructure;
;;;176    
;;;177    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); //时钟使能
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;178    
;;;179    	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 
00000e  f8ad4004          STRH     r4,[sp,#4]
;;;180    	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  
;;;181    	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000012  2000              MOVS     r0,#0
000014  f8ad5000          STRH     r5,[sp,#0]            ;180
000018  f8ad0006          STRH     r0,[sp,#6]
;;;182    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
00001c  f8ad0002          STRH     r0,[sp,#2]
;;;183    	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000020  f04f4480          MOV      r4,#0x40000000
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       TIM_TimeBaseInit
;;;184     
;;;185    	TIM_ITConfig(  //使能或者失能指定的TIM中断
00002c  2201              MOVS     r2,#1
00002e  4611              MOV      r1,r2
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       TIM_ITConfig
;;;186    		TIM2, //TIM2
;;;187    		TIM_IT_Update ,
;;;188    		ENABLE  //使能
;;;189    		);
;;;190    	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;  //TIM2中断
000036  201c              MOVS     r0,#0x1c
000038  f88d000c          STRB     r0,[sp,#0xc]
;;;191    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;  //先占优先级0级
00003c  2003              MOVS     r0,#3
00003e  f88d000d          STRB     r0,[sp,#0xd]
;;;192    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
000042  2001              MOVS     r0,#1
000044  f88d000f          STRB     r0,[sp,#0xf]
;;;193    	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000048  a803              ADD      r0,sp,#0xc
00004a  f7fffffe          BL       NVIC_Init
;;;194    
;;;195    	TIM_Cmd(TIM2, ENABLE);  //使能TIMx外设						 
00004e  2101              MOVS     r1,#1
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       TIM_Cmd
;;;196    }
000056  bd7f              POP      {r0-r6,pc}
;;;197    void TIM4_Int_Init(u16 arr,u16 psc)
                          ENDP


                          AREA ||i.TIM4_Int_Init||, CODE, READONLY, ALIGN=2

                  TIM4_Int_Init PROC
;;;196    }
;;;197    void TIM4_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;198    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;199        TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;200    	NVIC_InitTypeDef NVIC_InitStructure;
;;;201    
;;;202    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE); //时钟使能
000006  2101              MOVS     r1,#1
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;203    
;;;204    	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 
00000e  f8ad4004          STRH     r4,[sp,#4]
;;;205    	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  
;;;206    	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000012  2000              MOVS     r0,#0
000014  f8ad5000          STRH     r5,[sp,#0]            ;205
;;;207    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
;;;208    	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000018  4c0f              LDR      r4,|L4.88|
00001a  f8ad0006          STRH     r0,[sp,#6]            ;206
00001e  f8ad0002          STRH     r0,[sp,#2]            ;207
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TIM_TimeBaseInit
;;;209     
;;;210    	TIM_ITConfig(  //使能或者失能指定的TIM中断
00002a  2201              MOVS     r2,#1
00002c  4611              MOV      r1,r2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       TIM_ITConfig
;;;211    		TIM4, //TIM2
;;;212    		TIM_IT_Update ,
;;;213    		ENABLE  //使能
;;;214    		);
;;;215    	NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;  //TIM2中断
000034  201e              MOVS     r0,#0x1e
000036  f88d000c          STRB     r0,[sp,#0xc]
;;;216    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;  //先占优先级0级
00003a  2004              MOVS     r0,#4
00003c  f88d000d          STRB     r0,[sp,#0xd]
;;;217    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
000040  2001              MOVS     r0,#1
000042  f88d000f          STRB     r0,[sp,#0xf]
;;;218    	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000046  a803              ADD      r0,sp,#0xc
000048  f7fffffe          BL       NVIC_Init
;;;219    
;;;220    	TIM_Cmd(TIM4, ENABLE);  //使能TIMx外设						 
00004c  2101              MOVS     r1,#1
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       TIM_Cmd
;;;221    }
000054  bd7f              POP      {r0-r6,pc}
;;;222    /*******************************************************************************
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      0x40000800

                          AREA ||i.UART_Configuration||, CODE, READONLY, ALIGN=2

                  UART_Configuration PROC
;;;49     
;;;50     void UART_Configuration(void)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;51     {
000004  b085              SUB      sp,sp,#0x14
;;;52     	USART_InitTypeDef USART_InitStructure;
;;;53     	
;;;54     	GPIO_InitTypeDef GPIO_InitStructure;
;;;55     
;;;56     	
;;;57     	RCC_APB2PeriphClockCmd(USART1_GPIO_CLK  , ENABLE);
000006  2101              MOVS     r1,#1
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;58     	RCC_APB2PeriphClockCmd(USART2_GPIO_CLK  , ENABLE);
00000e  2101              MOVS     r1,#1
000010  2020              MOVS     r0,#0x20
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;59     //	RCC_APB2PeriphClockCmd(USART3_GPIO_CLK  , ENABLE);
;;;60     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC  , ENABLE);
000016  2101              MOVS     r1,#1
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;61     	
;;;62     	RCC_APB2PeriphClockCmd(USART1_CLK  , ENABLE);
00001e  2101              MOVS     r1,#1
000020  0388              LSLS     r0,r1,#14
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;63     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO  , ENABLE);
000026  2101              MOVS     r1,#1
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;64     	
;;;65     	RCC_APB1PeriphClockCmd(USART2_CLK  , ENABLE);
00002e  2101              MOVS     r1,#1
000030  0448              LSLS     r0,r1,#17
000032  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;66     //	RCC_APB1PeriphClockCmd(USART3_CLK  , ENABLE);
;;;67     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4  , ENABLE);
000036  2101              MOVS     r1,#1
000038  04c8              LSLS     r0,r1,#19
00003a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;68     	
;;;69       /*串口1 RX管脚配置*/
;;;70       /* Configure USART1 Rx as input floating */
;;;71       GPIO_InitStructure.GPIO_Pin = USART1_RxPin;
00003e  f44f6580          MOV      r5,#0x400
000042  f8ad5000          STRH     r5,[sp,#0]
;;;72       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000046  2004              MOVS     r0,#4
;;;73       GPIO_Init(USART1_GPIO, &GPIO_InitStructure);
000048  4f4d              LDR      r7,|L5.384|
00004a  f88d0003          STRB     r0,[sp,#3]            ;72
00004e  4669              MOV      r1,sp
000050  4638              MOV      r0,r7
000052  f7fffffe          BL       GPIO_Init
;;;74     
;;;75       /*串口2 RX管脚配置*/
;;;76       /* Configure USART2 Rx as input floating */
;;;77       GPIO_InitStructure.GPIO_Pin = USART2_RxPin;
000056  2040              MOVS     r0,#0x40
;;;78       GPIO_Init(USART2_GPIO, &GPIO_InitStructure);  
000058  f8df9128          LDR      r9,|L5.388|
00005c  f8ad0000          STRH     r0,[sp,#0]            ;77
000060  4669              MOV      r1,sp
000062  4648              MOV      r0,r9
000064  f7fffffe          BL       GPIO_Init
;;;79     
;;;80       /*串口3 RX管脚配置*/
;;;81       /* Configure USART3 Rx as input floating */
;;;82     //  GPIO_InitStructure.GPIO_Pin = USART3_RxPin;
;;;83     //  GPIO_Init(USART3_GPIO, &GPIO_InitStructure);
;;;84     	
;;;85     	/*串口4 RX管脚配置*/
;;;86       /* Configure USART3 Rx as input floating */
;;;87       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;88       GPIO_Init(GPIOC, &GPIO_InitStructure);
000068  f8df811c          LDR      r8,|L5.392|
00006c  006e              LSLS     r6,r5,#1              ;87
00006e  f8ad6000          STRH     r6,[sp,#0]            ;87
000072  4669              MOV      r1,sp
000074  4640              MOV      r0,r8
000076  f7fffffe          BL       GPIO_Init
;;;89     
;;;90     
;;;91     
;;;92       /*串口1 TX管脚配置*/ 
;;;93       /* Configure USART1 Tx as alternate function push-pull */
;;;94       GPIO_InitStructure.GPIO_Pin = USART1_TxPin;
00007a  1068              ASRS     r0,r5,#1
00007c  f8ad0000          STRH     r0,[sp,#0]
;;;95       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000080  2403              MOVS     r4,#3
000082  f88d4002          STRB     r4,[sp,#2]
;;;96       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000086  2018              MOVS     r0,#0x18
000088  f88d0003          STRB     r0,[sp,#3]
;;;97       GPIO_Init(USART1_GPIO, &GPIO_InitStructure);
00008c  4669              MOV      r1,sp
00008e  4638              MOV      r0,r7
000090  f7fffffe          BL       GPIO_Init
;;;98       
;;;99       GPIO_InitStructure.GPIO_Pin = USART2_TxPin;
000094  2020              MOVS     r0,#0x20
000096  f8ad0000          STRH     r0,[sp,#0]
;;;100      GPIO_Init(USART2_GPIO, &GPIO_InitStructure);
00009a  4669              MOV      r1,sp
00009c  4648              MOV      r0,r9
00009e  f7fffffe          BL       GPIO_Init
;;;101    	
;;;102    //	GPIO_InitStructure.GPIO_Pin = USART3_TxPin;
;;;103    //  GPIO_Init(USART3_GPIO, &GPIO_InitStructure);
;;;104    	
;;;105    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
0000a2  f8ad5000          STRH     r5,[sp,#0]
;;;106      GPIO_Init(GPIOC, &GPIO_InitStructure);
0000a6  4669              MOV      r1,sp
0000a8  4640              MOV      r0,r8
0000aa  f7fffffe          BL       GPIO_Init
;;;107    	
;;;108    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
0000ae  f8ad6000          STRH     r6,[sp,#0]
;;;109      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000b2  f88d4002          STRB     r4,[sp,#2]
;;;110      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000b6  2510              MOVS     r5,#0x10
0000b8  f88d5003          STRB     r5,[sp,#3]
;;;111      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000bc  4669              MOV      r1,sp
0000be  4638              MOV      r0,r7
0000c0  f7fffffe          BL       GPIO_Init
;;;112    	GPIO_PinRemapConfig(GPIO_Remap_USART2,ENABLE);
0000c4  2101              MOVS     r1,#1
0000c6  2008              MOVS     r0,#8
0000c8  f7fffffe          BL       GPIO_PinRemapConfig
;;;113    	
;;;114    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
0000cc  2080              MOVS     r0,#0x80
0000ce  f8ad0000          STRH     r0,[sp,#0]
;;;115      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000d2  f88d4002          STRB     r4,[sp,#2]
;;;116      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000d6  f88d5003          STRB     r5,[sp,#3]
;;;117      GPIO_Init(GPIOD, &GPIO_InitStructure);
0000da  4669              MOV      r1,sp
0000dc  4648              MOV      r0,r9
0000de  f7fffffe          BL       GPIO_Init
;;;118      DE1=1;
0000e2  492a              LDR      r1,|L5.396|
0000e4  2001              MOVS     r0,#1
0000e6  6008              STR      r0,[r1,#0]
;;;119    	DE2=1;
0000e8  4929              LDR      r1,|L5.400|
0000ea  f8c1019c          STR      r0,[r1,#0x19c]
;;;120    
;;;121    /* USART1 and USART2 configuration */
;;;122    
;;;123      /* USART1 and USART2 configured as follow:
;;;124            - BaudRate = 9600 baud  
;;;125            - Word Length = 8 Bits
;;;126            - One Stop Bit
;;;127            - No parity
;;;128            - Hardware flow control disabled (RTS and CTS signals)
;;;129            - Receive and transmit enabled
;;;130      */
;;;131      USART_InitStructure.USART_BaudRate = 9600;               /*设置波特率为115200*/
0000ee  f44f5016          MOV      r0,#0x2580
;;;132      USART_InitStructure.USART_WordLength = USART_WordLength_8b;/*设置数据位为8*/
0000f2  9001              STR      r0,[sp,#4]
0000f4  f04f0000          MOV      r0,#0
0000f8  f8ad0008          STRH     r0,[sp,#8]
;;;133      USART_InitStructure.USART_StopBits = USART_StopBits_1;     /*设置停止位为1位*/
0000fc  f8ad000a          STRH     r0,[sp,#0xa]
;;;134      USART_InitStructure.USART_Parity = USART_Parity_No;        /*无奇偶校验*/
000100  f8ad000c          STRH     r0,[sp,#0xc]
;;;135      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;/*无硬件流控*/
000104  f8ad0010          STRH     r0,[sp,#0x10]
;;;136      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;  /*发送和接收*/
000108  f04f000c          MOV      r0,#0xc
;;;137    
;;;138      /*配置串口1 */
;;;139      USART_Init(USART1, &USART_InitStructure);
00010c  4c21              LDR      r4,|L5.404|
00010e  f8ad000e          STRH     r0,[sp,#0xe]          ;136
000112  a901              ADD      r1,sp,#4
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       USART_Init
;;;140    	USART_Init(USART2, &USART_InitStructure);
00011a  4d1f              LDR      r5,|L5.408|
00011c  a901              ADD      r1,sp,#4
00011e  4628              MOV      r0,r5
000120  f7fffffe          BL       USART_Init
;;;141      
;;;142      /*配置串口3*/
;;;143    	USART_InitStructure.USART_BaudRate = 115200;
000124  f44f30e1          MOV      r0,#0x1c200
;;;144    	/*配置串口2*/
;;;145      
;;;146      USART_Init(USART3, &USART_InitStructure);
000128  4e1c              LDR      r6,|L5.412|
00012a  9001              STR      r0,[sp,#4]
00012c  a901              ADD      r1,sp,#4
00012e  4630              MOV      r0,r6
000130  f7fffffe          BL       USART_Init
;;;147    	USART_Init(UART4, &USART_InitStructure);
000134  4f1a              LDR      r7,|L5.416|
000136  a901              ADD      r1,sp,#4
000138  4638              MOV      r0,r7
00013a  f7fffffe          BL       USART_Init
;;;148      			    
;;;149      /*使能串口1的发送和接收中断*/
;;;150      USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
00013e  f2405825          MOV      r8,#0x525
000142  2201              MOVS     r2,#1
000144  4641              MOV      r1,r8
000146  4620              MOV      r0,r4
000148  f7fffffe          BL       USART_ITConfig
;;;151    //  USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;152      /*使能串口2的发送和接收中断*/
;;;153      USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
00014c  2201              MOVS     r2,#1
00014e  4641              MOV      r1,r8
000150  4628              MOV      r0,r5
000152  f7fffffe          BL       USART_ITConfig
;;;154    //  USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
;;;155      USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
000156  2201              MOVS     r2,#1
000158  4641              MOV      r1,r8
00015a  4630              MOV      r0,r6
00015c  f7fffffe          BL       USART_ITConfig
;;;156    //  USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
;;;157    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
000160  2201              MOVS     r2,#1
000162  4641              MOV      r1,r8
000164  4638              MOV      r0,r7
000166  f7fffffe          BL       USART_ITConfig
;;;158    //  USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
;;;159    
;;;160      /* 使能串口1 */
;;;161      USART_Cmd(USART1, ENABLE);
00016a  2101              MOVS     r1,#1
00016c  4620              MOV      r0,r4
00016e  f7fffffe          BL       USART_Cmd
;;;162      /* 使能串口2 */
;;;163      USART_Cmd(USART2, ENABLE);
000172  2101              MOVS     r1,#1
000174  4628              MOV      r0,r5
000176  f7fffffe          BL       USART_Cmd
;;;164      /* 使能串口3 */
;;;165    //  USART_Cmd(USART3, ENABLE);
;;;166    //	/* 使能串口3 */
;;;167    //  USART_Cmd(UART4, ENABLE);
;;;168    
;;;169    }
00017a  b005              ADD      sp,sp,#0x14
00017c  e8bd83f0          POP      {r4-r9,pc}
;;;170    
                          ENDP

                  |L5.384|
                          DCD      0x40010800
                  |L5.388|
                          DCD      0x40011400
                  |L5.392|
                          DCD      0x40011000
                  |L5.396|
                          DCD      0x422101ac
                  |L5.400|
                          DCD      0x42228000
                  |L5.404|
                          DCD      0x40013800
                  |L5.408|
                          DCD      0x40004400
                  |L5.412|
                          DCD      0x40004800
                  |L5.416|
                          DCD      0x40004c00
