; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -odelay.o --asm_dir=.\ --list_dir=.\ --depend=delay.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\RTD -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=delay.crf ..\delay.c]
                          THUMB

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=1

                  delay_ms PROC
;;;12     /*毫秒级精确延时函数*/
;;;13     void delay_ms(__IO uint32_t nTime)	                 //延时多少微秒，n就输入多少！
000000  eb0000c0          ADD      r0,r0,r0,LSL #3
;;;14     {
;;;15       int cnt = 1000;
;;;16       SysTick->LOAD=72*nTime;		                //装载计数值，因为时钟72M，72次在1μs
000004  ea4f02c0          LSL      r2,r0,#3
000008  f04f20e0          MOV      r0,#0xe000e000
00000c  f44f717a          MOV      r1,#0x3e8             ;15
000010  6142              STR      r2,[r0,#0x14]
;;;17       SysTick->CTRL=0x00000005; 				//时钟来源设为为HCLK(72M)，打开定时器
000012  f04f0205          MOV      r2,#5
000016  6102              STR      r2,[r0,#0x10]
                  |L1.24|
;;;18       while(1) 
;;;19       {                 
;;;20         while(!(SysTick->CTRL&0x00010000));        //等待计数到0
000018  6902              LDR      r2,[r0,#0x10]
00001a  03d2              LSLS     r2,r2,#15
00001c  d5fc              BPL      |L1.24|
;;;21     	SysTick->CTRL &= ~0x00010000;
00001e  6902              LDR      r2,[r0,#0x10]
000020  f4223280          BIC      r2,r2,#0x10000
000024  6102              STR      r2,[r0,#0x10]
;;;22     	cnt--;
000026  1e49              SUBS     r1,r1,#1
;;;23     	if(cnt == 0) break;
000028  d1f6              BNE      |L1.24|
;;;24       }
;;;25       SysTick->CTRL=0x00000004;                //关闭定时器
00002a  2104              MOVS     r1,#4
00002c  6101              STR      r1,[r0,#0x10]
;;;26     }
00002e  4770              BX       lr
;;;27     /*秒级精确延时函数*/
                          ENDP


                          AREA ||i.delay_s||, CODE, READONLY, ALIGN=2

                  delay_s PROC
;;;27     /*秒级精确延时函数*/
;;;28     void delay_s(__IO uint32_t nTime)	                 //延时多少微秒，n就输入多少！
000000  490a              LDR      r1,|L2.44|
;;;29     {
;;;30       int cnt = 1000;
000002  f44f727a          MOV      r2,#0x3e8
;;;31       SysTick->LOAD=72*1000*nTime;		                //装载计数值，因为时钟72M，72次在1μs
000006  4348              MULS     r0,r1,r0
000008  f04f21e0          MOV      r1,#0xe000e000
00000c  6148              STR      r0,[r1,#0x14]
;;;32       SysTick->CTRL=0x00000005; 				//时钟来源设为为HCLK(72M)，打开定时器
00000e  2005              MOVS     r0,#5
000010  6108              STR      r0,[r1,#0x10]
                  |L2.18|
;;;33       while(1) 
;;;34       {                 
;;;35         while(!(SysTick->CTRL&0x00010000));        //等待计数到0
000012  6908              LDR      r0,[r1,#0x10]
000014  03c0              LSLS     r0,r0,#15
000016  d5fc              BPL      |L2.18|
;;;36     	SysTick->CTRL &= ~0x00010000;
000018  6908              LDR      r0,[r1,#0x10]
00001a  f4203080          BIC      r0,r0,#0x10000
00001e  6108              STR      r0,[r1,#0x10]
;;;37     	cnt--;
000020  1e52              SUBS     r2,r2,#1
;;;38     	if(cnt == 0) break;
000022  d1f6              BNE      |L2.18|
;;;39       }
;;;40       SysTick->CTRL=0x00000004;                //关闭定时器
000024  2004              MOVS     r0,#4
000026  6108              STR      r0,[r1,#0x10]
;;;41     }
000028  4770              BX       lr
;;;42     
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x00011940

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=1

                  delay_us PROC
;;;4      /*微秒级精确延时函数*/
;;;5      void delay_us(__IO uint32_t nTime)	                 //延时多少微秒，n就输入多少！
000000  eb0000c0          ADD      r0,r0,r0,LSL #3
;;;6      {
;;;7        SysTick->LOAD=72*nTime;		                //装载计数值，因为时钟72M，72次在1μs
000004  ea4f01c0          LSL      r1,r0,#3
000008  f04f20e0          MOV      r0,#0xe000e000
00000c  6141              STR      r1,[r0,#0x14]
;;;8        SysTick->CTRL=0x00000005;                   //时钟来源设为为HCLK(72M)，打开定时器
00000e  f04f0105          MOV      r1,#5
000012  6101              STR      r1,[r0,#0x10]
                  |L3.20|
;;;9        while(!(SysTick->CTRL&0x00010000));        //等待计数到0
000014  6901              LDR      r1,[r0,#0x10]
000016  03c9              LSLS     r1,r1,#15
000018  d5fc              BPL      |L3.20|
;;;10       SysTick->CTRL=0x00000004;                //关闭定时器
00001a  2104              MOVS     r1,#4
00001c  6101              STR      r1,[r0,#0x10]
;;;11     }
00001e  4770              BX       lr
;;;12     /*毫秒级精确延时函数*/
                          ENDP

