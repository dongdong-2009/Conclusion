; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -ow25q16.o --asm_dir=.\ --list_dir=.\ --depend=w25q16.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\RTD -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=w25q16.crf W25Q16.c]
                          THUMB

                          AREA ||i.SPI_FLASH_Write_Disable||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_Write_Disable PROC
;;;128    //将WEL清零  
;;;129    void SPI_FLASH_Write_Disable(void)   
000000  b510              PUSH     {r4,lr}
;;;130    {  
;;;131    	SPI_FLASH_CS=0;                            //使能器件   
000002  4c05              LDR      r4,|L1.24|
000004  2000              MOVS     r0,#0
000006  6020              STR      r0,[r4,#0]
;;;132        SPIx_ReadWriteByte(W25X_WriteDisable);     //发送写禁止指令    
000008  f04f0004          MOV      r0,#4
00000c  f7fffffe          BL       SPIx_ReadWriteByte
;;;133    	SPI_FLASH_CS=1;                            //取消片选     	      
000010  2001              MOVS     r0,#1
000012  6020              STR      r0,[r4,#0]
;;;134    } 			    
000014  bd10              POP      {r4,pc}
;;;135    //读取芯片ID W25X16的ID:0XEF14
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x42220190

                          AREA ||i.SPI_FLASH_Write_Enable||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_Write_Enable PROC
;;;120    //将WEL置位   
;;;121    void SPI_FLASH_Write_Enable(void)   
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123    	SPI_FLASH_CS=0;                            //使能器件   
000002  4c05              LDR      r4,|L2.24|
000004  2000              MOVS     r0,#0
000006  6020              STR      r0,[r4,#0]
;;;124        SPIx_ReadWriteByte(W25X_WriteEnable);      //发送写使能  
000008  f04f0006          MOV      r0,#6
00000c  f7fffffe          BL       SPIx_ReadWriteByte
;;;125    	SPI_FLASH_CS=1;                            //取消片选     	      
000010  2001              MOVS     r0,#1
000012  6020              STR      r0,[r4,#0]
;;;126    } 
000014  bd10              POP      {r4,pc}
;;;127    //SPI_FLASH写禁止	
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x42220190

                          AREA ||i.SPI_FLASH_Write_SR||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_Write_SR PROC
;;;111    //只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写!!!
;;;112    void SPI_FLASH_Write_SR(u8 sr)   
000000  b530              PUSH     {r4,r5,lr}
;;;113    {   
;;;114    	SPI_FLASH_CS=0;                            //使能器件   
000002  4c07              LDR      r4,|L3.32|
000004  4605              MOV      r5,r0                 ;113
000006  2000              MOVS     r0,#0
000008  6020              STR      r0,[r4,#0]
;;;115    	SPIx_ReadWriteByte(W25X_WriteStatusReg);   //发送写取状态寄存器命令    
00000a  f04f0001          MOV      r0,#1
00000e  f7fffffe          BL       SPIx_ReadWriteByte
;;;116    	SPIx_ReadWriteByte(sr);               //写入一个字节  
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SPIx_ReadWriteByte
;;;117    	SPI_FLASH_CS=1;                            //取消片选     	      
000018  2001              MOVS     r0,#1
00001a  6020              STR      r0,[r4,#0]
;;;118    }   
00001c  bd30              POP      {r4,r5,pc}
;;;119    //SPI_FLASH写使能	
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x42220190

                          AREA ||i.SPI_Flash_Erase_Chip||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Erase_Chip PROC
;;;268    //等待时间超长...
;;;269    void SPI_Flash_Erase_Chip(void)   
000000  b510              PUSH     {r4,lr}
;;;270    {                                             
;;;271        SPI_FLASH_Write_Enable();                  //SET WEL 
000002  f7fffffe          BL       SPI_FLASH_Write_Enable
;;;272        SPI_Flash_Wait_Busy();   
000006  f7fffffe          BL       SPI_Flash_Wait_Busy
;;;273      	SPI_FLASH_CS=0;                            //使能器件   
00000a  4c06              LDR      r4,|L4.36|
00000c  2000              MOVS     r0,#0
00000e  6020              STR      r0,[r4,#0]
;;;274        SPIx_ReadWriteByte(W25X_ChipErase);        //发送片擦除命令  
000010  f04f00c7          MOV      r0,#0xc7
000014  f7fffffe          BL       SPIx_ReadWriteByte
;;;275    	SPI_FLASH_CS=1;                            //取消片选     	      
000018  2001              MOVS     r0,#1
00001a  6020              STR      r0,[r4,#0]
;;;276    	SPI_Flash_Wait_Busy();   				   //等待芯片擦除结束
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      SPI_Flash_Wait_Busy
;;;277    }   
;;;278    //擦除一个扇区
                          ENDP

                  |L4.36|
                          DCD      0x42220190

                          AREA ||i.SPI_Flash_Erase_Sector||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Erase_Sector PROC
;;;280    //擦除一个山区的最少时间:150ms
;;;281    void SPI_Flash_Erase_Sector(u32 Dst_Addr)   
000000  b530              PUSH     {r4,r5,lr}
;;;282    {   
;;;283    	Dst_Addr*=4096;
000002  0304              LSLS     r4,r0,#12
;;;284        SPI_FLASH_Write_Enable();                  //SET WEL 	 
000004  f7fffffe          BL       SPI_FLASH_Write_Enable
;;;285        SPI_Flash_Wait_Busy();   
000008  f7fffffe          BL       SPI_Flash_Wait_Busy
;;;286      	SPI_FLASH_CS=0;                            //使能器件   
00000c  4d0b              LDR      r5,|L5.60|
00000e  2000              MOVS     r0,#0
000010  6028              STR      r0,[r5,#0]
;;;287        SPIx_ReadWriteByte(W25X_SectorErase);      //发送扇区擦除指令 
000012  f04f0020          MOV      r0,#0x20
000016  f7fffffe          BL       SPIx_ReadWriteByte
;;;288        SPIx_ReadWriteByte((u8)((Dst_Addr)>>16));  //发送24bit地址    
00001a  f3c44007          UBFX     r0,r4,#16,#8
00001e  f7fffffe          BL       SPIx_ReadWriteByte
;;;289        SPIx_ReadWriteByte((u8)((Dst_Addr)>>8));   
000022  f3c42007          UBFX     r0,r4,#8,#8
000026  f7fffffe          BL       SPIx_ReadWriteByte
;;;290        SPIx_ReadWriteByte((u8)Dst_Addr);  
00002a  b2e0              UXTB     r0,r4
00002c  f7fffffe          BL       SPIx_ReadWriteByte
;;;291    	SPI_FLASH_CS=1;                            //取消片选     	      
000030  2001              MOVS     r0,#1
000032  6028              STR      r0,[r5,#0]
;;;292        SPI_Flash_Wait_Busy();   				   //等待擦除完成
000034  e8bd4030          POP      {r4,r5,lr}
000038  f7ffbffe          B.W      SPI_Flash_Wait_Busy
;;;293    }  
;;;294    //等待空闲
                          ENDP

                  |L5.60|
                          DCD      0x42220190

                          AREA ||i.SPI_Flash_Init||, CODE, READONLY, ALIGN=1

                  SPI_Flash_Init PROC
;;;87     //初始化SPI FLASH的IO口
;;;88     void SPI_Flash_Init(void)
000000  f7ffbffe          B.W      SPIx_Init
;;;89     {
;;;90     	SPIx_Init();		   //初始化SPI
;;;91     }  
;;;92     
                          ENDP


                          AREA ||i.SPI_Flash_PowerDown||, CODE, READONLY, ALIGN=2

                  SPI_Flash_PowerDown PROC
;;;299    //进入掉电模式
;;;300    void SPI_Flash_PowerDown(void)   
000000  b510              PUSH     {r4,lr}
;;;301    { 
;;;302      	SPI_FLASH_CS=0;                            //使能器件   
000002  4c07              LDR      r4,|L7.32|
000004  2000              MOVS     r0,#0
000006  6020              STR      r0,[r4,#0]
;;;303        SPIx_ReadWriteByte(W25X_PowerDown);        //发送掉电命令  
000008  f04f00b9          MOV      r0,#0xb9
00000c  f7fffffe          BL       SPIx_ReadWriteByte
;;;304    	SPI_FLASH_CS=1;                            //取消片选     	      
000010  2001              MOVS     r0,#1
000012  6020              STR      r0,[r4,#0]
;;;305        delay_us(3);                               //等待TPD  
000014  e8bd4010          POP      {r4,lr}
000018  2003              MOVS     r0,#3
00001a  f7ffbffe          B.W      delay_us
;;;306    }   
;;;307    //唤醒
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0x42220190

                          AREA ||i.SPI_Flash_Read||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Read PROC
;;;153    //NumByteToRead:要读取的字节数(最大65535)
;;;154    void SPI_Flash_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)   
000000  b5f0              PUSH     {r4-r7,lr}
;;;155    { 
;;;156     	u16 i;    												    
;;;157    	SPI_FLASH_CS=0;                            //使能器件   
000002  4e11              LDR      r6,|L8.72|
000004  4607              MOV      r7,r0                 ;155
000006  2000              MOVS     r0,#0
000008  460c              MOV      r4,r1                 ;155
00000a  4615              MOV      r5,r2                 ;155
00000c  f8c60190          STR      r0,[r6,#0x190]
;;;158        SPIx_ReadWriteByte(W25X_ReadData);         //发送读取命令   
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       SPIx_ReadWriteByte
;;;159        SPIx_ReadWriteByte((u8)((ReadAddr)>>16));  //发送24bit地址    
000016  f3c44007          UBFX     r0,r4,#16,#8
00001a  f7fffffe          BL       SPIx_ReadWriteByte
;;;160        SPIx_ReadWriteByte((u8)((ReadAddr)>>8));   
00001e  f3c42007          UBFX     r0,r4,#8,#8
000022  f7fffffe          BL       SPIx_ReadWriteByte
;;;161        SPIx_ReadWriteByte((u8)ReadAddr);   
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       SPIx_ReadWriteByte
;;;162        for(i=0;i<NumByteToRead;i++)
00002c  2400              MOVS     r4,#0
00002e  e005              B        |L8.60|
                  |L8.48|
;;;163    	{ 
;;;164            pBuffer[i]=SPIx_ReadWriteByte(0XFF);   //循环读数  
000030  20ff              MOVS     r0,#0xff
000032  f7fffffe          BL       SPIx_ReadWriteByte
000036  5538              STRB     r0,[r7,r4]
000038  1c64              ADDS     r4,r4,#1              ;162
00003a  b2a4              UXTH     r4,r4                 ;162
                  |L8.60|
00003c  42ac              CMP      r4,r5                 ;162
00003e  d3f7              BCC      |L8.48|
;;;165        }
;;;166    	SPI_FLASH_CS=1;                            //取消片选     	      
000040  2001              MOVS     r0,#1
000042  f8c60190          STR      r0,[r6,#0x190]
;;;167    }  
000046  bdf0              POP      {r4-r7,pc}
;;;168    //SPI在一页(0~65535)内写入少于256个字节的数据
                          ENDP

                  |L8.72|
                          DCD      0x42220000

                          AREA ||i.SPI_Flash_ReadID||, CODE, READONLY, ALIGN=2

                  SPI_Flash_ReadID PROC
;;;135    //读取芯片ID W25X16的ID:0XEF14
;;;136    u16 SPI_Flash_ReadID(void)
000000  b530              PUSH     {r4,r5,lr}
;;;137    {
;;;138    	u16 Temp = 0;	  
;;;139    	SPI_FLASH_CS=0;				    
000002  4c0e              LDR      r4,|L9.60|
000004  2500              MOVS     r5,#0
000006  6025              STR      r5,[r4,#0]
;;;140    	SPIx_ReadWriteByte(0x90);//发送读取ID命令	    
000008  f04f0090          MOV      r0,#0x90
00000c  f7fffffe          BL       SPIx_ReadWriteByte
;;;141    	SPIx_ReadWriteByte(0x00); 	    
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       SPIx_ReadWriteByte
;;;142    	SPIx_ReadWriteByte(0x00); 	    
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPIx_ReadWriteByte
;;;143    	SPIx_ReadWriteByte(0x00); 	 			   
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SPIx_ReadWriteByte
;;;144    	Temp|=SPIx_ReadWriteByte(0xFF)<<8;  
000022  20ff              MOVS     r0,#0xff
000024  f7fffffe          BL       SPIx_ReadWriteByte
000028  ea452500          ORR      r5,r5,r0,LSL #8
;;;145    	Temp|=SPIx_ReadWriteByte(0xFF);	 
00002c  20ff              MOVS     r0,#0xff
00002e  f7fffffe          BL       SPIx_ReadWriteByte
000032  4328              ORRS     r0,r0,r5
;;;146    	SPI_FLASH_CS=1;				    
000034  2101              MOVS     r1,#1
000036  6021              STR      r1,[r4,#0]
;;;147    	return Temp;
;;;148    }   		    
000038  bd30              POP      {r4,r5,pc}
;;;149    //读取SPI FLASH  
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      0x42220190

                          AREA ||i.SPI_Flash_ReadSR||, CODE, READONLY, ALIGN=2

                  SPI_Flash_ReadSR PROC
;;;100    //默认:0x00
;;;101    u8 SPI_Flash_ReadSR(void)   
000000  b510              PUSH     {r4,lr}
;;;102    {  
;;;103    	u8 byte=0;   
;;;104    	SPI_FLASH_CS=0;                            //使能器件   
000002  4c06              LDR      r4,|L10.28|
000004  2000              MOVS     r0,#0
000006  6020              STR      r0,[r4,#0]
;;;105    	SPIx_ReadWriteByte(W25X_ReadStatusReg);    //发送读取状态寄存器命令    
000008  f04f0005          MOV      r0,#5
00000c  f7fffffe          BL       SPIx_ReadWriteByte
;;;106    	byte=SPIx_ReadWriteByte(0Xff);             //读取一个字节  
000010  20ff              MOVS     r0,#0xff
000012  f7fffffe          BL       SPIx_ReadWriteByte
;;;107    	SPI_FLASH_CS=1;                            //取消片选     
000016  2101              MOVS     r1,#1
000018  6021              STR      r1,[r4,#0]
;;;108    	return byte;   
;;;109    } 
00001a  bd10              POP      {r4,pc}
;;;110    //写SPI_FLASH状态寄存器
                          ENDP

                  |L10.28|
                          DCD      0x42220190

                          AREA ||i.SPI_Flash_WAKEUP||, CODE, READONLY, ALIGN=2

                  SPI_Flash_WAKEUP PROC
;;;307    //唤醒
;;;308    void SPI_Flash_WAKEUP(void)   
000000  b510              PUSH     {r4,lr}
;;;309    {  
;;;310      	SPI_FLASH_CS=0;                            //使能器件   
000002  4c07              LDR      r4,|L11.32|
000004  2000              MOVS     r0,#0
000006  6020              STR      r0,[r4,#0]
;;;311        SPIx_ReadWriteByte(W25X_ReleasePowerDown);   //  send W25X_PowerDown command 0xAB    
000008  f04f00ab          MOV      r0,#0xab
00000c  f7fffffe          BL       SPIx_ReadWriteByte
;;;312    	SPI_FLASH_CS=1;                            //取消片选     	      
000010  2001              MOVS     r0,#1
000012  6020              STR      r0,[r4,#0]
;;;313        delay_us(3);                               //等待TRES1
000014  e8bd4010          POP      {r4,lr}
000018  2003              MOVS     r0,#3
00001a  f7ffbffe          B.W      delay_us
;;;314    }   
;;;315    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0x42220190

                          AREA ||i.SPI_Flash_Wait_Busy||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Wait_Busy PROC
;;;294    //等待空闲
;;;295    void SPI_Flash_Wait_Busy(void)   
000000  b500              PUSH     {lr}
;;;296    {   
;;;297    	while ((SPI_Flash_ReadSR()&0x01)==0x01);   // 等待BUSY位清空
000002  bf00              NOP      
                  |L12.4|
000004  f7fffffe          BL       SPI_Flash_ReadSR
000008  07c0              LSLS     r0,r0,#31
00000a  d1fb              BNE      |L12.4|
;;;298    }  
00000c  bd00              POP      {pc}
;;;299    //进入掉电模式
                          ENDP


                          AREA ||i.SPI_Flash_Write||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Write PROC
;;;220    u8 SPI_FLASH_BUF[4096];
;;;221    void SPI_Flash_Write(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;222    { 
;;;223    	u32 secpos;
;;;224    	u16 secoff;
;;;225    	u16 secremain;	   
;;;226     	u16 i;  
;;;227    	secpos=WriteAddr/4096;//扇区地址 0~511 for w25x16
;;;228    	secoff=WriteAddr%4096;//在扇区内的偏移
000004  f3c1060b          UBFX     r6,r1,#0,#12
000008  0b0f              LSRS     r7,r1,#12             ;227
;;;229    	secremain=4096-secoff;//扇区剩余空间大小   
00000a  f5c65480          RSB      r4,r6,#0x1000
00000e  4682              MOV      r10,r0                ;222
000010  4688              MOV      r8,r1                 ;222
000012  4615              MOV      r5,r2                 ;222
;;;230    	if(NumByteToWrite<=secremain)secremain=NumByteToWrite;//不大于4096个字节
000014  42a2              CMP      r2,r4
000016  d800              BHI      |L13.26|
000018  4614              MOV      r4,r2
                  |L13.26|
;;;231    	while(1) 
;;;232    	{	
;;;233    		SPI_Flash_Read(SPI_FLASH_BUF,secpos*4096,4096);//读出整个扇区的内容
00001a  f8df907c          LDR      r9,|L13.152|
00001e  f44f5b80          MOV      r11,#0x1000
                  |L13.34|
000022  0339              LSLS     r1,r7,#12
000024  465a              MOV      r2,r11
000026  481c              LDR      r0,|L13.152|
000028  9100              STR      r1,[sp,#0]
00002a  f7fffffe          BL       SPI_Flash_Read
;;;234    		for(i=0;i<secremain;i++)//校验数据
00002e  2000              MOVS     r0,#0
000030  e006              B        |L13.64|
                  |L13.50|
;;;235    		{
;;;236    			if(SPI_FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除  	  
000032  1832              ADDS     r2,r6,r0
000034  f8191002          LDRB     r1,[r9,r2]
000038  29ff              CMP      r1,#0xff
00003a  d103              BNE      |L13.68|
00003c  1c40              ADDS     r0,r0,#1              ;234
00003e  b280              UXTH     r0,r0                 ;234
                  |L13.64|
000040  42a0              CMP      r0,r4                 ;234
000042  d3f6              BCC      |L13.50|
                  |L13.68|
;;;237    		}
;;;238    		if(i<secremain)//需要擦除
000044  42a0              CMP      r0,r4
000046  d220              BCS      |L13.138|
;;;239    		{
;;;240    			SPI_Flash_Erase_Sector(secpos);//擦除这个扇区
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       SPI_Flash_Erase_Sector
;;;241    			for(i=0;i<secremain;i++)	   //复制
00004e  2000              MOVS     r0,#0
000050  4649              MOV      r1,r9                 ;233
000052  e005              B        |L13.96|
                  |L13.84|
;;;242    			{
;;;243    				SPI_FLASH_BUF[i+secoff]=pBuffer[i];	  
000054  f81a2000          LDRB     r2,[r10,r0]
000058  1983              ADDS     r3,r0,r6
00005a  1c40              ADDS     r0,r0,#1              ;241
00005c  54ca              STRB     r2,[r1,r3]
00005e  b280              UXTH     r0,r0                 ;241
                  |L13.96|
000060  42a0              CMP      r0,r4                 ;241
000062  d3f7              BCC      |L13.84|
;;;244    			}
;;;245    			SPI_Flash_Write_NoCheck(SPI_FLASH_BUF,secpos*4096,4096);//写入整个扇区  
000064  465a              MOV      r2,r11
000066  480c              LDR      r0,|L13.152|
000068  f8dd1000          LDR.W    r1,[sp,#0]
                  |L13.108|
;;;246    
;;;247    		}else SPI_Flash_Write_NoCheck(pBuffer,WriteAddr,secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   
00006c  f7fffffe          BL       SPI_Flash_Write_NoCheck
;;;248    		if(NumByteToWrite==secremain)break;//写入结束了
000070  42a5              CMP      r5,r4
000072  d00e              BEQ      |L13.146|
;;;249    		else//写入未结束
;;;250    		{
;;;251    			secpos++;//扇区地址增1
;;;252    			secoff=0;//偏移位置为0 	 
;;;253    
;;;254    		   	pBuffer+=secremain;  //指针偏移
;;;255    			WriteAddr+=secremain;//写地址偏移	   
;;;256    		   	NumByteToWrite-=secremain;				//字节数递减
000074  1b28              SUBS     r0,r5,r4
000076  44a2              ADD      r10,r10,r4            ;254
000078  44a0              ADD      r8,r8,r4              ;255
00007a  1c7f              ADDS     r7,r7,#1              ;251
00007c  2600              MOVS     r6,#0                 ;252
00007e  b285              UXTH     r5,r0
;;;257    			if(NumByteToWrite>4096)secremain=4096;	//下一个扇区还是写不完
000080  465c              MOV      r4,r11
000082  42a5              CMP      r5,r4
000084  d8cd              BHI      |L13.34|
;;;258    			else secremain=NumByteToWrite;			//下一个扇区可以写完了
000086  462c              MOV      r4,r5
000088  e7cb              B        |L13.34|
                  |L13.138|
00008a  4622              MOV      r2,r4                 ;247
00008c  4641              MOV      r1,r8                 ;247
00008e  4650              MOV      r0,r10                ;247
000090  e7ec              B        |L13.108|
                  |L13.146|
;;;259    		}	 
;;;260    	};	 	 
;;;261    }
000092  e8bd8ff8          POP      {r3-r11,pc}
;;;262    
                          ENDP

000096  0000              DCW      0x0000
                  |L13.152|
                          DCD      ||.bss||

                          AREA ||i.SPI_Flash_Write_NoCheck||, CODE, READONLY, ALIGN=1

                  SPI_Flash_Write_NoCheck PROC
;;;193    //CHECK OK
;;;194    void SPI_Flash_Write_NoCheck(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;195    { 			 		 
000004  4607              MOV      r7,r0
;;;196    	u16 pageremain;	   
;;;197    	pageremain=256-WriteAddr%256; //单页剩余的字节数		 	    
000006  b2c8              UXTB     r0,r1
000008  f5c07480          RSB      r4,r0,#0x100
00000c  460e              MOV      r6,r1                 ;195
00000e  4615              MOV      r5,r2                 ;195
;;;198    	if(NumByteToWrite<=pageremain)pageremain=NumByteToWrite;//不大于256个字节
000010  42a2              CMP      r2,r4
000012  d800              BHI      |L14.22|
000014  4614              MOV      r4,r2
                  |L14.22|
;;;199    	while(1)
;;;200    	{	   
;;;201    		SPI_Flash_Write_Page(pBuffer,WriteAddr,pageremain);
;;;202    		if(NumByteToWrite==pageremain)break;//写入结束了
;;;203    	 	else //NumByteToWrite>pageremain
;;;204    		{
;;;205    			pBuffer+=pageremain;
;;;206    			WriteAddr+=pageremain;	
;;;207    
;;;208    			NumByteToWrite-=pageremain;			  //减去已经写入了的字节数
;;;209    			if(NumByteToWrite>256)pageremain=256; //一次可以写入256个字节
000016  f44f7880          MOV      r8,#0x100
                  |L14.26|
00001a  4622              MOV      r2,r4                 ;201
00001c  4631              MOV      r1,r6                 ;201
00001e  4638              MOV      r0,r7                 ;201
000020  f7fffffe          BL       SPI_Flash_Write_Page
000024  42a5              CMP      r5,r4                 ;202
000026  d008              BEQ      |L14.58|
000028  1b28              SUBS     r0,r5,r4              ;208
00002a  4427              ADD      r7,r7,r4              ;205
00002c  4426              ADD      r6,r6,r4              ;206
00002e  b285              UXTH     r5,r0                 ;208
000030  4644              MOV      r4,r8
000032  42a5              CMP      r5,r4
000034  d8f1              BHI      |L14.26|
;;;210    			else pageremain=NumByteToWrite; 	  //不够256个字节了
000036  462c              MOV      r4,r5
000038  e7ef              B        |L14.26|
                  |L14.58|
;;;211    		}
;;;212    	};	    
;;;213    } 
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;214    //写SPI FLASH  
                          ENDP


                          AREA ||i.SPI_Flash_Write_Page||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Write_Page PROC
;;;172    //NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 
;;;173    void SPI_Flash_Write_Page(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)
000000  b5f0              PUSH     {r4-r7,lr}
;;;174    {
000002  4607              MOV      r7,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;175     	u16 i;  
;;;176        SPI_FLASH_Write_Enable();                  //SET WEL 
000008  f7fffffe          BL       SPI_FLASH_Write_Enable
;;;177    	SPI_FLASH_CS=0;                            //使能器件   
00000c  4e10              LDR      r6,|L15.80|
00000e  2000              MOVS     r0,#0
000010  f8c60190          STR      r0,[r6,#0x190]
;;;178        SPIx_ReadWriteByte(W25X_PageProgram);      //发送写页命令   
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       SPIx_ReadWriteByte
;;;179        SPIx_ReadWriteByte((u8)((WriteAddr)>>16)); //发送24bit地址    
00001a  f3c44007          UBFX     r0,r4,#16,#8
00001e  f7fffffe          BL       SPIx_ReadWriteByte
;;;180        SPIx_ReadWriteByte((u8)((WriteAddr)>>8));   
000022  f3c42007          UBFX     r0,r4,#8,#8
000026  f7fffffe          BL       SPIx_ReadWriteByte
;;;181        SPIx_ReadWriteByte((u8)WriteAddr);   
00002a  b2e0              UXTB     r0,r4
00002c  f7fffffe          BL       SPIx_ReadWriteByte
;;;182        for(i=0;i<NumByteToWrite;i++)SPIx_ReadWriteByte(pBuffer[i]);//循环写数  
000030  2400              MOVS     r4,#0
000032  e004              B        |L15.62|
                  |L15.52|
000034  5d38              LDRB     r0,[r7,r4]
000036  f7fffffe          BL       SPIx_ReadWriteByte
00003a  1c64              ADDS     r4,r4,#1
00003c  b2a4              UXTH     r4,r4
                  |L15.62|
00003e  42ac              CMP      r4,r5
000040  d3f8              BCC      |L15.52|
;;;183    	SPI_FLASH_CS=1;                            //取消片选 
000042  2001              MOVS     r0,#1
000044  f8c60190          STR      r0,[r6,#0x190]
;;;184    	SPI_Flash_Wait_Busy();					   //等待写入结束
000048  e8bd40f0          POP      {r4-r7,lr}
00004c  f7ffbffe          B.W      SPI_Flash_Wait_Busy
;;;185    } 
;;;186    //无检验写SPI FLASH 
                          ENDP

                  |L15.80|
                          DCD      0x42220000

                          AREA ||i.SPIx_Init||, CODE, READONLY, ALIGN=2

                  SPIx_Init PROC
;;;14     //本例程选用SPI2对W25X16进行读写操作，对SPI2进行初始化
;;;15     void SPIx_Init(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;16     {
;;;17     	SPI_InitTypeDef  SPI_InitStructure;
;;;18     	GPIO_InitTypeDef GPIO_InitStructure;
;;;19     	
;;;20     	/* Enable SPI2 and GPIOA clocks */
;;;21     	
;;;22     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
000002  2101              MOVS     r1,#1
000004  b087              SUB      sp,sp,#0x1c           ;16
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;23     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;24     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
000014  2101              MOVS     r1,#1
000016  2010              MOVS     r0,#0x10
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;25     	
;;;26     	/* Configure SPI2 pins: NSS, SCK, MISO and MOSI */
;;;27     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_5;
00001c  f2460020          MOV      r0,#0x6020
000020  f8ad0014          STRH     r0,[sp,#0x14]
;;;28     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2503              MOVS     r5,#3
000026  f88d5016          STRB     r5,[sp,#0x16]
;;;29     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00002a  2018              MOVS     r0,#0x18
;;;30     	GPIO_Init(GPIOB, &GPIO_InitStructure);
00002c  4e24              LDR      r6,|L16.192|
00002e  f88d0017          STRB     r0,[sp,#0x17]         ;29
000032  a905              ADD      r1,sp,#0x14
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       GPIO_Init
;;;31     	
;;;32     	//SPI2 NSS 
;;;33         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
00003a  2410              MOVS     r4,#0x10
00003c  f8ad4014          STRH     r4,[sp,#0x14]
;;;34         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;35         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;36         GPIO_Init(GPIOC, &GPIO_InitStructure);
000040  4f20              LDR      r7,|L16.196|
000042  f88d5016          STRB     r5,[sp,#0x16]         ;34
000046  f88d4017          STRB     r4,[sp,#0x17]         ;35
00004a  a905              ADD      r1,sp,#0x14
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       GPIO_Init
;;;37     
;;;38     	GPIO_SetBits(GPIOC, GPIO_Pin_4); 
000052  2110              MOVS     r1,#0x10
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       GPIO_SetBits
;;;39     
;;;40         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
00005a  0220              LSLS     r0,r4,#8
00005c  f8ad0014          STRH     r0,[sp,#0x14]
;;;41         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000060  f88d5016          STRB     r5,[sp,#0x16]
;;;42         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000064  f88d4017          STRB     r4,[sp,#0x17]
;;;43         GPIO_Init(GPIOB, &GPIO_InitStructure);
000068  a905              ADD      r1,sp,#0x14
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       GPIO_Init
;;;44     	GPIO_SetBits(GPIOB, GPIO_Pin_4);   
000070  2110              MOVS     r1,#0x10
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       GPIO_SetBits
;;;45     
;;;46     	/* SPI2 configuration */ 
;;;47     	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //SPI2设置为两线全双工
000078  2000              MOVS     r0,#0
00007a  f8ad0000          STRH     r0,[sp,#0]
;;;48     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;	                   //设置SPI2为主模式
;;;49     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;                  //SPI发送接收8位帧结构
00007e  f8ad0004          STRH     r0,[sp,#4]
000082  f44f7182          MOV      r1,#0x104             ;48
000086  f8ad1002          STRH     r1,[sp,#2]            ;48
;;;50     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;	 		               //串行时钟在不操作时，时钟为高电平
00008a  2102              MOVS     r1,#2
00008c  f8ad1006          STRH     r1,[sp,#6]
;;;51     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		               //第二个时钟沿开始采样数据
;;;52     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			               //NSS信号由软件（使用SSI位）管理
;;;53     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8; //定义波特率预分频的值:波特率预分频值为8
000090  f8ad400c          STRH     r4,[sp,#0xc]
000094  2101              MOVS     r1,#1                 ;51
000096  f8ad1008          STRH     r1,[sp,#8]            ;51
;;;54     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;				   //数据传输从MSB位开始
00009a  f8ad000e          STRH     r0,[sp,#0xe]
00009e  0249              LSLS     r1,r1,#9              ;52
;;;55     	SPI_InitStructure.SPI_CRCPolynomial = 7;						   //CRC值计算的多项式
0000a0  2007              MOVS     r0,#7
;;;56     	SPI_Init(SPI2, &SPI_InitStructure);
0000a2  4c09              LDR      r4,|L16.200|
0000a4  f8ad100a          STRH     r1,[sp,#0xa]          ;52
0000a8  f8ad0010          STRH     r0,[sp,#0x10]         ;55
0000ac  4669              MOV      r1,sp
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       SPI_Init
;;;57     	/* Enable SPI2  */
;;;58     	SPI_Cmd(SPI2, ENABLE); 											  //使能SPI2外设
0000b4  2101              MOVS     r1,#1
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       SPI_Cmd
;;;59     }   
0000bc  b007              ADD      sp,sp,#0x1c
0000be  bdf0              POP      {r4-r7,pc}
;;;60     
                          ENDP

                  |L16.192|
                          DCD      0x40010c00
                  |L16.196|
                          DCD      0x40011000
                  |L16.200|
                          DCD      0x40003800

                          AREA ||i.SPIx_ReadWriteByte||, CODE, READONLY, ALIGN=2

                  SPIx_ReadWriteByte PROC
;;;62     //返回值:读取到的字节
;;;63     u8 SPIx_ReadWriteByte(u8 TxData)
000000  2100              MOVS     r1,#0
;;;64     {		
;;;65     	u8 retry=0;				 
;;;66     	while((SPI2->SR&1<<1)==0)//等待发送区空	
000002  4a0d              LDR      r2,|L17.56|
;;;67     	{
;;;68     		retry++;
;;;69     		if(retry>200)return 0;
000004  e003              B        |L17.14|
                  |L17.6|
000006  1c49              ADDS     r1,r1,#1              ;68
000008  b2c9              UXTB     r1,r1                 ;68
00000a  29c8              CMP      r1,#0xc8
00000c  d80b              BHI      |L17.38|
                  |L17.14|
00000e  8813              LDRH     r3,[r2,#0]            ;66
000010  079b              LSLS     r3,r3,#30             ;66
000012  d5f8              BPL      |L17.6|
;;;70     	}			  
;;;71     	SPI2->DR=TxData;	 	  //发送一个byte 
000014  4908              LDR      r1,|L17.56|
000016  1d09              ADDS     r1,r1,#4
000018  8008              STRH     r0,[r1,#0]
;;;72     	retry=0;
00001a  2000              MOVS     r0,#0
;;;73     	while((SPI2->SR&1<<0)==0) //等待接收完一个byte  
00001c  e005              B        |L17.42|
                  |L17.30|
;;;74     	{
;;;75     		retry++;
00001e  1c40              ADDS     r0,r0,#1
000020  b2c0              UXTB     r0,r0
;;;76     		if(retry>200)return 0;
000022  28c8              CMP      r0,#0xc8
000024  d901              BLS      |L17.42|
                  |L17.38|
000026  2000              MOVS     r0,#0
;;;77     	}	  						    
;;;78     	return SPI2->DR;          //返回收到的数据				    
;;;79     }
000028  4770              BX       lr
                  |L17.42|
00002a  8813              LDRH     r3,[r2,#0]            ;73
00002c  07db              LSLS     r3,r3,#31             ;73
00002e  d0f6              BEQ      |L17.30|
000030  8808              LDRH     r0,[r1,#0]            ;78
000032  b2c0              UXTB     r0,r0                 ;78
000034  4770              BX       lr
;;;80     
                          ENDP

000036  0000              DCW      0x0000
                  |L17.56|
                          DCD      0x40003808

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  SPI_FLASH_BUF
                          %        4096
