; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -ostm32f10x_it.o --asm_dir=.\ --list_dir=.\ --depend=stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\RTD -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=stm32f10x_it.crf ..\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
                  |L1.0|
;;;111      */
;;;112    void BusFault_Handler(void)
000000  e7fe              B        |L1.0|
;;;113    {
;;;114      /* Go to infinite loop when Bus Fault exception occurs */
;;;115      while (1)
;;;116      {
;;;117      }
;;;118    }
;;;119    
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;146      */
;;;147    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;148    {
;;;149    }
;;;150    
                          ENDP


                          AREA ||i.EXTI15_10_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI15_10_IRQHandler PROC
;;;276    
;;;277    void EXTI15_10_IRQHandler(void)
000000  4770              BX       lr
;;;278    {
;;;279    
;;;280    }
;;;281    /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L4.0|
;;;85       */
;;;86     void HardFault_Handler(void)
000000  e7fe              B        |L4.0|
;;;87     {
;;;88       /* Go to infinite loop when Hard Fault exception occurs */
;;;89       while (1)
;;;90       {
;;;91       }
;;;92     }
;;;93     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
                  |L5.0|
;;;98       */
;;;99     void MemManage_Handler(void)
000000  e7fe              B        |L5.0|
;;;100    {
;;;101      /* Go to infinite loop when Memory Manage exception occurs */
;;;102      while (1)
;;;103      {
;;;104      }
;;;105    }
;;;106    
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;76       */
;;;77     void NMI_Handler(void)
000000  4770              BX       lr
;;;78     {
;;;79     }
;;;80     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;155      */
;;;156    void PendSV_Handler(void)
000000  4770              BX       lr
;;;157    {
;;;158    }
;;;159    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;137      */
;;;138    void SVC_Handler(void)
000000  4770              BX       lr
;;;139    {
;;;140    }
;;;141    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;164      */
;;;165    void SysTick_Handler(void)
000000  4770              BX       lr
;;;166    {
;;;167    }
;;;168    
                          ENDP


                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=1

                  TIM2_IRQHandler PROC
;;;189    
;;;190    void TIM2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;191    {
;;;192    				 
;;;193      if(TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
000002  2101              MOVS     r1,#1
000004  078c              LSLS     r4,r1,#30
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       TIM_GetITStatus
00000c  2800              CMP      r0,#0
00000e  d007              BEQ      |L10.32|
;;;194      { 
;;;195       	 TIM_ClearITPendingBit(TIM2, TIM_FLAG_Update); 
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_ClearITPendingBit
;;;196    	 DataProcess();
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      DataProcess
                  |L10.32|
;;;197    
;;;198      }	    	   
;;;199    
;;;200       
;;;201    }
000020  bd10              POP      {r4,pc}
;;;202    
                          ENDP


                          AREA ||i.TIM4_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM4_IRQHandler PROC
;;;203    /*定时器4中断处理，clean the receive buffer*/
;;;204    void TIM4_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;205    {     
;;;206       u8 i;
;;;207       if (TIM_GetITStatus(TIM4, TIM_IT_Update) == SET)
000002  4c12              LDR      r4,|L11.76|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       TIM_GetITStatus
00000c  2801              CMP      r0,#1
00000e  d11b              BNE      |L11.72|
;;;208       {
;;;209          TIM_ClearITPendingBit(TIM4,TIM_FLAG_Update); 
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_ClearITPendingBit
;;;210    	  
;;;211    	  mCount++;
000018  4a0d              LDR      r2,|L11.80|
00001a  7890              LDRB     r0,[r2,#2]  ; mCount
00001c  1c40              ADDS     r0,r0,#1
00001e  b2c0              UXTB     r0,r0
000020  7090              STRB     r0,[r2,#2]
;;;212    	  if(mCount==0x25)			  //22
000022  2825              CMP      r0,#0x25
000024  d110              BNE      |L11.72|
;;;213    	  {
;;;214    	     mCount=0;
000026  2300              MOVS     r3,#0
;;;215    	     for(i=0;i<24;i++)
;;;216    		 {
;;;217    		    ReceivedBufTemp[i]=0x00; 
000028  480a              LDR      r0,|L11.84|
00002a  7093              STRB     r3,[r2,#2]            ;214
00002c  4619              MOV      r1,r3                 ;215
                  |L11.46|
00002e  5443              STRB     r3,[r0,r1]
000030  1c49              ADDS     r1,r1,#1              ;215
000032  b2c9              UXTB     r1,r1                 ;215
000034  2918              CMP      r1,#0x18              ;215
000036  d3fa              BCC      |L11.46|
;;;218    		 }
;;;219             num=0;  		
000038  7013              STRB     r3,[r2,#0]
;;;220             TIM_ITConfig(TIM4, TIM_IT_Update, DISABLE); 
00003a  4620              MOV      r0,r4
00003c  2200              MOVS     r2,#0
00003e  e8bd4010          POP      {r4,lr}
000042  2101              MOVS     r1,#1
000044  f7ffbffe          B.W      TIM_ITConfig
                  |L11.72|
;;;221    	  }		
;;;222       }
;;;223    }
000048  bd10              POP      {r4,pc}
;;;224    
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      0x40000800
                  |L11.80|
                          DCD      ||area_number.26||
                  |L11.84|
                          DCD      ||.bss||+0x18

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;224    
;;;225    void USART1_IRQHandler(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;226    { 
;;;227         u8 i=0,isTrue=0;
;;;228    
;;;229        if(USART_GetFlagStatus(USART1,USART_FLAG_ORE)==SET)
000004  4d34              LDR      r5,|L12.216|
000006  2400              MOVS     r4,#0                 ;227
000008  4627              MOV      r7,r4                 ;227
00000a  2108              MOVS     r1,#8
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       USART_GetFlagStatus
000012  2801              CMP      r0,#1
000014  d106              BNE      |L12.36|
;;;230        {
;;;231            USART_ClearFlag(USART1,USART_FLAG_ORE); //读SR其实就是清除标志
000016  2108              MOVS     r1,#8
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       USART_ClearFlag
;;;232            USART_ReceiveData(USART1);		
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_ReceiveData
                  |L12.36|
;;;233        }
;;;234    
;;;235        if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET)
000024  f2405b25          MOV      r11,#0x525
000028  4659              MOV      r1,r11
00002a  46aa              MOV      r10,r5
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       USART_GetITStatus
;;;236        {
;;;237            ReceivedBufTemp[num]=USART_ReceiveData(USART1);
000032  4d2a              LDR      r5,|L12.220|
000034  f8df80a8          LDR      r8,|L12.224|
000038  b1a8              CBZ      r0,|L12.102|
00003a  4656              MOV      r6,r10
00003c  4650              MOV      r0,r10
00003e  f7fffffe          BL       USART_ReceiveData
000042  4601              MOV      r1,r0
000044  7828              LDRB     r0,[r5,#0]  ; num
000046  f8081000          STRB     r1,[r8,r0]
;;;238            num++;
00004a  1c40              ADDS     r0,r0,#1
00004c  b2c0              UXTB     r0,r0
00004e  7028              STRB     r0,[r5,#0]
;;;239            
;;;240    		if(num==1)
000050  2801              CMP      r0,#1
000052  d104              BNE      |L12.94|
;;;241            {
;;;242                TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);
000054  2201              MOVS     r2,#1
000056  4611              MOV      r1,r2
000058  4822              LDR      r0,|L12.228|
00005a  f7fffffe          BL       TIM_ITConfig
                  |L12.94|
;;;243            }
;;;244    		 USART_ClearITPendingBit(USART1,USART_IT_RXNE);
00005e  4659              MOV      r1,r11
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       USART_ClearITPendingBit
                  |L12.102|
;;;245        }     
;;;246        if(num==24)
000066  7828              LDRB     r0,[r5,#0]  ; num
000068  f04f0901          MOV      r9,#1                 ;237
00006c  2818              CMP      r0,#0x18
00006e  d128              BNE      |L12.194|
;;;247        {
;;;248            num=0;
000070  2600              MOVS     r6,#0
000072  702e              STRB     r6,[r5,#0]
;;;249            format=1;
000074  f8859001          STRB     r9,[r5,#1]
;;;250            if((ReceivedBufTemp[0]!=0x55)||(ReceivedBufTemp[1]!=0x66)||(ReceivedBufTemp[22]!=0x66)||(ReceivedBufTemp[23]!=0x55))
000078  f8980000          LDRB     r0,[r8,#0]  ; ReceivedBufTemp
00007c  2855              CMP      r0,#0x55
00007e  d10b              BNE      |L12.152|
000080  f8981001          LDRB     r1,[r8,#1]  ; ReceivedBufTemp
000084  4640              MOV      r0,r8
000086  2966              CMP      r1,#0x66
000088  d106              BNE      |L12.152|
00008a  7d81              LDRB     r1,[r0,#0x16]  ; ReceivedBufTemp
00008c  2966              CMP      r1,#0x66
00008e  d103              BNE      |L12.152|
000090  f8980017          LDRB     r0,[r8,#0x17]  ; ReceivedBufTemp
000094  2855              CMP      r0,#0x55
000096  d001              BEQ      |L12.156|
                  |L12.152|
;;;251                format=0;
000098  706e              STRB     r6,[r5,#1]
00009a  e003              B        |L12.164|
                  |L12.156|
;;;252    		if(format)
;;;253    	        isTrue =  CheckReceivedData(ReceivedBufTemp)  ;
00009c  4810              LDR      r0,|L12.224|
00009e  f7fffffe          BL       CheckReceivedData
0000a2  b2c7              UXTB     r7,r0
                  |L12.164|
;;;254            if(format&isTrue)
0000a4  7868              LDRB     r0,[r5,#1]  ; format
0000a6  4238              TST      r0,r7
0000a8  d00a              BEQ      |L12.192|
;;;255            {
;;;256                for(i=0;i<24;i++) 
;;;257                    ReceivedBuffer[i]=ReceivedBufTemp[i];
0000aa  490d              LDR      r1,|L12.224|
0000ac  4640              MOV      r0,r8                 ;237
0000ae  3918              SUBS     r1,r1,#0x18
                  |L12.176|
0000b0  5d02              LDRB     r2,[r0,r4]
0000b2  550a              STRB     r2,[r1,r4]
0000b4  1c64              ADDS     r4,r4,#1              ;256
0000b6  b2e4              UXTB     r4,r4                 ;256
0000b8  2c18              CMP      r4,#0x18              ;256
0000ba  d3f9              BCC      |L12.176|
;;;258    		     	SendProcess();
0000bc  f7fffffe          BL       SendProcess
                  |L12.192|
;;;259    				num=0;
;;;260    				isTrue=0;
;;;261            }
;;;262    		else
;;;263    		num=0;
0000c0  702e              STRB     r6,[r5,#0]
                  |L12.194|
0000c2  4909              LDR      r1,|L12.232|
;;;264    
;;;265    }
;;;266           DE1=1;
0000c4  f8c19000          STR      r9,[r1,#0]
;;;267    	   USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); 
0000c8  4659              MOV      r1,r11
0000ca  4650              MOV      r0,r10
0000cc  e8bd5ff0          POP      {r4-r12,lr}
0000d0  f04f0201          MOV      r2,#1
0000d4  f7ffbffe          B.W      USART_ITConfig
;;;268    
;;;269    
;;;270    }
;;;271    void Usart_SendChar(char dat)
                          ENDP

                  |L12.216|
                          DCD      0x40013800
                  |L12.220|
                          DCD      ||area_number.26||
                  |L12.224|
                          DCD      ||.bss||+0x18
                  |L12.228|
                          DCD      0x40000800
                  |L12.232|
                          DCD      0x422101ac

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
                  |L13.0|
;;;124      */
;;;125    void UsageFault_Handler(void)
000000  e7fe              B        |L13.0|
;;;126    {
;;;127      /* Go to infinite loop when Usage Fault exception occurs */
;;;128      while (1)
;;;129      {
;;;130      }
;;;131    }
;;;132    
                          ENDP


                          AREA ||i.Usart_SendChar||, CODE, READONLY, ALIGN=2

                  Usart_SendChar PROC
;;;270    }
;;;271    void Usart_SendChar(char dat)
000000  b570              PUSH     {r4-r6,lr}
;;;272    {
;;;273        while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);//等待上一个字节发送完毕
000002  4c07              LDR      r4,|L14.32|
000004  4605              MOV      r5,r0                 ;272
                  |L14.6|
000006  2140              MOVS     r1,#0x40
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L14.6|
;;;274        USART_SendData(USART1,dat);   
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  e8bd4070          POP      {r4-r6,lr}
00001a  f7ffbffe          B.W      USART_SendData
;;;275    }
;;;276    
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ReceivedBuffer
                          %        24
                  ReceivedBufTemp
                          %        24

                          AREA ||area_number.17||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.17||, ||.bss||
                  SentBuffer
                          %        24

                          AREA ||.data||, DATA, ALIGN=0

                  UIreceivedCount
000000  00                DCB      0x00

                          AREA ||area_number.20||, DATA, ALIGN=0

                          EXPORTAS ||area_number.20||, ||.data||
                  receivedCount
000000  00                DCB      0x00

                          AREA ||area_number.21||, DATA, ALIGN=0

                          EXPORTAS ||area_number.21||, ||.data||
                  receiveFlag
000000  00                DCB      0x00

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  UIreceiveFlag
000000  00                DCB      0x00

                          AREA ||area_number.23||, DATA, ALIGN=1

                          EXPORTAS ||area_number.23||, ||.data||
                  SumRec
000000  0000              DCW      0x0000

                          AREA ||area_number.24||, DATA, ALIGN=1

                          EXPORTAS ||area_number.24||, ||.data||
                  SumCal
000000  0000              DCW      0x0000

                          AREA ||area_number.25||, DATA, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.data||
                  timercnt
                          DCD      0x00000000

                          AREA ||area_number.26||, DATA, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.data||
                  num
000000  00                DCB      0x00
                  format
000001  00                DCB      0x00
                  mCount
000002  00                DCB      0x00

                          AREA ||area_number.27||, DATA, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.data||
                  ReceivedNum
                          DCD      0x00000000

                          AREA ||area_number.28||, DATA, ALIGN=0

                          EXPORTAS ||area_number.28||, ||.data||
                  nCount
000000  00                DCB      0x00
