; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -ostm32f10x_i2c.o --asm_dir=.\ --list_dir=.\ --depend=stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\RTD -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=stm32f10x_i2c.crf ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;793      */
;;;794    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;795    {
;;;796      /* Check the parameters */
;;;797      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;798      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;799      if (NewState != DISABLE)
;;;800      {
;;;801        /* Enable the selected I2C ARP */
;;;802        I2Cx->CR1 |= CR1_ENARP_Set;
;;;803      }
;;;804      else
;;;805      {
;;;806        /* Disable the selected I2C ARP */
;;;807        I2Cx->CR1 &= CR1_ENARP_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L1.12|
000006  f0410110          ORR      r1,r1,#0x10           ;802
00000a  e001              B        |L1.16|
                  |L1.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L1.16|
000010  8001              STRH     r1,[r0,#0]            ;802
;;;808      }
;;;809    }
000012  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;440      */
;;;441    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;442    {
;;;443      /* Check the parameters */
;;;444      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;445      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;446      if (NewState != DISABLE)
;;;447      {
;;;448        /* Enable the acknowledgement */
;;;449        I2Cx->CR1 |= CR1_ACK_Set;
;;;450      }
;;;451      else
;;;452      {
;;;453        /* Disable the acknowledgement */
;;;454        I2Cx->CR1 &= CR1_ACK_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  f4416180          ORR      r1,r1,#0x400          ;449
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L2.16|
000010  8001              STRH     r1,[r0,#0]            ;449
;;;455      }
;;;456    }
000012  4770              BX       lr
;;;457    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;756      */
;;;757    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;758    {
;;;759      /* Check the parameters */
;;;760      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;761      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;762      if (NewState != DISABLE)
;;;763      {
;;;764        /* Enable the selected I2C PEC calculation */
;;;765        I2Cx->CR1 |= CR1_ENPEC_Set;
;;;766      }
;;;767      else
;;;768      {
;;;769        /* Disable the selected I2C PEC calculation */
;;;770        I2Cx->CR1 &= CR1_ENPEC_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410120          ORR      r1,r1,#0x20           ;765
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;765
;;;771      }
;;;772    }
000012  4770              BX       lr
;;;773    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;983      */
;;;984    ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  8a83              LDRH     r3,[r0,#0x14]
;;;985    {
;;;986      uint32_t lastevent = 0;
;;;987      uint32_t flag1 = 0, flag2 = 0;
;;;988      ErrorStatus status = ERROR;
000002  2200              MOVS     r2,#0
;;;989    
;;;990      /* Check the parameters */
;;;991      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;992      assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;993    
;;;994      /* Read the I2Cx status register */
;;;995      flag1 = I2Cx->SR1;
;;;996      flag2 = I2Cx->SR2;
000004  8b00              LDRH     r0,[r0,#0x18]
;;;997      flag2 = flag2 << 16;
;;;998    
;;;999      /* Get the last event value from I2C status register */
;;;1000     lastevent = (flag1 | flag2) & FLAG_Mask;
000006  ea434300          ORR      r3,r3,r0,LSL #16
00000a  f023407f          BIC      r0,r3,#0xff000000
;;;1001   
;;;1002     /* Check whether the last event contains the I2C_EVENT */
;;;1003     if ((lastevent & I2C_EVENT) == I2C_EVENT)
00000e  4381              BICS     r1,r1,r0
000010  d100              BNE      |L4.20|
;;;1004     {
;;;1005       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1006       status = SUCCESS;
000012  2201              MOVS     r2,#1
                  |L4.20|
;;;1007     }
;;;1008     else
;;;1009     {
;;;1010       /* ERROR: last event is different from I2C_EVENT */
;;;1011       status = ERROR;
;;;1012     }
;;;1013     /* Return status */
;;;1014     return status;
000014  4610              MOV      r0,r2
;;;1015   }
000016  4770              BX       lr
;;;1016   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1165     */
;;;1166   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1167   {
;;;1168     uint32_t flagpos = 0;
;;;1169     /* Check the parameters */
;;;1170     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1171     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1172     /* Get the I2C flag position */
;;;1173     flagpos = I2C_FLAG & FLAG_Mask;
;;;1174     /* Clear the selected I2C flag */
;;;1175     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1176   }
000004  4770              BX       lr
;;;1177   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1260     */
;;;1261   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1262   {
;;;1263     uint32_t flagpos = 0;
;;;1264     /* Check the parameters */
;;;1265     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1266     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1267     /* Get the I2C flag position */
;;;1268     flagpos = I2C_IT & FLAG_Mask;
;;;1269     /* Clear the selected I2C flag */
;;;1270     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1271   }
000004  4770              BX       lr
;;;1272   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;320      */
;;;321    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;322    {
;;;323      /* Check the parameters */
;;;324      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;325      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;326      if (NewState != DISABLE)
;;;327      {
;;;328        /* Enable the selected I2C peripheral */
;;;329        I2Cx->CR1 |= CR1_PE_Set;
;;;330      }
;;;331      else
;;;332      {
;;;333        /* Disable the selected I2C peripheral */
;;;334        I2Cx->CR1 &= CR1_PE_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L7.12|
000006  f0410101          ORR      r1,r1,#1              ;329
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L7.16|
000010  8001              STRH     r1,[r0,#0]            ;329
;;;335      }
;;;336    }
000012  4770              BX       lr
;;;337    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;344      */
;;;345    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;346    {
;;;347      /* Check the parameters */
;;;348      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;349      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;350      if (NewState != DISABLE)
;;;351      {
;;;352        /* Enable the selected I2C DMA requests */
;;;353        I2Cx->CR2 |= CR2_DMAEN_Set;
;;;354      }
;;;355      else
;;;356      {
;;;357        /* Disable the selected I2C DMA requests */
;;;358        I2Cx->CR2 &= CR2_DMAEN_Reset;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L8.12|
000006  f4416100          ORR      r1,r1,#0x800          ;353
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L8.16|
000010  8081              STRH     r1,[r0,#4]            ;353
;;;359      }
;;;360    }
000012  4770              BX       lr
;;;361    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;368      */
;;;369    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;370    {
;;;371      /* Check the parameters */
;;;372      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;373      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;374      if (NewState != DISABLE)
;;;375      {
;;;376        /* Next DMA transfer is the last transfer */
;;;377        I2Cx->CR2 |= CR2_LAST_Set;
;;;378      }
;;;379      else
;;;380      {
;;;381        /* Next DMA transfer is not the last transfer */
;;;382        I2Cx->CR2 &= CR2_LAST_Reset;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L9.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;377
00000a  e001              B        |L9.16|
                  |L9.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L9.16|
000010  8081              STRH     r1,[r0,#4]            ;377
;;;383      }
;;;384    }
000012  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;160      */
;;;161    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  4909              LDR      r1,|L10.40|
;;;162    {
000002  b510              PUSH     {r4,lr}
;;;163      /* Check the parameters */
;;;164      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;165    
;;;166      if (I2Cx == I2C1)
000004  4288              CMP      r0,r1
;;;167      {
;;;168        /* Enable I2C1 reset state */
;;;169        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;170        /* Release I2C1 from reset state */
;;;171        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
;;;172      }
;;;173      else
;;;174      {
;;;175        /* Enable I2C2 reset state */
;;;176        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000006  f04f0101          MOV      r1,#1
00000a  d101              BNE      |L10.16|
00000c  054c              LSLS     r4,r1,#21             ;169
00000e  e001              B        |L10.20|
                  |L10.16|
000010  f44f0480          MOV      r4,#0x400000
                  |L10.20|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;177        /* Release I2C2 from reset state */
;;;178        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00001a  4620              MOV      r0,r4
00001c  e8bd4010          POP      {r4,lr}
000020  2100              MOVS     r1,#0
000022  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;179      }
;;;180    }
;;;181    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x40005400

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;490      */
;;;491    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;495      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;496      if (NewState != DISABLE)
;;;497      {
;;;498        /* Enable dual addressing mode */
;;;499        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Disable dual addressing mode */
;;;504        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L11.12|
000006  f0410101          ORR      r1,r1,#1              ;499
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L11.16|
000010  8181              STRH     r1,[r0,#0xc]          ;499
;;;505      }
;;;506    }
000012  4770              BX       lr
;;;507    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;843      */
;;;844    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;845    {
;;;846      /* Check the parameters */
;;;847      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;848      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;849      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;850      {
;;;851        /* I2C fast mode Tlow/Thigh=2 */
;;;852        I2Cx->CCR &= I2C_DutyCycle_2;
;;;853      }
;;;854      else
;;;855      {
;;;856        /* I2C fast mode Tlow/Thigh=16/9 */
;;;857        I2Cx->CCR |= I2C_DutyCycle_16_9;
000004  8b81              LDRH     r1,[r0,#0x1c]
000006  d002              BEQ      |L12.14|
000008  f4214180          BIC      r1,r1,#0x4000         ;852
00000c  e001              B        |L12.18|
                  |L12.14|
00000e  f4414180          ORR      r1,r1,#0x4000
                  |L12.18|
000012  8381              STRH     r1,[r0,#0x1c]         ;852
;;;858      }
;;;859    }
000014  4770              BX       lr
;;;860    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;514      */
;;;515    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;516    {
;;;517      /* Check the parameters */
;;;518      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;519      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;520      if (NewState != DISABLE)
;;;521      {
;;;522        /* Enable generall call */
;;;523        I2Cx->CR1 |= CR1_ENGC_Set;
;;;524      }
;;;525      else
;;;526      {
;;;527        /* Disable generall call */
;;;528        I2Cx->CR1 &= CR1_ENGC_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L13.12|
000006  f0410140          ORR      r1,r1,#0x40           ;523
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f0210140          BIC      r1,r1,#0x40
                  |L13.16|
000010  8001              STRH     r1,[r0,#0]            ;523
;;;529      }
;;;530    }
000012  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;392      */
;;;393    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;394    {
;;;395      /* Check the parameters */
;;;396      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;397      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;398      if (NewState != DISABLE)
;;;399      {
;;;400        /* Generate a START condition */
;;;401        I2Cx->CR1 |= CR1_START_Set;
;;;402      }
;;;403      else
;;;404      {
;;;405        /* Disable the START condition generation */
;;;406        I2Cx->CR1 &= CR1_START_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L14.12|
000006  f4417180          ORR      r1,r1,#0x100          ;401
00000a  e001              B        |L14.16|
                  |L14.12|
00000c  f4217180          BIC      r1,r1,#0x100
                  |L14.16|
000010  8001              STRH     r1,[r0,#0]            ;401
;;;407      }
;;;408    }
000012  4770              BX       lr
;;;409    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;416      */
;;;417    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;421      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;422      if (NewState != DISABLE)
;;;423      {
;;;424        /* Generate a STOP condition */
;;;425        I2Cx->CR1 |= CR1_STOP_Set;
;;;426      }
;;;427      else
;;;428      {
;;;429        /* Disable the STOP condition generation */
;;;430        I2Cx->CR1 &= CR1_STOP_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f4417100          ORR      r1,r1,#0x200          ;425
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f4217100          BIC      r1,r1,#0x200
                  |L15.16|
000010  8001              STRH     r1,[r0,#0]            ;425
;;;431      }
;;;432    }
000012  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1086     */
;;;1087   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  2200              MOVS     r2,#0
;;;1088   {
;;;1089     FlagStatus bitstatus = RESET;
;;;1090     __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;1091   
;;;1092     /* Check the parameters */
;;;1093     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1094     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1095   
;;;1096     /* Get the I2Cx peripheral base address */
;;;1097     i2cxbase = (uint32_t)I2Cx;
;;;1098     
;;;1099     /* Read flag register index */
;;;1100     i2creg = I2C_FLAG >> 28;
000002  0f0b              LSRS     r3,r1,#28
;;;1101     
;;;1102     /* Get bit[23:0] of the flag */
;;;1103     I2C_FLAG &= FLAG_Mask;
000004  f021417f          BIC      r1,r1,#0xff000000
;;;1104     
;;;1105     if(i2creg != 0)
000008  d001              BEQ      |L16.14|
;;;1106     {
;;;1107       /* Get the I2Cx SR1 register address */
;;;1108       i2cxbase += 0x14;
00000a  3014              ADDS     r0,r0,#0x14
00000c  e001              B        |L16.18|
                  |L16.14|
;;;1109     }
;;;1110     else
;;;1111     {
;;;1112       /* Flag in I2Cx SR2 Register */
;;;1113       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
00000e  0c09              LSRS     r1,r1,#16
;;;1114       /* Get the I2Cx SR2 register address */
;;;1115       i2cxbase += 0x18;
000010  3018              ADDS     r0,r0,#0x18
                  |L16.18|
;;;1116     }
;;;1117     
;;;1118     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
000012  6800              LDR      r0,[r0,#0]
000014  4208              TST      r0,r1
000016  d000              BEQ      |L16.26|
;;;1119     {
;;;1120       /* I2C_FLAG is set */
;;;1121       bitstatus = SET;
000018  2201              MOVS     r2,#1
                  |L16.26|
;;;1122     }
;;;1123     else
;;;1124     {
;;;1125       /* I2C_FLAG is reset */
;;;1126       bitstatus = RESET;
;;;1127     }
;;;1128     
;;;1129     /* Return the I2C_FLAG status */
;;;1130     return  bitstatus;
00001a  4610              MOV      r0,r2
;;;1131   }
00001c  4770              BX       lr
;;;1132   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1199     */
;;;1200   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1201   {
;;;1202     ITStatus bitstatus = RESET;
;;;1203     uint32_t enablestatus = 0;
;;;1204   
;;;1205     /* Check the parameters */
;;;1206     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1207     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1208   
;;;1209     /* Check if the interrupt source is enabled or not */
;;;1210     enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
000002  8883              LDRH     r3,[r0,#4]
000004  2200              MOVS     r2,#0                 ;1202
000006  f00164e0          AND      r4,r1,#0x7000000
;;;1211     
;;;1212     /* Get bit[23:0] of the flag */
;;;1213     I2C_IT &= FLAG_Mask;
;;;1214   
;;;1215     /* Check the status of the specified I2C flag */
;;;1216     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
00000a  8a80              LDRH     r0,[r0,#0x14]
00000c  ea034314          AND      r3,r3,r4,LSR #16      ;1210
000010  f021417f          BIC      r1,r1,#0xff000000     ;1213
000014  4208              TST      r0,r1
000016  d001              BEQ      |L17.28|
000018  b103              CBZ      r3,|L17.28|
;;;1217     {
;;;1218       /* I2C_IT is set */
;;;1219       bitstatus = SET;
00001a  2201              MOVS     r2,#1
                  |L17.28|
;;;1220     }
;;;1221     else
;;;1222     {
;;;1223       /* I2C_IT is reset */
;;;1224       bitstatus = RESET;
;;;1225     }
;;;1226     /* Return the I2C_IT status */
;;;1227     return  bitstatus;
00001c  4610              MOV      r0,r2
;;;1228   }
00001e  bd10              POP      {r4,pc}
;;;1229   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1031     */
;;;1032   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  8a81              LDRH     r1,[r0,#0x14]
;;;1033   {
;;;1034     uint32_t lastevent = 0;
;;;1035     uint32_t flag1 = 0, flag2 = 0;
;;;1036   
;;;1037     /* Check the parameters */
;;;1038     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1039   
;;;1040     /* Read the I2Cx status register */
;;;1041     flag1 = I2Cx->SR1;
;;;1042     flag2 = I2Cx->SR2;
000002  8b00              LDRH     r0,[r0,#0x18]
;;;1043     flag2 = flag2 << 16;
;;;1044   
;;;1045     /* Get the last event value from I2C status register */
;;;1046     lastevent = (flag1 | flag2) & FLAG_Mask;
000004  ea414100          ORR      r1,r1,r0,LSL #16
000008  f021407f          BIC      r0,r1,#0xff000000
;;;1047   
;;;1048     /* Return status */
;;;1049     return lastevent;
;;;1050   }
00000c  4770              BX       lr
;;;1051   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;778      */
;;;779    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  8b00              LDRH     r0,[r0,#0x18]
;;;780    {
;;;781      /* Check the parameters */
;;;782      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;783      /* Return the selected I2C PEC value */
;;;784      return ((I2Cx->SR2) >> 8);
000002  0a00              LSRS     r0,r0,#8
;;;785    }
000004  4770              BX       lr
;;;786    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;543      */
;;;544    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;545    {
;;;546      /* Check the parameters */
;;;547      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;548      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;549      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;550      
;;;551      if (NewState != DISABLE)
;;;552      {
;;;553        /* Enable the selected I2C interrupts */
;;;554        I2Cx->CR2 |= I2C_IT;
;;;555      }
;;;556      else
;;;557      {
;;;558        /* Disable the selected I2C interrupts */
;;;559        I2Cx->CR2 &= (uint16_t)~I2C_IT;
000002  8882              LDRH     r2,[r0,#4]
000004  d001              BEQ      |L20.10|
000006  430a              ORRS     r2,r2,r1              ;554
000008  e000              B        |L20.12|
                  |L20.10|
00000a  438a              BICS     r2,r2,r1
                  |L20.12|
00000c  8082              STRH     r2,[r0,#4]            ;554
;;;560      }
;;;561    }
00000e  4770              BX       lr
;;;562    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;189      */
;;;190    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;191    {
000002  4604              MOV      r4,r0
;;;192      uint16_t tmpreg = 0, freqrange = 0;
;;;193      uint16_t result = 0x04;
;;;194      uint32_t pclk1 = 8000000;
;;;195      RCC_ClocksTypeDef  rcc_clocks;
;;;196      /* Check the parameters */
;;;197      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;198      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;199      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;200      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;201      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;202      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;203      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;204    
;;;205    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;206      /* Get the I2Cx CR2 value */
;;;207      tmpreg = I2Cx->CR2;
000004  8880              LDRH     r0,[r0,#4]
000006  b086              SUB      sp,sp,#0x18           ;191
000008  460d              MOV      r5,r1                 ;191
;;;208      /* Clear frequency FREQ[5:0] bits */
;;;209      tmpreg &= CR2_FREQ_Reset;
00000a  f020063f          BIC      r6,r0,#0x3f
;;;210      /* Get pclk1 frequency value */
;;;211      RCC_GetClocksFreq(&rcc_clocks);
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       RCC_GetClocksFreq
;;;212      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;213      /* Set frequency bits depending on pclk1 value */
;;;214      freqrange = (uint16_t)(pclk1 / 1000000);
000014  4926              LDR      r1,|L21.176|
000016  9802              LDR      r0,[sp,#8]
000018  fbb0f1f1          UDIV     r1,r0,r1
00001c  b289              UXTH     r1,r1
;;;215      tmpreg |= freqrange;
00001e  430e              ORRS     r6,r6,r1
;;;216      /* Write to I2Cx CR2 */
;;;217      I2Cx->CR2 = tmpreg;
000020  80a6              STRH     r6,[r4,#4]
;;;218    
;;;219    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;220      /* Disable the selected I2C peripheral to configure TRISE */
;;;221      I2Cx->CR1 &= CR1_PE_Reset;
000022  8822              LDRH     r2,[r4,#0]
000024  f0220201          BIC      r2,r2,#1
000028  8022              STRH     r2,[r4,#0]
;;;222      /* Reset tmpreg value */
;;;223      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;224      tmpreg = 0;
;;;225    
;;;226      /* Configure speed in standard mode */
;;;227      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
00002a  4b22              LDR      r3,|L21.180|
00002c  682a              LDR      r2,[r5,#0]
00002e  429a              CMP      r2,r3
000030  d81c              BHI      |L21.108|
;;;228      {
;;;229        /* Standard mode speed calculate */
;;;230        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000032  0052              LSLS     r2,r2,#1
000034  fbb0f0f2          UDIV     r0,r0,r2
000038  b280              UXTH     r0,r0
;;;231        /* Test if CCR value is under 0x4*/
;;;232        if (result < 0x04)
00003a  2804              CMP      r0,#4
00003c  d200              BCS      |L21.64|
;;;233        {
;;;234          /* Set minimum allowed value */
;;;235          result = 0x04;  
00003e  2004              MOVS     r0,#4
                  |L21.64|
;;;236        }
;;;237        /* Set speed value for standard mode */
;;;238        tmpreg |= result;	  
;;;239        /* Set Maximum Rise Time for standard mode */
;;;240        I2Cx->TRISE = freqrange + 1; 
000040  1c49              ADDS     r1,r1,#1
000042  8421              STRH     r1,[r4,#0x20]
;;;241      }
;;;242      /* Configure speed in fast mode */
;;;243      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;244      {
;;;245        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
;;;246        {
;;;247          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;248          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;249        }
;;;250        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;251        {
;;;252          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;253          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
;;;254          /* Set DUTY bit */
;;;255          result |= I2C_DutyCycle_16_9;
;;;256        }
;;;257    
;;;258        /* Test if CCR value is under 0x1*/
;;;259        if ((result & CCR_CCR_Set) == 0)
;;;260        {
;;;261          /* Set minimum allowed value */
;;;262          result |= (uint16_t)0x0001;  
;;;263        }
;;;264        /* Set speed value and set F/S bit for fast mode */
;;;265        tmpreg |= (uint16_t)(result | CCR_FS_Set);
;;;266        /* Set Maximum Rise Time for fast mode */
;;;267        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
;;;268      }
;;;269    
;;;270      /* Write to I2Cx CCR */
;;;271      I2Cx->CCR = tmpreg;
000044  83a0              STRH     r0,[r4,#0x1c]
;;;272      /* Enable the selected I2C peripheral */
;;;273      I2Cx->CR1 |= CR1_PE_Set;
000046  8820              LDRH     r0,[r4,#0]
000048  f0400001          ORR      r0,r0,#1
00004c  8020              STRH     r0,[r4,#0]
;;;274    
;;;275    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;276      /* Get the I2Cx CR1 value */
;;;277      tmpreg = I2Cx->CR1;
00004e  8821              LDRH     r1,[r4,#0]
;;;278      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;279      tmpreg &= CR1_CLEAR_Mask;
000050  f64f30f5          MOV      r0,#0xfbf5
000054  4001              ANDS     r1,r1,r0
;;;280      /* Configure I2Cx: mode and acknowledgement */
;;;281      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;282      /* Set ACK bit according to I2C_Ack value */
;;;283      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000056  88a8              LDRH     r0,[r5,#4]
000058  896a              LDRH     r2,[r5,#0xa]
00005a  4310              ORRS     r0,r0,r2
00005c  4308              ORRS     r0,r0,r1
;;;284      /* Write to I2Cx CR1 */
;;;285      I2Cx->CR1 = tmpreg;
00005e  8020              STRH     r0,[r4,#0]
;;;286    
;;;287    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;288      /* Set I2Cx Own Address1 and acknowledged address */
;;;289      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
000060  89a8              LDRH     r0,[r5,#0xc]
000062  8929              LDRH     r1,[r5,#8]
000064  4308              ORRS     r0,r0,r1
000066  8120              STRH     r0,[r4,#8]
;;;290    }
000068  b006              ADD      sp,sp,#0x18
00006a  bd70              POP      {r4-r6,pc}
                  |L21.108|
00006c  88eb              LDRH     r3,[r5,#6]            ;245
00006e  f5a3463f          SUB      r6,r3,#0xbf00         ;245
000072  3eff              SUBS     r6,r6,#0xff           ;245
000074  d105              BNE      |L21.130|
000076  eb020242          ADD      r2,r2,r2,LSL #1       ;248
00007a  fbb0f0f2          UDIV     r0,r0,r2              ;248
00007e  b280              UXTH     r0,r0                 ;248
000080  e008              B        |L21.148|
                  |L21.130|
000082  eb0203c2          ADD      r3,r2,r2,LSL #3       ;253
000086  eb031202          ADD      r2,r3,r2,LSL #4       ;253
00008a  fbb0f0f2          UDIV     r0,r0,r2              ;253
00008e  b280              UXTH     r0,r0                 ;253
000090  f4404080          ORR      r0,r0,#0x4000         ;255
                  |L21.148|
000094  0502              LSLS     r2,r0,#20             ;259
000096  d101              BNE      |L21.156|
000098  f0400001          ORR      r0,r0,#1              ;262
                  |L21.156|
00009c  f44f7296          MOV      r2,#0x12c             ;267
0000a0  4351              MULS     r1,r2,r1              ;267
0000a2  f44f727a          MOV      r2,#0x3e8             ;267
0000a6  fbb1f1f2          UDIV     r1,r1,r2              ;267
0000aa  f4404000          ORR      r0,r0,#0x8000         ;265
0000ae  e7c7              B        |L21.64|
;;;291    
                          ENDP

                  |L21.176|
                          DCD      0x000f4240
                  |L21.180|
                          DCD      0x000186a0

                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;463      */
;;;464    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  8982              LDRH     r2,[r0,#0xc]
;;;465    {
;;;466      uint16_t tmpreg = 0;
;;;467    
;;;468      /* Check the parameters */
;;;469      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;470    
;;;471      /* Get the old register value */
;;;472      tmpreg = I2Cx->OAR2;
;;;473    
;;;474      /* Reset I2Cx Own address2 bit [7:1] */
;;;475      tmpreg &= OAR2_ADD2_Reset;
;;;476    
;;;477      /* Set I2Cx Own address2 */
;;;478      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000002  f00101fe          AND      r1,r1,#0xfe
000006  f02202fe          BIC      r2,r2,#0xfe           ;475
00000a  4311              ORRS     r1,r1,r2
;;;479    
;;;480      /* Store the new register value */
;;;481      I2Cx->OAR2 = tmpreg;
00000c  8181              STRH     r1,[r0,#0xc]
;;;482    }
00000e  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;732      */
;;;733    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;734    {
;;;735      /* Check the parameters */
;;;736      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;737      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;738      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;739      {
;;;740        /* Next byte in shift register is PEC */
;;;741        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;742      }
;;;743      else
;;;744      {
;;;745        /* Current byte in shift register is PEC */
;;;746        I2Cx->CR1 &= I2C_PECPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L23.16|
000008  f4216100          BIC      r1,r1,#0x800
                  |L23.12|
00000c  8001              STRH     r1,[r0,#0]            ;741
;;;747      }
;;;748    }
00000e  4770              BX       lr
                  |L23.16|
000010  f4416100          ORR      r1,r1,#0x800          ;741
000014  e7fa              B        |L23.12|
;;;749    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;634      */
;;;635    uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  5a40              LDRH     r0,[r0,r1]
;;;636    {
;;;637      __IO uint32_t tmp = 0;
;;;638    
;;;639      /* Check the parameters */
;;;640      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;641      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;642    
;;;643      tmp = (uint32_t) I2Cx;
;;;644      tmp += I2C_Register;
;;;645    
;;;646      /* Return the selected register value */
;;;647      return (*(__IO uint16_t *) tmp);
;;;648    }
000002  4770              BX       lr
;;;649    
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;581      */
;;;582    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;583    {
;;;584      /* Check the parameters */
;;;585      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;586      /* Return the data in the DR register */
;;;587      return (uint8_t)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;588    }
000004  4770              BX       lr
;;;589    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;682      */
;;;683    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;684    {
;;;685      /* Check the parameters */
;;;686      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;687      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;688      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;689      {
;;;690        /* Drive the SMBusAlert pin Low */
;;;691        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;692      }
;;;693      else
;;;694      {
;;;695        /* Drive the SMBusAlert pin High  */
;;;696        I2Cx->CR1 &= I2C_SMBusAlert_High;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L26.16|
000008  f4215100          BIC      r1,r1,#0x2000
                  |L26.12|
00000c  8001              STRH     r1,[r0,#0]            ;691
;;;697      }
;;;698    }
00000e  4770              BX       lr
                  |L26.16|
000010  f4415100          ORR      r1,r1,#0x2000         ;691
000014  e7fa              B        |L26.12|
;;;699    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;599      */
;;;600    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L27.8|
;;;601    {
;;;602      /* Check the parameters */
;;;603      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;604      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;605      /* Test on the direction to set/reset the read/write bit */
;;;606      if (I2C_Direction != I2C_Direction_Transmitter)
;;;607      {
;;;608        /* Set the address bit0 for read */
;;;609        Address |= OAR1_ADD0_Set;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L27.12|
                  |L27.8|
;;;610      }
;;;611      else
;;;612      {
;;;613        /* Reset the address bit0 for write */
;;;614        Address &= OAR1_ADD0_Reset;
000008  f00101fe          AND      r1,r1,#0xfe
                  |L27.12|
;;;615      }
;;;616      /* Send the address */
;;;617      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;618    }
00000e  4770              BX       lr
;;;619    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;568      */
;;;569    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;570    {
;;;571      /* Check the parameters */
;;;572      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;573      /* Write in the DR register the data to be sent */
;;;574      I2Cx->DR = Data;
;;;575    }
000002  4770              BX       lr
;;;576    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;656      */
;;;657    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;658    {
;;;659      /* Check the parameters */
;;;660      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;661      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;662      if (NewState != DISABLE)
;;;663      {
;;;664        /* Peripheral under reset */
;;;665        I2Cx->CR1 |= CR1_SWRST_Set;
;;;666      }
;;;667      else
;;;668      {
;;;669        /* Peripheral not under reset */
;;;670        I2Cx->CR1 &= CR1_SWRST_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L29.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;665
00000a  e001              B        |L29.16|
                  |L29.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L29.16|
000010  8001              STRH     r1,[r0,#0]            ;665
;;;671      }
;;;672    }
000012  4770              BX       lr
;;;673    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;817      */
;;;818    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;819    {
;;;820      /* Check the parameters */
;;;821      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;822      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;823      if (NewState == DISABLE)
;;;824      {
;;;825        /* Enable the selected I2C Clock stretching */
;;;826        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
;;;827      }
;;;828      else
;;;829      {
;;;830        /* Disable the selected I2C Clock stretching */
;;;831        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d003              BEQ      |L30.14|
000006  f0210180          BIC      r1,r1,#0x80
                  |L30.10|
00000a  8001              STRH     r1,[r0,#0]            ;826
;;;832      }
;;;833    }
00000c  4770              BX       lr
                  |L30.14|
00000e  f0410180          ORR      r1,r1,#0x80           ;826
000012  e7fa              B        |L30.10|
;;;834    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;296      */
;;;297    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;298    {
;;;299    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;300      /* initialize the I2C_ClockSpeed member */
;;;301      I2C_InitStruct->I2C_ClockSpeed = 5000;
;;;302      /* Initialize the I2C_Mode member */
;;;303      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;304      /* Initialize the I2C_DutyCycle member */
;;;305      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b72ff          MOV      r2,#0xbfff
00000e  80c2              STRH     r2,[r0,#6]
;;;306      /* Initialize the I2C_OwnAddress1 member */
;;;307      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  8101              STRH     r1,[r0,#8]
;;;308      /* Initialize the I2C_Ack member */
;;;309      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000012  8141              STRH     r1,[r0,#0xa]
;;;310      /* Initialize the I2C_AcknowledgedAddress member */
;;;311      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000014  f44f4180          MOV      r1,#0x4000
000018  8181              STRH     r1,[r0,#0xc]
;;;312    }
00001a  4770              BX       lr
;;;313    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;706      */
;;;707    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;708    {
;;;709      /* Check the parameters */
;;;710      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;711      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;712      if (NewState != DISABLE)
;;;713      {
;;;714        /* Enable the selected I2C PEC transmission */
;;;715        I2Cx->CR1 |= CR1_PEC_Set;
;;;716      }
;;;717      else
;;;718      {
;;;719        /* Disable the selected I2C PEC transmission */
;;;720        I2Cx->CR1 &= CR1_PEC_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L32.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;715
00000a  e001              B        |L32.16|
                  |L32.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L32.16|
000010  8001              STRH     r1,[r0,#0]            ;715
;;;721      }
;;;722    }
000012  4770              BX       lr
;;;723    
                          ENDP

