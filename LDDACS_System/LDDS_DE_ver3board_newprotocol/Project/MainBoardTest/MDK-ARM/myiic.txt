; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -omyiic.o --asm_dir=.\ --list_dir=.\ --depend=myiic.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=myiic.crf ..\myiic.c]
                          THUMB

                          AREA ||i.IIC_Ack||, CODE, READONLY, ALIGN=2

                  IIC_Ack PROC
;;;71     //产生ACK应答
;;;72     void IIC_Ack(void)
000000  b570              PUSH     {r4-r6,lr}
;;;73     {
;;;74     	IIC_SCL=0;
000002  4c0c              LDR      r4,|L1.52|
000004  2500              MOVS     r5,#0
000006  6065              STR      r5,[r4,#4]
;;;75     	SDA_OUT();
000008  480b              LDR      r0,|L1.56|
00000a  6801              LDR      r1,[r0,#0]
00000c  f4216170          BIC      r1,r1,#0xf00
000010  6001              STR      r1,[r0,#0]
000012  6801              LDR      r1,[r0,#0]
000014  f4417140          ORR      r1,r1,#0x300
000018  6001              STR      r1,[r0,#0]
;;;76     	IIC_SDA=0;
00001a  6025              STR      r5,[r4,#0]
;;;77     	delay_us(2);
00001c  f04f0002          MOV      r0,#2
000020  f7fffffe          BL       delay_us
;;;78     	IIC_SCL=1;
000024  2001              MOVS     r0,#1
000026  6060              STR      r0,[r4,#4]
;;;79     	delay_us(2);
000028  2002              MOVS     r0,#2
00002a  f7fffffe          BL       delay_us
;;;80     	IIC_SCL=0;
00002e  6065              STR      r5,[r4,#4]
;;;81     }
000030  bd70              POP      {r4-r6,pc}
;;;82     //不产生ACK应答		    
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x42240188
                  |L1.56|
                          DCD      0x40012000

                          AREA ||i.IIC_Init||, CODE, READONLY, ALIGN=2

                  IIC_Init PROC
;;;16     //初始化IIC
;;;17     void IIC_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;18     {					     
;;;19     	GPIO_InitTypeDef GPIO_InitStructure;
;;;20     	RCC_APB2PeriphClockCmd(	RCC_APB2Periph_GPIOG, ENABLE );	
000002  2101              MOVS     r1,#1
000004  0208              LSLS     r0,r1,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;21     	   
;;;22     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_2;
00000a  200c              MOVS     r0,#0xc
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;23     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;   //推挽输出
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;24     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
;;;25     	GPIO_Init(GPIOG, &GPIO_InitStructure);
000018  4c05              LDR      r4,|L2.48|
00001a  f88d0002          STRB     r0,[sp,#2]            ;24
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       GPIO_Init
;;;26     	GPIO_SetBits(GPIOG,GPIO_Pin_3|GPIO_Pin_2); 	//PB10,PB11 输出高
000026  210c              MOVS     r1,#0xc
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       GPIO_SetBits
;;;27     }
00002e  bd38              POP      {r3-r5,pc}
;;;28     //产生IIC起始信号
                          ENDP

                  |L2.48|
                          DCD      0x40012000

                          AREA ||i.IIC_NAck||, CODE, READONLY, ALIGN=2

                  IIC_NAck PROC
;;;82     //不产生ACK应答		    
;;;83     void IIC_NAck(void)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
;;;85     	IIC_SCL=0;
000002  4c0c              LDR      r4,|L3.52|
000004  2500              MOVS     r5,#0
000006  6065              STR      r5,[r4,#4]
;;;86     	SDA_OUT();
000008  480b              LDR      r0,|L3.56|
00000a  6801              LDR      r1,[r0,#0]
00000c  f4216170          BIC      r1,r1,#0xf00
000010  6001              STR      r1,[r0,#0]
000012  6801              LDR      r1,[r0,#0]
000014  f4417140          ORR      r1,r1,#0x300
000018  6001              STR      r1,[r0,#0]
;;;87     	IIC_SDA=1;
00001a  f04f0601          MOV      r6,#1
00001e  6026              STR      r6,[r4,#0]
;;;88     	delay_us(2);
000020  f04f0002          MOV      r0,#2
000024  f7fffffe          BL       delay_us
;;;89     	IIC_SCL=1;
000028  6066              STR      r6,[r4,#4]
;;;90     	delay_us(2);
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       delay_us
;;;91     	IIC_SCL=0;
000030  6065              STR      r5,[r4,#4]
;;;92     }					 				     
000032  bd70              POP      {r4-r6,pc}
;;;93     //IIC发送一个字节
                          ENDP

                  |L3.52|
                          DCD      0x42240188
                  |L3.56|
                          DCD      0x40012000

                          AREA ||i.IIC_Read_Byte||, CODE, READONLY, ALIGN=2

                  IIC_Read_Byte PROC
;;;117    //读1个字节，ack=1时，发送ACK，ack=0，发送nACK   
;;;118    u8 IIC_Read_Byte(unsigned char ack)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;119    {
000004  4681              MOV      r9,r0
;;;120    	unsigned char i,receive=0;
;;;121    	SDA_IN();//SDA设置为输入
000006  4817              LDR      r0,|L4.100|
000008  2400              MOVS     r4,#0                 ;120
00000a  6801              LDR      r1,[r0,#0]
00000c  f4216170          BIC      r1,r1,#0xf00
000010  6001              STR      r1,[r0,#0]
000012  6801              LDR      r1,[r0,#0]
000014  f4416100          ORR      r1,r1,#0x800
000018  6001              STR      r1,[r0,#0]
;;;122        for(i=0;i<8;i++ )
;;;123    	{
;;;124            IIC_SCL=0; 
00001a  4e13              LDR      r6,|L4.104|
00001c  4625              MOV      r5,r4                 ;122
00001e  4627              MOV      r7,r4                 ;120
;;;125            delay_us(2);
;;;126    		IIC_SCL=1;
000020  f04f0801          MOV      r8,#1
                  |L4.36|
000024  f8c6718c          STR      r7,[r6,#0x18c]        ;124
000028  2002              MOVS     r0,#2                 ;125
00002a  f7fffffe          BL       delay_us
00002e  f8c6818c          STR      r8,[r6,#0x18c]
;;;127            receive<<=1;
000032  0660              LSLS     r0,r4,#25
000034  0e04              LSRS     r4,r0,#24
;;;128            if(READ_SDA)receive++;   
000036  f8d60108          LDR      r0,[r6,#0x108]
00003a  b108              CBZ      r0,|L4.64|
00003c  1c64              ADDS     r4,r4,#1
00003e  b2e4              UXTB     r4,r4
                  |L4.64|
;;;129    		delay_us(1); 
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       delay_us
000046  1c6d              ADDS     r5,r5,#1              ;122
000048  b2ed              UXTB     r5,r5                 ;122
00004a  2d08              CMP      r5,#8                 ;122
00004c  d3ea              BCC      |L4.36|
;;;130        }					 
;;;131        if (!ack)
00004e  f1b90f00          CMP      r9,#0
000052  d004              BEQ      |L4.94|
;;;132            IIC_NAck();//发送nACK
;;;133        else
;;;134            IIC_Ack(); //发送ACK   
000054  f7fffffe          BL       IIC_Ack
                  |L4.88|
;;;135        return receive;
000058  4620              MOV      r0,r4
;;;136    }
00005a  e8bd87f0          POP      {r4-r10,pc}
                  |L4.94|
00005e  f7fffffe          BL       IIC_NAck
000062  e7f9              B        |L4.88|
;;;137    
                          ENDP

                  |L4.100|
                          DCD      0x40012000
                  |L4.104|
                          DCD      0x42240000

                          AREA ||i.IIC_Send_Byte||, CODE, READONLY, ALIGN=2

                  IIC_Send_Byte PROC
;;;96     //0，无应答			  
;;;97     void IIC_Send_Byte(u8 txd)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;98     {                        
000004  4606              MOV      r6,r0
;;;99         u8 t;   
;;;100    	SDA_OUT(); 	    
000006  4816              LDR      r0,|L5.96|
000008  6801              LDR      r1,[r0,#0]
00000a  f4216170          BIC      r1,r1,#0xf00
00000e  6001              STR      r1,[r0,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f4417140          ORR      r1,r1,#0x300
000016  6001              STR      r1,[r0,#0]
;;;101        IIC_SCL=0;//拉低时钟开始数据传输
000018  4c12              LDR      r4,|L5.100|
00001a  2700              MOVS     r7,#0
00001c  f8c4718c          STR      r7,[r4,#0x18c]
;;;102        for(t=0;t<8;t++)
000020  463d              MOV      r5,r7
;;;103        {              
;;;104            //IIC_SDA=(txd&0x80)>>7;
;;;105    		if((txd&0x80)>>7)
;;;106    			IIC_SDA=1;
000022  f04f0801          MOV      r8,#1
                  |L5.38|
000026  0630              LSLS     r0,r6,#24             ;105
000028  d502              BPL      |L5.48|
00002a  f8c48188          STR      r8,[r4,#0x188]
00002e  e001              B        |L5.52|
                  |L5.48|
;;;107    		else
;;;108    			IIC_SDA=0;
000030  f8c47188          STR      r7,[r4,#0x188]
                  |L5.52|
;;;109    		txd<<=1; 	  
000034  0670              LSLS     r0,r6,#25
000036  0e06              LSRS     r6,r0,#24
;;;110    		delay_us(2);   //对TEA5767这三个延时都是必须的
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       delay_us
;;;111    		IIC_SCL=1;
00003e  f8c4818c          STR      r8,[r4,#0x18c]
;;;112    		delay_us(2); 
000042  2002              MOVS     r0,#2
000044  f7fffffe          BL       delay_us
;;;113    		IIC_SCL=0;	
000048  f8c4718c          STR      r7,[r4,#0x18c]
;;;114    		delay_us(2);
00004c  2002              MOVS     r0,#2
00004e  f7fffffe          BL       delay_us
000052  1c6d              ADDS     r5,r5,#1              ;102
000054  b2ed              UXTB     r5,r5                 ;102
000056  2d08              CMP      r5,#8                 ;102
000058  d3e5              BCC      |L5.38|
;;;115        }	 
;;;116    } 	    
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;117    //读1个字节，ack=1时，发送ACK，ack=0，发送nACK   
                          ENDP

00005e  0000              DCW      0x0000
                  |L5.96|
                          DCD      0x40012000
                  |L5.100|
                          DCD      0x42240000

                          AREA ||i.IIC_Start||, CODE, READONLY, ALIGN=2

                  IIC_Start PROC
;;;28     //产生IIC起始信号
;;;29     void IIC_Start(void)
000000  b570              PUSH     {r4-r6,lr}
;;;30     {
;;;31     	SDA_OUT();     //sda线输出
000002  480c              LDR      r0,|L6.52|
000004  6801              LDR      r1,[r0,#0]
000006  f4216170          BIC      r1,r1,#0xf00
00000a  6001              STR      r1,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f4417140          ORR      r1,r1,#0x300
000012  6001              STR      r1,[r0,#0]
;;;32     	IIC_SDA=1;	  	  
000014  4c08              LDR      r4,|L6.56|
000016  2001              MOVS     r0,#1
000018  6020              STR      r0,[r4,#0]
;;;33     	IIC_SCL=1;
00001a  6060              STR      r0,[r4,#4]
;;;34     	delay_us(4);
00001c  f04f0004          MOV      r0,#4
000020  f7fffffe          BL       delay_us
;;;35      	IIC_SDA=0;//START:when CLK is high,DATA change form high to low 
000024  2500              MOVS     r5,#0
000026  6025              STR      r5,[r4,#0]
;;;36     	delay_us(4);
000028  2004              MOVS     r0,#4
00002a  f7fffffe          BL       delay_us
;;;37     	IIC_SCL=0;//钳住I2C总线，准备发送或接收数据 
00002e  6065              STR      r5,[r4,#4]
;;;38     }	  
000030  bd70              POP      {r4-r6,pc}
;;;39     //产生IIC停止信号
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40012000
                  |L6.56|
                          DCD      0x42240188

                          AREA ||i.IIC_Stop||, CODE, READONLY, ALIGN=2

                  IIC_Stop PROC
;;;39     //产生IIC停止信号
;;;40     void IIC_Stop(void)
000000  480c              LDR      r0,|L7.52|
;;;41     {
000002  b510              PUSH     {r4,lr}
;;;42     	SDA_OUT();//sda线输出
000004  6801              LDR      r1,[r0,#0]
000006  f4216170          BIC      r1,r1,#0xf00
00000a  6001              STR      r1,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f4417140          ORR      r1,r1,#0x300
000012  6001              STR      r1,[r0,#0]
;;;43     	IIC_SCL=0;
000014  4c08              LDR      r4,|L7.56|
000016  2000              MOVS     r0,#0
000018  6060              STR      r0,[r4,#4]
;;;44     	IIC_SDA=0;//STOP:when CLK is high DATA change form low to high
00001a  6020              STR      r0,[r4,#0]
;;;45      	delay_us(4);
00001c  f04f0004          MOV      r0,#4
000020  f7fffffe          BL       delay_us
;;;46     	IIC_SCL=1; 
000024  2001              MOVS     r0,#1
000026  6060              STR      r0,[r4,#4]
;;;47     	IIC_SDA=1;//发送I2C总线结束信号
000028  6020              STR      r0,[r4,#0]
;;;48     	delay_us(4);							   	
00002a  e8bd4010          POP      {r4,lr}
00002e  2004              MOVS     r0,#4
000030  f7ffbffe          B.W      delay_us
;;;49     }
;;;50     //等待应答信号到来
                          ENDP

                  |L7.52|
                          DCD      0x40012000
                  |L7.56|
                          DCD      0x42240188

                          AREA ||i.IIC_Wait_Ack||, CODE, READONLY, ALIGN=2

                  IIC_Wait_Ack PROC
;;;52     //        0，接收应答成功
;;;53     u8 IIC_Wait_Ack(void)
000000  b570              PUSH     {r4-r6,lr}
;;;54     {
;;;55     	u8 ucErrTime=0;
;;;56     	SDA_IN();      //SDA设置为输入  
000002  4813              LDR      r0,|L8.80|
000004  2400              MOVS     r4,#0                 ;55
000006  6801              LDR      r1,[r0,#0]
000008  f4216170          BIC      r1,r1,#0xf00
00000c  6001              STR      r1,[r0,#0]
00000e  6801              LDR      r1,[r0,#0]
000010  f4416100          ORR      r1,r1,#0x800
000014  6001              STR      r1,[r0,#0]
;;;57     	IIC_SDA=1;delay_us(1);	   
000016  4d0f              LDR      r5,|L8.84|
000018  2601              MOVS     r6,#1
00001a  f8c56188          STR      r6,[r5,#0x188]
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       delay_us
;;;58     	IIC_SCL=1;delay_us(1);	 
000024  f8c5618c          STR      r6,[r5,#0x18c]
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       delay_us
;;;59     	while(READ_SDA)
00002e  e007              B        |L8.64|
                  |L8.48|
;;;60     	{
;;;61     		ucErrTime++;
000030  1c64              ADDS     r4,r4,#1
000032  b2e4              UXTB     r4,r4
;;;62     		if(ucErrTime>250)
000034  2cfa              CMP      r4,#0xfa
000036  d903              BLS      |L8.64|
;;;63     		{
;;;64     			IIC_Stop();
000038  f7fffffe          BL       IIC_Stop
;;;65     			return 1;
00003c  2001              MOVS     r0,#1
;;;66     		}
;;;67     	}
;;;68     	IIC_SCL=0;//时钟输出0 	   
;;;69     	return 0;  
;;;70     } 
00003e  bd70              POP      {r4-r6,pc}
                  |L8.64|
000040  f8d50108          LDR      r0,[r5,#0x108]        ;59
000044  2800              CMP      r0,#0                 ;59
000046  d1f3              BNE      |L8.48|
000048  f8c5018c          STR      r0,[r5,#0x18c]        ;68
00004c  bd70              POP      {r4-r6,pc}
;;;71     //产生ACK应答
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      0x40012000
                  |L8.84|
                          DCD      0x42240000
