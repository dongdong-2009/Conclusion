; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -oads1115.o --asm_dir=.\ --list_dir=.\ --depend=ads1115.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=ads1115.crf ..\ADS1115.c]
                          THUMB

                          AREA ||i.ADC_allchannels||, CODE, READONLY, ALIGN=1

                  ADC_allchannels PROC
;;;255    
;;;256    void ADC_allchannels(float *adc_value,char* flag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;257    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;258      	int i;
;;;259    	for(i = 0; i < 12; i++)
000008  2400              MOVS     r4,#0
;;;260    	{
;;;261    	  adc_value[i]= ReadAdOfChannel(i,flag[i]);
;;;262    	//  ReadAdOfChannel(unsigned char  Channel,unsigned char CurrentFlag)
;;;263    	  delay_us(2000);
00000a  f44f67fa          MOV      r7,#0x7d0
                  |L1.14|
00000e  5d31              LDRB     r1,[r6,r4]            ;261
000010  b2e0              UXTB     r0,r4                 ;261
000012  f7fffffe          BL       ReadAdOfChannel
000016  f8450024          STR      r0,[r5,r4,LSL #2]     ;261
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       delay_us
000020  1c64              ADDS     r4,r4,#1              ;259
000022  2c0c              CMP      r4,#0xc               ;259
000024  dbf3              BLT      |L1.14|
;;;264    	}
;;;265    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;266    //-----------------------------------------------//
                          ENDP


                          AREA ||i.AD_init||, CODE, READONLY, ALIGN=2

                  AD_init PROC
;;;30     //---------------------------------------------------------//
;;;31     void AD_init(unsigned char id,unsigned char write_address,unsigned char byte1,unsigned char byte2)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;32     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;33     	__disable_irq();   // 关闭总中断
00000c  b672              CPSID    i
;;;34     	IIC_Start();
00000e  f7fffffe          BL       IIC_Start
;;;35     	//产生起始条件
;;;36     	IIC_Send_Byte(id);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       IIC_Send_Byte
                  |L2.24|
;;;37     	//向设备发送设备地址
;;;38     	while( IIC_Wait_Ack());
000018  f7fffffe          BL       IIC_Wait_Ack
00001c  2800              CMP      r0,#0
00001e  d1fb              BNE      |L2.24|
;;;39     	//等待ACK
;;;40     	IIC_Send_Byte(write_address) ;//配置寄存器
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       IIC_Send_Byte
;;;41     	//寄存器地址
;;;42     	while( IIC_Wait_Ack());
000026  bf00              NOP      
                  |L2.40|
000028  f7fffffe          BL       IIC_Wait_Ack
00002c  2800              CMP      r0,#0
00002e  d1fb              BNE      |L2.40|
;;;43     	delay_us(4);
000030  2004              MOVS     r0,#4
000032  f7fffffe          BL       delay_us
;;;44     	//等待ACK
;;;45     	IIC_Send_Byte(byte1) ;//c-an0 d-an1 e-an2 f-an3  0->6.144 2->4.096,高字节配置
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       IIC_Send_Byte
                  |L2.60|
;;;46     	//发送数据
;;;47     	while(IIC_Wait_Ack());
00003c  f7fffffe          BL       IIC_Wait_Ack
000040  2800              CMP      r0,#0
000042  d1fb              BNE      |L2.60|
;;;48     	//发送完成
;;;49     	IIC_Send_Byte(byte2);//低字节 最高转换速度
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       IIC_Send_Byte
;;;50     	while(IIC_Wait_Ack());
00004a  bf00              NOP      
                  |L2.76|
00004c  f7fffffe          BL       IIC_Wait_Ack
000050  2800              CMP      r0,#0
000052  d1fb              BNE      |L2.76|
;;;51     	//发送完成
;;;52     	IIC_Stop();
000054  f7fffffe          BL       IIC_Stop
;;;53     	//产生结束信号
;;;54     	__enable_irq();    // 开启总中断
000058  b662              CPSIE    i
;;;55     }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;56     //----------------------------------------------------//
                          ENDP


                          AREA ||i.I2C_ADpoint||, CODE, READONLY, ALIGN=2

                  I2C_ADpoint PROC
;;;56     //----------------------------------------------------//
;;;57     void I2C_ADpoint(unsigned char id,unsigned char write_address)
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;59     	__disable_irq();   // 关闭总中断
000006  b672              CPSID    i
;;;60     	IIC_Start();
000008  f7fffffe          BL       IIC_Start
;;;61     	//产生起始条件
;;;62     	IIC_Send_Byte(id);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       IIC_Send_Byte
;;;63     	//向设备发送设备地址
;;;64     	while(IIC_Wait_Ack());
000012  bf00              NOP      
                  |L3.20|
000014  f7fffffe          BL       IIC_Wait_Ack
000018  2800              CMP      r0,#0
00001a  d1fb              BNE      |L3.20|
;;;65     	//等待ACK
;;;66     	IIC_Send_Byte(write_address);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       IIC_Send_Byte
;;;67     	//寄存器地址
;;;68     	while(IIC_Wait_Ack());
000022  bf00              NOP      
                  |L3.36|
000024  f7fffffe          BL       IIC_Wait_Ack
000028  2800              CMP      r0,#0
00002a  d1fb              BNE      |L3.36|
;;;69     
;;;70     	IIC_Stop();
00002c  f7fffffe          BL       IIC_Stop
;;;71     	//产生结束信号
;;;72     	__enable_irq();    // 开启总中断
000030  b662              CPSIE    i
;;;73     }
000032  bd70              POP      {r4-r6,pc}
;;;74     
                          ENDP


                          AREA ||i.I2C_Read2||, CODE, READONLY, ALIGN=2

                  I2C_Read2 PROC
;;;123    //----------------------------------------------------------//
;;;124    void I2C_Read2(unsigned char  id, unsigned char read_address)
000000  b510              PUSH     {r4,lr}
;;;125    {  
000002  4604              MOV      r4,r0
;;;126    	__disable_irq();   // 关闭总中断
000004  b672              CPSID    i
;;;127      	IIC_Start();
000006  f7fffffe          BL       IIC_Start
;;;128      	//产生起始信号
;;;129      	IIC_Send_Byte(id);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       IIC_Send_Byte
                  |L4.16|
;;;130    	//发送地址
;;;131      	while(IIC_Wait_Ack());
000010  f7fffffe          BL       IIC_Wait_Ack
000014  2800              CMP      r0,#0
000016  d1fb              BNE      |L4.16|
;;;132    	//等待ACK
;;;133      	//IIC_Send_Byte(read_address);
;;;134    	//发送读得地址
;;;135      	//while(IIC_Wait_Ack());
;;;136    	
;;;137      	 BUF[1] = IIC_Read_Byte(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       IIC_Read_Byte
00001e  4c06              LDR      r4,|L4.56|
000020  7060              STRB     r0,[r4,#1]
;;;138    	//重新发送
;;;139      	delay_us(5);
000022  2005              MOVS     r0,#5
000024  f7fffffe          BL       delay_us
;;;140    	BUF[2] = IIC_Read_Byte(1);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       IIC_Read_Byte
00002e  70a0              STRB     r0,[r4,#2]
;;;141    	IIC_Stop();
000030  f7fffffe          BL       IIC_Stop
;;;142    		
;;;143        __enable_irq();    // 开启总中断
000034  b662              CPSIE    i
;;;144    		
;;;145    }
000036  bd10              POP      {r4,pc}
;;;146    float ReadAdOfChannel(unsigned char  Channel,unsigned char CurrentFlag)
                          ENDP

                  |L4.56|
                          DCD      ||.data||+0x10

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=2

                  I2C_ReadByte PROC
;;;82     
;;;83     unsigned char I2C_ReadByte(unsigned char  id, unsigned char read_address)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {  
;;;85     	unsigned char temp; 	
;;;86     
;;;87     	while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));
000004  4c31              LDR      r4,|L5.204|
000006  4606              MOV      r6,r0                 ;84
000008  4688              MOV      r8,r1                 ;84
00000a  f44f3500          MOV      r5,#0x20000
                  |L5.14|
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2C_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d1f9              BNE      |L5.14|
;;;88       	//等待I2C
;;;89       	I2C_GenerateSTART(I2C1, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       I2C_GenerateSTART
;;;90       	//产生起始信号
;;;91       	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
000022  4d2b              LDR      r5,|L5.208|
                  |L5.36|
000024  4620              MOV      r0,r4
000026  4629              MOV      r1,r5
000028  f7fffffe          BL       I2C_CheckEvent
00002c  2800              CMP      r0,#0
00002e  d0f9              BEQ      |L5.36|
;;;92         //EV5
;;;93       	I2C_Send7bitAddress(I2C1, id, I2C_Direction_Transmitter);
000030  2200              MOVS     r2,#0
000032  4631              MOV      r1,r6
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_Send7bitAddress
;;;94     	//发送地址
;;;95       	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
00003a  4f26              LDR      r7,|L5.212|
                  |L5.60|
00003c  4620              MOV      r0,r4
00003e  4639              MOV      r1,r7
000040  f7fffffe          BL       I2C_CheckEvent
000044  2800              CMP      r0,#0
000046  d0f9              BEQ      |L5.60|
;;;96       	//EV6
;;;97       	I2C_Cmd(I2C1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_Cmd
;;;98      	//重新设置可以清楚EV6
;;;99       	I2C_SendData(I2C1, read_address);  
000050  4641              MOV      r1,r8
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       I2C_SendData
;;;100    	//发送读地址
;;;101      	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
000058  4f1e              LDR      r7,|L5.212|
00005a  1cbf              ADDS     r7,r7,#2
                  |L5.92|
00005c  4639              MOV      r1,r7
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       I2C_CheckEvent
000064  2800              CMP      r0,#0
000066  d0f9              BEQ      |L5.92|
;;;102      	//EV8 
;;;103      	I2C_GenerateSTART(I2C1, ENABLE);
000068  2101              MOVS     r1,#1
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       I2C_GenerateSTART
                  |L5.112|
;;;104    	//重新发送
;;;105      	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
000070  4629              MOV      r1,r5
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       I2C_CheckEvent
000078  2800              CMP      r0,#0
00007a  d0f9              BEQ      |L5.112|
;;;106      	//EV5
;;;107      	I2C_Send7bitAddress(I2C1, id, I2C_Direction_Receiver);
00007c  2201              MOVS     r2,#1
00007e  4631              MOV      r1,r6
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       I2C_Send7bitAddress
;;;108      	//发送读地址
;;;109      	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
000086  4d12              LDR      r5,|L5.208|
000088  1c6d              ADDS     r5,r5,#1
                  |L5.138|
00008a  4629              MOV      r1,r5
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       I2C_CheckEvent
000092  2800              CMP      r0,#0
000094  d0f9              BEQ      |L5.138|
;;;110      	//EV6  
;;;111        I2C_AcknowledgeConfig(I2C1, DISABLE);
000096  2100              MOVS     r1,#0
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       I2C_AcknowledgeConfig
;;;112        I2C_GenerateSTOP(I2C1, ENABLE);
00009e  2101              MOVS     r1,#1
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       I2C_GenerateSTOP
;;;113    	//关闭应答和停止条件产生
;;;114        while(!(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)));
0000a6  4d0a              LDR      r5,|L5.208|
0000a8  353f              ADDS     r5,r5,#0x3f
                  |L5.170|
0000aa  4629              MOV      r1,r5
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       I2C_CheckEvent
0000b2  2800              CMP      r0,#0
0000b4  d0f9              BEQ      |L5.170|
;;;115    	      
;;;116        temp = I2C_ReceiveData(I2C1);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       I2C_ReceiveData
0000bc  4605              MOV      r5,r0
;;;117       
;;;118      	I2C_AcknowledgeConfig(I2C1, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       I2C_AcknowledgeConfig
;;;119    		
;;;120        return temp;
0000c6  4628              MOV      r0,r5
;;;121    }
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;122    
                          ENDP

                  |L5.204|
                          DCD      0x40005400
                  |L5.208|
                          DCD      0x00030001
                  |L5.212|
                          DCD      0x00070082

                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=2

                  I2C_WriteByte PROC
;;;10     
;;;11     void I2C_WriteByte(unsigned char id,unsigned char write_address,unsigned char byte)
000000  b570              PUSH     {r4-r6,lr}
;;;12     {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;13     	IIC_Start();
000008  f7fffffe          BL       IIC_Start
;;;14     	//产生起始条件
;;;15     	IIC_Send_Byte(id);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       IIC_Send_Byte
;;;16     	//向设备发送设备地址
;;;17     	while(IIC_Wait_Ack());
000012  bf00              NOP      
                  |L6.20|
000014  f7fffffe          BL       IIC_Wait_Ack
000018  2800              CMP      r0,#0
00001a  d1fb              BNE      |L6.20|
;;;18     	//等待ACK
;;;19     	IIC_Send_Byte(write_address);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       IIC_Send_Byte
;;;20     	//寄存器地址
;;;21     	while(IIC_Wait_Ack());
000022  bf00              NOP      
                  |L6.36|
000024  f7fffffe          BL       IIC_Wait_Ack
000028  2800              CMP      r0,#0
00002a  d1fb              BNE      |L6.36|
;;;22     	//等待ACK
;;;23     	IIC_Send_Byte(byte);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       IIC_Send_Byte
;;;24     	//发送数据
;;;25     	while(IIC_Wait_Ack());
000032  bf00              NOP      
                  |L6.52|
000034  f7fffffe          BL       IIC_Wait_Ack
000038  2800              CMP      r0,#0
00003a  d1fb              BNE      |L6.52|
;;;26     	//发送完成
;;;27     	IIC_Stop();
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f7ffbffe          B.W      IIC_Stop
;;;28     	//产生结束信号
;;;29     }
;;;30     //---------------------------------------------------------//
                          ENDP


                          AREA ||i.ReadAdOfChannel||, CODE, READONLY, ALIGN=2

                  ReadAdOfChannel PROC
;;;145    }
;;;146    float ReadAdOfChannel(unsigned char  Channel,unsigned char CurrentFlag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
000004  4602              MOV      r2,r0
000006  000f              MOVS     r7,r1
;;;148    	float resaultVoltageOrCurrent=0;
000008  f04f0600          MOV      r6,#0
;;;149    	
;;;150    	
;;;151    	int16_t CigH=0xc2;
00000c  f04f00c2          MOV      r0,#0xc2
;;;152    	switch(CurrentFlag)
000010  d100              BNE      |L7.20|
;;;153    	{
;;;154    		case 0:CigH=0xce;break;  //FS=+-0.256
000012  20ce              MOVS     r0,#0xce
                  |L7.20|
;;;155    		case 1:CigH=0xc2;break;  //FS=+-4.096
;;;156    		default:break;
;;;157    	}
;;;158    
;;;159    	switch(Channel)
;;;160    	{
;;;161    		case 1:AD_init(0x90,0x01,CigH|0x00,0xe2);
;;;162    		       delay_ms(2);
;;;163    					 I2C_ADpoint(0x90,0x00);
;;;164    					 delay_ms(2);
;;;165    		       I2C_Read2(0x91,0x00);
;;;166    		       resault = (BUF[1] << 8) | BUF[2];
000014  4d49              LDR      r5,|L7.316|
000016  2a0d              CMP      r2,#0xd               ;159
000018  f1a50410          SUB      r4,r5,#0x10
00001c  d224              BCS      |L7.104|
00001e  e8dff002          TBB      [pc,r2]               ;159
000022  2307              DCB      0x23,0x07
000024  0a282b30          DCB      0x0a,0x28,0x2b,0x30
000028  3336394e          DCB      0x33,0x36,0x39,0x4e
00002c  51555800          DCB      0x51,0x55,0x58,0x00
000030  23e2              MOVS     r3,#0xe2              ;161
000032  b2c2              UXTB     r2,r0                 ;161
;;;167    					 break;
000034  e002              B        |L7.60|
;;;168    		case 2:AD_init(0x90,0x01,CigH|0x10,0xe2);
000036  f0400010          ORR      r0,r0,#0x10
;;;169    		       delay_ms(2);
;;;170    					 I2C_ADpoint(0x90,0x00);
;;;171    					 delay_ms(2);
;;;172    		       I2C_Read2(0x91,0x00);
;;;173    		       resault = (BUF[1] << 8) | BUF[2];
;;;174    					 break;
00003a  e01f              B        |L7.124|
                  |L7.60|
00003c  2101              MOVS     r1,#1                 ;161
00003e  2090              MOVS     r0,#0x90              ;161
000040  f7fffffe          BL       AD_init
000044  2002              MOVS     r0,#2                 ;162
000046  f7fffffe          BL       delay_ms
00004a  2100              MOVS     r1,#0                 ;163
00004c  2090              MOVS     r0,#0x90              ;163
00004e  f7fffffe          BL       I2C_ADpoint
000052  2002              MOVS     r0,#2                 ;164
000054  f7fffffe          BL       delay_ms
000058  2100              MOVS     r1,#0                 ;165
00005a  2091              MOVS     r0,#0x91              ;165
                  |L7.92|
00005c  f7fffffe          BL       I2C_Read2
000060  f8b50001          LDRH     r0,[r5,#1]            ;166  ; BUF
000064  ba40              REV16    r0,r0                 ;166
000066  8020              STRH     r0,[r4,#0]            ;166
                  |L7.104|
;;;175    		case 3:AD_init(0x90,0x01,CigH|0x20,0xe2);
;;;176    		       delay_ms(2);
;;;177    					 I2C_ADpoint(0x90,0x00);
;;;178    					 delay_ms(2);
;;;179    		       I2C_Read2(0x91,0x00);
;;;180    		       resault = (BUF[1] << 8) | BUF[2];
;;;181    					 break;
;;;182    	  case 4:AD_init(0x90,0x01,CigH|0x30,0xe2);
;;;183    		       delay_ms(2);
;;;184    					 I2C_ADpoint(0x90,0x00);
;;;185    					 delay_ms(2);
;;;186    		       I2C_Read2(0x91,0x00);
;;;187    		       resault = (BUF[1] << 8) | BUF[2];
;;;188    					 break;
;;;189    		case 5:AD_init(0x92,0x01,CigH|0x00,0xe2);
;;;190    		       delay_ms(2);
;;;191    					 I2C_ADpoint(0x92,0x00);
;;;192    					 delay_ms(2);
;;;193    		       I2C_Read2(0x93,0x00);
;;;194    		       resault = (BUF[1] << 8) | BUF[2];
;;;195    					 break;
;;;196    		case 6:AD_init(0x92,0x01,CigH|0x10,0xe2);
;;;197    		       delay_ms(2);
;;;198    					 I2C_ADpoint(0x92,0x00);
;;;199    					 delay_ms(2);
;;;200    		       I2C_Read2(0x93,0x00);
;;;201    		       resault = (BUF[1] << 8) | BUF[2];
;;;202    					 break;
;;;203    		case 7:AD_init(0x92,0x01,CigH|0x20,0xe2);
;;;204    		       delay_ms(2);
;;;205    					 I2C_ADpoint(0x92,0x00);
;;;206    					 delay_ms(2);
;;;207    		       I2C_Read2(0x93,0x00);
;;;208    		       resault = (BUF[1] << 8) | BUF[2];
;;;209    					 break;
;;;210    	  case 8:AD_init(0x92,0x01,CigH|0x30,0xe2);
;;;211    		       delay_ms(2);
;;;212    					 I2C_ADpoint(0x92,0x00);
;;;213    					 delay_ms(2);
;;;214    		       I2C_Read2(0x93,0x00);
;;;215    		       resault = (BUF[1] << 8) | BUF[2];
;;;216    					 break;
;;;217    		case 9:AD_init(0x94,0x01,CigH|0x00,0xe2);
;;;218    		       delay_ms(2);
;;;219    					 I2C_ADpoint(0x94,0x00);
;;;220    					 delay_ms(2);
;;;221    		       I2C_Read2(0x95,0x00);
;;;222    		       resault = (BUF[1] << 8) | BUF[2];
;;;223    					 break;
;;;224    		case 10:AD_init(0x94,0x01,CigH|0x10,0xe2);
;;;225    		       delay_ms(2);
;;;226    					 I2C_ADpoint(0x94,0x00);
;;;227    					 delay_ms(2);
;;;228    		       I2C_Read2(0x95,0x00);
;;;229    		       resault = (BUF[1] << 8) | BUF[2];
;;;230    					 break;
;;;231    		case 11:AD_init(0x94,0x01,CigH|0x20,0xe2);
;;;232    		       delay_ms(2);
;;;233    					 I2C_ADpoint(0x94,0x00);
;;;234    					 delay_ms(2);
;;;235    		       I2C_Read2(0x95,0x00);
;;;236    		       resault = (BUF[1] << 8) | BUF[2];
;;;237    					 break;
;;;238    	  case 12:AD_init(0x94,0x01,CigH|0x30,0xe2);
;;;239    		       delay_ms(2);
;;;240    					 I2C_ADpoint(0x94,0x00);
;;;241    					 delay_ms(2);
;;;242    		       I2C_Read2(0x95,0x00);
;;;243    		       resault = (BUF[1] << 8) | BUF[2];
;;;244    					 break;
;;;245    		default:break;
;;;246    	}
;;;247    	switch(CurrentFlag)
;;;248    	{ 
;;;249    		case 0: resaultVoltageOrCurrent=0.256*51*resault/32767.0;break;    //FS=+-0.256
000068  4d35              LDR      r5,|L7.320|
00006a  b377              CBZ      r7,|L7.202|
00006c  2f01              CMP      r7,#1                 ;247
00006e  d162              BNE      |L7.310|
000070  e04f              B        |L7.274|
000072  f0400020          ORR      r0,r0,#0x20           ;175
000076  e001              B        |L7.124|
000078  f0400030          ORR      r0,r0,#0x30           ;182
                  |L7.124|
00007c  b2c2              UXTB     r2,r0                 ;182
00007e  23e2              MOVS     r3,#0xe2              ;182
000080  e7dc              B        |L7.60|
000082  23e2              MOVS     r3,#0xe2              ;189
000084  b2c2              UXTB     r2,r0                 ;189
000086  e009              B        |L7.156|
000088  f0400010          ORR      r0,r0,#0x10           ;196
00008c  e004              B        |L7.152|
00008e  f0400020          ORR      r0,r0,#0x20           ;203
000092  e001              B        |L7.152|
000094  f0400030          ORR      r0,r0,#0x30           ;210
                  |L7.152|
000098  b2c2              UXTB     r2,r0                 ;210
00009a  23e2              MOVS     r3,#0xe2              ;210
                  |L7.156|
00009c  2101              MOVS     r1,#1                 ;210
00009e  2092              MOVS     r0,#0x92              ;210
0000a0  f7fffffe          BL       AD_init
0000a4  2002              MOVS     r0,#2                 ;211
0000a6  f7fffffe          BL       delay_ms
0000aa  2100              MOVS     r1,#0                 ;212
0000ac  2092              MOVS     r0,#0x92              ;212
0000ae  f7fffffe          BL       I2C_ADpoint
0000b2  2002              MOVS     r0,#2                 ;213
0000b4  f7fffffe          BL       delay_ms
0000b8  2100              MOVS     r1,#0                 ;214
0000ba  2093              MOVS     r0,#0x93              ;214
0000bc  e7ce              B        |L7.92|
0000be  23e2              MOVS     r3,#0xe2              ;217
0000c0  b2c2              UXTB     r2,r0                 ;217
0000c2  e00a              B        |L7.218|
0000c4  f0400010          ORR      r0,r0,#0x10           ;224
0000c8  e005              B        |L7.214|
                  |L7.202|
0000ca  e017              B        |L7.252|
0000cc  f0400020          ORR      r0,r0,#0x20           ;231
0000d0  e001              B        |L7.214|
0000d2  f0400030          ORR      r0,r0,#0x30           ;238
                  |L7.214|
0000d6  b2c2              UXTB     r2,r0                 ;238
0000d8  23e2              MOVS     r3,#0xe2              ;238
                  |L7.218|
0000da  2101              MOVS     r1,#1                 ;238
0000dc  2094              MOVS     r0,#0x94              ;238
0000de  f7fffffe          BL       AD_init
0000e2  2002              MOVS     r0,#2                 ;239
0000e4  f7fffffe          BL       delay_ms
0000e8  2100              MOVS     r1,#0                 ;240
0000ea  2094              MOVS     r0,#0x94              ;240
0000ec  f7fffffe          BL       I2C_ADpoint
0000f0  2002              MOVS     r0,#2                 ;241
0000f2  f7fffffe          BL       delay_ms
0000f6  2100              MOVS     r1,#0                 ;242
0000f8  2095              MOVS     r0,#0x95              ;242
0000fa  e7af              B        |L7.92|
                  |L7.252|
0000fc  f9b40000          LDRSH    r0,[r4,#0]  ; resault
000100  f7fffffe          BL       __aeabi_i2d
000104  4a0f              LDR      r2,|L7.324|
000106  4b10              LDR      r3,|L7.328|
000108  f7fffffe          BL       __aeabi_dmul
00010c  2200              MOVS     r2,#0
00010e  462b              MOV      r3,r5
000110  e00c              B        |L7.300|
                  |L7.274|
;;;250    		case 1: resaultVoltageOrCurrent=4.096*1000*resault/32767.0/200.0;break;//FS=+-4.096
000112  f9b40000          LDRSH    r0,[r4,#0]  ; resault
000116  f7fffffe          BL       __aeabi_i2d
00011a  220c              MOVS     r2,#0xc
00011c  f7fffffe          BL       __ARM_scalbn
000120  2200              MOVS     r2,#0
000122  462b              MOV      r3,r5
000124  f7fffffe          BL       __aeabi_ddiv
000128  2200              MOVS     r2,#0
00012a  4b08              LDR      r3,|L7.332|
                  |L7.300|
00012c  f7fffffe          BL       __aeabi_ddiv
000130  f7fffffe          BL       __aeabi_d2f
000134  4606              MOV      r6,r0                 ;249
                  |L7.310|
;;;251    		default:resaultVoltageOrCurrent=0;break;
;;;252    	}
;;;253    	return resaultVoltageOrCurrent;
000136  4630              MOV      r0,r6
;;;254    }
000138  e8bd81f0          POP      {r4-r8,pc}
;;;255    
                          ENDP

                  |L7.316|
                          DCD      ||.data||+0x10
                  |L7.320|
                          DCD      0x40dfffc0
                  |L7.324|
                          DCD      0x083126ea
                  |L7.328|
                          DCD      0x402a1cac
                  |L7.332|
                          DCD      0x40690000

                          AREA ||i.read_ADS1115_1||, CODE, READONLY, ALIGN=2

                  read_ADS1115_1 PROC
;;;266    //-----------------------------------------------//
;;;267    void read_ADS1115_1()
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;268    {
;;;269    	 /*******************************AD1***********************************************/
;;;270    	   AD_init(0x90,0x01,0xc2,0xe2);
000004  23e2              MOVS     r3,#0xe2
000006  22c2              MOVS     r2,#0xc2
000008  2101              MOVS     r1,#1
00000a  2090              MOVS     r0,#0x90
00000c  f7fffffe          BL       AD_init
;;;271    	   //器件地址90，配置寄存器01，寄存器高位，寄存器低位e2
;;;272    	   //高字节配置：c-an0 d-an1 e-an2 f-an3 ; 0->6.144 2->4.096 4->2.048
;;;273    	 delay_ms(1);	
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       delay_ms
;;;274    	   I2C_ADpoint(0x90,0x00);
000016  2100              MOVS     r1,#0
000018  2090              MOVS     r0,#0x90
00001a  f7fffffe          BL       I2C_ADpoint
;;;275         delay_ms(2);	
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       delay_ms
;;;276         I2C_Read2(0x91,0x00);
000024  2100              MOVS     r1,#0
000026  2091              MOVS     r0,#0x91
000028  f7fffffe          BL       I2C_Read2
;;;277    	 valu_stm32ads1115_1 = (BUF[1] << 8) | BUF[2]; 
00002c  4d30              LDR      r5,|L8.240|
;;;278    	 if(valu_stm32ads1115_1>32768)valu_stm32ads1115_1=valu_stm32ads1115_1-65536;
00002e  f44f4600          MOV      r6,#0x8000
000032  f1a50410          SUB      r4,r5,#0x10           ;277
000036  f8b50001          LDRH     r0,[r5,#1]            ;277  ; BUF
00003a  ba40              REV16    r0,r0                 ;277
00003c  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
00003e  42b0              CMP      r0,r6
000040  dd02              BLE      |L8.72|
000042  f5a03080          SUB      r0,r0,#0x10000
000046  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
                  |L8.72|
;;;279         s1 = ((float)valu_stm32ads1115_1/(float)0x7fff) *4.096*10.02/4.12;                //S1 AI1 通道电压值
000048  f7fffffe          BL       __aeabi_i2f
00004c  4f29              LDR      r7,|L8.244|
00004e  4639              MOV      r1,r7
000050  f7fffffe          BL       __aeabi_fdiv
000054  f7fffffe          BL       __aeabi_f2d
000058  f8dfb09c          LDR      r11,|L8.248|
00005c  f8df909c          LDR      r9,|L8.252|
000060  465a              MOV      r2,r11
000062  464b              MOV      r3,r9
000064  f7fffffe          BL       __aeabi_dmul
000068  f8dfa094          LDR      r10,|L8.256|
00006c  4b25              LDR      r3,|L8.260|
00006e  4652              MOV      r2,r10
000070  f7fffffe          BL       __aeabi_dmul
000074  f8df8090          LDR      r8,|L8.264|
000078  4b24              LDR      r3,|L8.268|
00007a  4642              MOV      r2,r8
00007c  f7fffffe          BL       __aeabi_ddiv
000080  f7fffffe          BL       __aeabi_d2f
;;;280        // if(valu_stm32ads1115_1>0x7fff)valu_stm32ads1115_1-=0xffff;	 
;;;281    	
;;;282    	/********************************AD2**********************************************/
;;;283    	AD_init(0x90,0x01,0xd2,0xe2);
000084  60a0              STR      r0,[r4,#8]  ; s1
000086  23e2              MOVS     r3,#0xe2
000088  22d2              MOVS     r2,#0xd2
00008a  2101              MOVS     r1,#1
00008c  2090              MOVS     r0,#0x90
00008e  f7fffffe          BL       AD_init
;;;284    	   //器件地址90，配置寄存器01，寄存器高位，寄存器低位e2
;;;285    	   //高字节配置：c-an0 d-an1 e-an2 f-an3 ; 0->6.144 2->4.096 4->2.048
;;;286    	 delay_ms(1);	
000092  2001              MOVS     r0,#1
000094  f7fffffe          BL       delay_ms
;;;287    	 I2C_ADpoint(0x90,0x00);
000098  2100              MOVS     r1,#0
00009a  2090              MOVS     r0,#0x90
00009c  f7fffffe          BL       I2C_ADpoint
;;;288         delay_ms(2);	
0000a0  2002              MOVS     r0,#2
0000a2  f7fffffe          BL       delay_ms
;;;289         I2C_Read2(0x91,0x00);
0000a6  2100              MOVS     r1,#0
0000a8  2091              MOVS     r0,#0x91
0000aa  f7fffffe          BL       I2C_Read2
;;;290    	 valu_stm32ads1115_1 = (BUF[1] << 8) | BUF[2]; 
0000ae  f8b50001          LDRH     r0,[r5,#1]  ; BUF
0000b2  ba40              REV16    r0,r0
;;;291    	 if(valu_stm32ads1115_1>32768)valu_stm32ads1115_1=valu_stm32ads1115_1-65536;
0000b4  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
0000b6  42b0              CMP      r0,r6
0000b8  dd02              BLE      |L8.192|
0000ba  f5a03080          SUB      r0,r0,#0x10000
0000be  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
                  |L8.192|
;;;292         s2 = ((float)valu_stm32ads1115_1/(float)0x7fff) *4.096*10.02/4.12;                 //S2 AI2 通道电压值
0000c0  f7fffffe          BL       __aeabi_i2f
0000c4  4639              MOV      r1,r7
0000c6  f7fffffe          BL       __aeabi_fdiv
0000ca  f7fffffe          BL       __aeabi_f2d
0000ce  465a              MOV      r2,r11
0000d0  464b              MOV      r3,r9
0000d2  f7fffffe          BL       __aeabi_dmul
0000d6  4652              MOV      r2,r10
0000d8  4b0a              LDR      r3,|L8.260|
0000da  f7fffffe          BL       __aeabi_dmul
0000de  4642              MOV      r2,r8
0000e0  4b0a              LDR      r3,|L8.268|
0000e2  f7fffffe          BL       __aeabi_ddiv
0000e6  f7fffffe          BL       __aeabi_d2f
0000ea  60e0              STR      r0,[r4,#0xc]  ; s2
;;;293        // if(valu_stm32ads1115_1>0x7fff)valu_stm32ads1115_1-=0xffff;	
;;;294    }
0000ec  e8bd9ff0          POP      {r4-r12,pc}
;;;295    
                          ENDP

                  |L8.240|
                          DCD      ||.data||+0x10
                  |L8.244|
                          DCD      0x46fffe00
                  |L8.248|
                          DCD      0xd2f1a9fc
                  |L8.252|
                          DCD      0x4010624d
                  |L8.256|
                          DCD      0x70a3d70a
                  |L8.260|
                          DCD      0x40240a3d
                  |L8.264|
                          DCD      0x47ae147b
                  |L8.268|
                          DCD      0x40107ae1

                          AREA ||i.stm32ads1115_1_init||, CODE, READONLY, ALIGN=1

                  stm32ads1115_1_init PROC
;;;295    
;;;296    void stm32ads1115_1_init(void)
000000  f7ffbffe          B.W      IIC_Init
;;;297    {
;;;298    	IIC_Init();
;;;299    }
;;;300    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  resault
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  valu_stm32ads1115_1
                          DCD      0x00000000
                  ||s1||
                          DCD      0x00000000
                  ||s2||
                          DCD      0x00000000
                  BUF
                          %        8
