; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -ostm32f10_config.o --asm_dir=.\ --list_dir=.\ --depend=stm32f10_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=stm32f10_config.crf stm32f10_config.c]
                          THUMB

                          AREA ||i.LedInit||, CODE, READONLY, ALIGN=2

                  LedInit PROC
;;;130    }
;;;131    void LedInit()
000000  b508              PUSH     {r3,lr}
;;;132    {
;;;133    	GPIO_InitTypeDef GPIO_InitStructure;
;;;134    	
;;;135    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB  , ENABLE);
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;136    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00000a  f44f7000          MOV      r0,#0x200
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;137    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;138     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000018  2010              MOVS     r0,#0x10
00001a  f88d0003          STRB     r0,[sp,#3]
;;;139      	GPIO_Init(GPIOB, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L1.40|
000022  f7fffffe          BL       GPIO_Init
;;;140    }
000026  bd08              POP      {r3,pc}
;;;141    
                          ENDP

                  |L1.40|
                          DCD      0x40010c00

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;108    }
;;;109    void NVIC_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;110    {
;;;111      NVIC_InitTypeDef NVIC_InitStructure;
;;;112      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); //分组
000002  f44f7040          MOV      r0,#0x300
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;113    
;;;114      NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
;;;115      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  //先占优先级0级
000010  2000              MOVS     r0,#0
000012  f88d0001          STRB     r0,[sp,#1]
;;;116    
;;;117      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000016  2401              MOVS     r4,#1
000018  f88d4003          STRB     r4,[sp,#3]
;;;118      NVIC_Init(&NVIC_InitStructure);
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       NVIC_Init
;;;119      
;;;120      NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000022  2026              MOVS     r0,#0x26
000024  f88d0000          STRB     r0,[sp,#0]
;;;121       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;  //先占优先级0级
000028  f88d4001          STRB     r4,[sp,#1]
;;;122    
;;;123      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00002c  f88d4003          STRB     r4,[sp,#3]
;;;124      NVIC_Init(&NVIC_InitStructure);
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       NVIC_Init
;;;125    
;;;126    //  NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
;;;127    //  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;128    //  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;129    //  NVIC_Init(&NVIC_InitStructure);
;;;130    }
000036  bd38              POP      {r3-r5,pc}
;;;131    void LedInit()
                          ENDP


                          AREA ||i.TIM1_Int_Init||, CODE, READONLY, ALIGN=2

                  TIM1_Int_Init PROC
;;;6      
;;;7      void TIM1_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;8      {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;9          TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;10     	NVIC_InitTypeDef NVIC_InitStructure;
;;;11     
;;;12     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); //时钟使能
000006  2101              MOVS     r1,#1
000008  02c8              LSLS     r0,r1,#11
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;13     
;;;14     	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 
00000e  f8ad4004          STRH     r4,[sp,#4]
;;;15     	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  
;;;16     	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000012  2000              MOVS     r0,#0
000014  f8ad5000          STRH     r5,[sp,#0]            ;15
;;;17     	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
;;;18     	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000018  4c0f              LDR      r4,|L3.88|
00001a  f8ad0006          STRH     r0,[sp,#6]            ;16
00001e  f8ad0002          STRH     r0,[sp,#2]            ;17
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TIM_TimeBaseInit
;;;19      
;;;20     	TIM_ITConfig(  //使能或者失能指定的TIM中断
00002a  2201              MOVS     r2,#1
00002c  4611              MOV      r1,r2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       TIM_ITConfig
;;;21     		TIM1, //TIM2
;;;22     		TIM_IT_Update ,
;;;23     		ENABLE  //使能
;;;24     		);
;;;25     
;;;26     	NVIC_InitStructure.NVIC_IRQChannel = TIM1_UP_IRQn;  //TIM1中断
000034  2019              MOVS     r0,#0x19
000036  f88d000c          STRB     r0,[sp,#0xc]
;;;27     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;  //先占优先级0级
00003a  2002              MOVS     r0,#2
00003c  f88d000d          STRB     r0,[sp,#0xd]
;;;28     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
000040  2001              MOVS     r0,#1
000042  f88d000f          STRB     r0,[sp,#0xf]
;;;29     	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000046  a803              ADD      r0,sp,#0xc
000048  f7fffffe          BL       NVIC_Init
;;;30     
;;;31     	TIM_Cmd(TIM1, ENABLE);  //使能TIMx外设						 
00004c  2101              MOVS     r1,#1
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       TIM_Cmd
;;;32     }
000054  bd7f              POP      {r0-r6,pc}
;;;33     
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      0x40012c00

                          AREA ||i.TIM2_Int_Init||, CODE, READONLY, ALIGN=1

                  TIM2_Int_Init PROC
;;;33     
;;;34     void TIM2_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;35     {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;36         TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;37     	NVIC_InitTypeDef NVIC_InitStructure;
;;;38     
;;;39     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); //时钟使能
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;40     
;;;41     	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 
00000e  f8ad4004          STRH     r4,[sp,#4]
;;;42     	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  
;;;43     	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000012  2000              MOVS     r0,#0
000014  f8ad5000          STRH     r5,[sp,#0]            ;42
000018  f8ad0006          STRH     r0,[sp,#6]
;;;44     	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
00001c  f8ad0002          STRH     r0,[sp,#2]
;;;45     	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000020  f04f4480          MOV      r4,#0x40000000
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       TIM_TimeBaseInit
;;;46      
;;;47     	TIM_ITConfig(  //使能或者失能指定的TIM中断
00002c  2201              MOVS     r2,#1
00002e  4611              MOV      r1,r2
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       TIM_ITConfig
;;;48     		TIM2, //TIM2
;;;49     		TIM_IT_Update ,
;;;50     		ENABLE  //使能
;;;51     		);
;;;52     	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;  //TIM2中断
000036  201c              MOVS     r0,#0x1c
000038  f88d000c          STRB     r0,[sp,#0xc]
;;;53     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;  //先占优先级0级
00003c  2003              MOVS     r0,#3
00003e  f88d000d          STRB     r0,[sp,#0xd]
;;;54     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
000042  2001              MOVS     r0,#1
000044  f88d000f          STRB     r0,[sp,#0xf]
;;;55     	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000048  a803              ADD      r0,sp,#0xc
00004a  f7fffffe          BL       NVIC_Init
;;;56     
;;;57     	TIM_Cmd(TIM2, ENABLE);  //使能TIMx外设						 
00004e  2101              MOVS     r1,#1
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       TIM_Cmd
;;;58     }
000056  bd7f              POP      {r0-r6,pc}
;;;59     void TIM3_Int_Init(u16 arr,u16 psc)
                          ENDP


                          AREA ||i.TIM3_Int_Init||, CODE, READONLY, ALIGN=2

                  TIM3_Int_Init PROC
;;;58     }
;;;59     void TIM3_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;60     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;61         TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;62     	NVIC_InitTypeDef NVIC_InitStructure;
;;;63     
;;;64     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能
000006  2101              MOVS     r1,#1
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;65     
;;;66     	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 
00000e  f8ad4004          STRH     r4,[sp,#4]
;;;67     	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  
;;;68     	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000012  2000              MOVS     r0,#0
000014  f8ad5000          STRH     r5,[sp,#0]            ;67
;;;69     	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
;;;70     	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000018  4c0f              LDR      r4,|L5.88|
00001a  f8ad0006          STRH     r0,[sp,#6]            ;68
00001e  f8ad0002          STRH     r0,[sp,#2]            ;69
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TIM_TimeBaseInit
;;;71      
;;;72     	TIM_ITConfig(  //使能或者失能指定的TIM中断
00002a  2201              MOVS     r2,#1
00002c  4611              MOV      r1,r2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       TIM_ITConfig
;;;73     		TIM3, //TIM2
;;;74     		TIM_IT_Update ,
;;;75     		ENABLE  //使能
;;;76     		);
;;;77     	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  //TIM2中断
000034  201d              MOVS     r0,#0x1d
000036  f88d000c          STRB     r0,[sp,#0xc]
;;;78     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;  //先占优先级0级
00003a  2004              MOVS     r0,#4
00003c  f88d000d          STRB     r0,[sp,#0xd]
;;;79     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
000040  2001              MOVS     r0,#1
000042  f88d000f          STRB     r0,[sp,#0xf]
;;;80     	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000046  a803              ADD      r0,sp,#0xc
000048  f7fffffe          BL       NVIC_Init
;;;81     
;;;82     	TIM_Cmd(TIM3, ENABLE);  //使能TIMx外设						 
00004c  2101              MOVS     r1,#1
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       TIM_Cmd
;;;83     }
000054  bd7f              POP      {r0-r6,pc}
;;;84     void TIM4_Int_Init(u16 arr,u16 psc)
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      0x40000400

                          AREA ||i.TIM4_Int_Init||, CODE, READONLY, ALIGN=2

                  TIM4_Int_Init PROC
;;;83     }
;;;84     void TIM4_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;85     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;86         TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;87     	NVIC_InitTypeDef NVIC_InitStructure;
;;;88     
;;;89     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE); //时钟使能
000006  2101              MOVS     r1,#1
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;90     
;;;91     	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 
00000e  f8ad4004          STRH     r4,[sp,#4]
;;;92     	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  
;;;93     	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000012  2000              MOVS     r0,#0
000014  f8ad5000          STRH     r5,[sp,#0]            ;92
;;;94     	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
;;;95     	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000018  4c0f              LDR      r4,|L6.88|
00001a  f8ad0006          STRH     r0,[sp,#6]            ;93
00001e  f8ad0002          STRH     r0,[sp,#2]            ;94
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TIM_TimeBaseInit
;;;96      
;;;97     	TIM_ITConfig(  //使能或者失能指定的TIM中断
00002a  2201              MOVS     r2,#1
00002c  4611              MOV      r1,r2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       TIM_ITConfig
;;;98     		TIM4, //TIM2
;;;99     		TIM_IT_Update ,
;;;100    		ENABLE  //使能
;;;101    		);
;;;102    	NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;  //TIM2中断
000034  201e              MOVS     r0,#0x1e
000036  f88d000c          STRB     r0,[sp,#0xc]
;;;103    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;  //先占优先级0级
00003a  2005              MOVS     r0,#5
00003c  f88d000d          STRB     r0,[sp,#0xd]
;;;104    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
000040  2001              MOVS     r0,#1
000042  f88d000f          STRB     r0,[sp,#0xf]
;;;105    	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000046  a803              ADD      r0,sp,#0xc
000048  f7fffffe          BL       NVIC_Init
;;;106    
;;;107    	TIM_Cmd(TIM4, ENABLE);  //使能TIMx外设						 
00004c  2101              MOVS     r1,#1
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       TIM_Cmd
;;;108    }
000054  bd7f              POP      {r0-r6,pc}
;;;109    void NVIC_Configuration(void)
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      0x40000800

                          AREA ||i.UART_Configuration||, CODE, READONLY, ALIGN=2

                  UART_Configuration PROC
;;;141    
;;;142    void UART_Configuration(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;143    {
000004  b086              SUB      sp,sp,#0x18
;;;144    	USART_InitTypeDef USART_InitStructure;
;;;145    	GPIO_InitTypeDef GPIO_InitStructure;
;;;146    	
;;;147    	RCC_APB2PeriphClockCmd(USART1_GPIO_CLK  , ENABLE);
000006  2101              MOVS     r1,#1
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;148    	RCC_APB2PeriphClockCmd(USART2_GPIO_CLK  , ENABLE);
00000e  2101              MOVS     r1,#1
000010  2020              MOVS     r0,#0x20
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;149    //	RCC_APB2PeriphClockCmd(USART3_GPIO_CLK  , ENABLE);
;;;150    	
;;;151    	RCC_APB2PeriphClockCmd(USART1_CLK  , ENABLE);
000016  2101              MOVS     r1,#1
000018  0388              LSLS     r0,r1,#14
00001a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;152    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO  , ENABLE);
00001e  2101              MOVS     r1,#1
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;153    	
;;;154    	RCC_APB1PeriphClockCmd(USART2_CLK  , ENABLE);
000026  2101              MOVS     r1,#1
000028  0448              LSLS     r0,r1,#17
00002a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;155    //	RCC_APB1PeriphClockCmd(USART3_CLK  , ENABLE);
;;;156    	GPIO_PinRemapConfig(GPIO_FullRemap_USART3, ENABLE);  
00002e  2101              MOVS     r1,#1
000030  4847              LDR      r0,|L7.336|
000032  f7fffffe          BL       GPIO_PinRemapConfig
;;;157    	GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);  
000036  2101              MOVS     r1,#1
000038  2008              MOVS     r0,#8
00003a  f7fffffe          BL       GPIO_PinRemapConfig
;;;158    
;;;159      /*串口1 RX管脚配置*/
;;;160      /* Configure USART1 Rx as input floating */
;;;161      GPIO_InitStructure.GPIO_Pin = USART1_RxPin;
00003e  f44f6080          MOV      r0,#0x400
000042  f8ad0000          STRH     r0,[sp,#0]
;;;162      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000046  2004              MOVS     r0,#4
;;;163      GPIO_Init(USART1_GPIO, &GPIO_InitStructure);
000048  f8df8108          LDR      r8,|L7.340|
00004c  f88d0003          STRB     r0,[sp,#3]            ;162
000050  4669              MOV      r1,sp
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       GPIO_Init
;;;164    
;;;165      /*串口2 RX管脚配置*/
;;;166      /* Configure USART2 Rx as input floating */
;;;167      GPIO_InitStructure.GPIO_Pin = USART2_RxPin;
000058  2040              MOVS     r0,#0x40
;;;168      GPIO_Init(USART2_GPIO, &GPIO_InitStructure);  
00005a  4f3f              LDR      r7,|L7.344|
00005c  f8ad0000          STRH     r0,[sp,#0]            ;167
000060  4669              MOV      r1,sp
000062  4638              MOV      r0,r7
000064  f7fffffe          BL       GPIO_Init
;;;169    
;;;170      /*串口3 RX管脚配置*/
;;;171      /* Configure USART3 Rx as input floating */
;;;172      GPIO_InitStructure.GPIO_Pin = USART3_RxPin;
000068  157c              ASRS     r4,r7,#21
00006a  f8ad4000          STRH     r4,[sp,#0]
;;;173      GPIO_Init(USART3_GPIO, &GPIO_InitStructure);
00006e  4669              MOV      r1,sp
000070  4638              MOV      r0,r7
000072  f7fffffe          BL       GPIO_Init
;;;174    
;;;175    
;;;176    
;;;177      /*串口1 TX管脚配置*/ 
;;;178      /* Configure USART1 Tx as alternate function push-pull */
;;;179      GPIO_InitStructure.GPIO_Pin = USART1_TxPin;
000076  f8ad4000          STRH     r4,[sp,#0]
;;;180      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00007a  2403              MOVS     r4,#3
00007c  f88d4002          STRB     r4,[sp,#2]
;;;181      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000080  2018              MOVS     r0,#0x18
000082  f88d0003          STRB     r0,[sp,#3]
;;;182      GPIO_Init(USART1_GPIO, &GPIO_InitStructure);
000086  4669              MOV      r1,sp
000088  4640              MOV      r0,r8
00008a  f7fffffe          BL       GPIO_Init
;;;183      
;;;184      GPIO_InitStructure.GPIO_Pin = USART2_TxPin;
00008e  2020              MOVS     r0,#0x20
000090  f8ad0000          STRH     r0,[sp,#0]
;;;185      GPIO_Init(USART2_GPIO, &GPIO_InitStructure);
000094  4669              MOV      r1,sp
000096  4638              MOV      r0,r7
000098  f7fffffe          BL       GPIO_Init
;;;186    	
;;;187      GPIO_InitStructure.GPIO_Pin = USART3_TxPin;
00009c  15bd              ASRS     r5,r7,#22
00009e  f8ad5000          STRH     r5,[sp,#0]
;;;188      GPIO_Init(USART3_GPIO, &GPIO_InitStructure);
0000a2  4669              MOV      r1,sp
0000a4  4638              MOV      r0,r7
0000a6  f7fffffe          BL       GPIO_Init
;;;189    	
;;;190      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
0000aa  2080              MOVS     r0,#0x80
0000ac  f8ad0000          STRH     r0,[sp,#0]
;;;191      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000b0  f88d4002          STRB     r4,[sp,#2]
;;;192      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000b4  2610              MOVS     r6,#0x10
0000b6  f88d6003          STRB     r6,[sp,#3]
;;;193      GPIO_Init(GPIOD, &GPIO_InitStructure);
0000ba  4669              MOV      r1,sp
0000bc  4638              MOV      r0,r7
0000be  f7fffffe          BL       GPIO_Init
;;;194    	
;;;195    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
0000c2  f8ad5000          STRH     r5,[sp,#0]
;;;196      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000c6  f88d4002          STRB     r4,[sp,#2]
;;;197      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000ca  f88d6003          STRB     r6,[sp,#3]
;;;198      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000ce  4669              MOV      r1,sp
0000d0  4640              MOV      r0,r8
0000d2  f7fffffe          BL       GPIO_Init
;;;199    	
;;;200      DE1=1;
0000d6  4921              LDR      r1,|L7.348|
0000d8  2001              MOVS     r0,#1
0000da  6008              STR      r0,[r1,#0]
;;;201      DE2=1;
0000dc  4920              LDR      r1,|L7.352|
0000de  f8c1019c          STR      r0,[r1,#0x19c]
;;;202    	
;;;203    /* USART1 and USART2 configuration */
;;;204    
;;;205      /* USART1 and USART2 configured as follow:
;;;206            - BaudRate = 9600 baud  
;;;207            - Word Length = 8 Bits
;;;208            - One Stop Bit
;;;209            - No parity
;;;210            - Hardware flow control disabled (RTS and CTS signals)
;;;211            - Receive and transmit enabled
;;;212      */
;;;213    
;;;214      	USART_InitStructure.USART_BaudRate = 9600;
0000e2  f44f5016          MOV      r0,#0x2580
;;;215    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000e6  9001              STR      r0,[sp,#4]
0000e8  f04f0000          MOV      r0,#0
0000ec  f8ad000a          STRH     r0,[sp,#0xa]
;;;216    	USART_InitStructure.USART_WordLength = USART_WordLength_9b;
0000f0  f44f5180          MOV      r1,#0x1000
0000f4  f8ad1008          STRH     r1,[sp,#8]
;;;217    	USART_InitStructure.USART_Parity = USART_Parity_Odd;
0000f8  f44f61c0          MOV      r1,#0x600
0000fc  f8ad100c          STRH     r1,[sp,#0xc]
;;;218    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000100  f8ad0010          STRH     r0,[sp,#0x10]
;;;219    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
000104  f04f000c          MOV      r0,#0xc
;;;220    	
;;;221    
;;;222      /*配置串口1 */
;;;223      USART_Init(USART1, &USART_InitStructure);
000108  4c16              LDR      r4,|L7.356|
00010a  f8ad000e          STRH     r0,[sp,#0xe]          ;219
00010e  a901              ADD      r1,sp,#4
000110  4620              MOV      r0,r4
000112  f7fffffe          BL       USART_Init
;;;224    
;;;225      /*配置串口2*/
;;;226      USART_Init(USART2, &USART_InitStructure);
000116  4d14              LDR      r5,|L7.360|
000118  a901              ADD      r1,sp,#4
00011a  4628              MOV      r0,r5
00011c  f7fffffe          BL       USART_Init
;;;227      /*配置串口3*/
;;;228      //USART_InitStructure.USART_BaudRate = 115200;
;;;229     // USART_Init(USART3, &USART_InitStructure);
;;;230    
;;;231      			    
;;;232      /*使能串口1的发送和接收中断*/
;;;233      USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
000120  f2405625          MOV      r6,#0x525
000124  2201              MOVS     r2,#1
000126  4631              MOV      r1,r6
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       USART_ITConfig
;;;234    //  USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;235      /*使能串口2的发送和接收中断*/
;;;236      USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
00012e  2201              MOVS     r2,#1
000130  4631              MOV      r1,r6
000132  4628              MOV      r0,r5
000134  f7fffffe          BL       USART_ITConfig
;;;237    //  USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
;;;238    //  USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
;;;239    //  USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
;;;240    
;;;241      /* 使能串口1 */
;;;242      USART_Cmd(USART1, ENABLE);
000138  2101              MOVS     r1,#1
00013a  4620              MOV      r0,r4
00013c  f7fffffe          BL       USART_Cmd
;;;243      /* 使能串口2 */
;;;244      USART_Cmd(USART2, ENABLE);
000140  2101              MOVS     r1,#1
000142  4628              MOV      r0,r5
000144  f7fffffe          BL       USART_Cmd
;;;245      /* 使能串口3 */
;;;246    //  USART_Cmd(USART3, ENABLE);
;;;247    
;;;248    }
000148  b006              ADD      sp,sp,#0x18
00014a  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

00014e  0000              DCW      0x0000
                  |L7.336|
                          DCD      0x00140030
                  |L7.340|
                          DCD      0x40010800
                  |L7.344|
                          DCD      0x40011400
                  |L7.348|
                          DCD      0x422101a0
                  |L7.352|
                          DCD      0x42228000
                  |L7.356|
                          DCD      0x40013800
                  |L7.360|
                          DCD      0x40004400
