; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\main.o --asm_dir=.\ --list_dir=.\ --depend=.\main.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I.\RTE\_MainBoardForRTD -I"D:\software install\Keil\ARM\CMSIS\5.1.0\CMSIS\Include" -I"D:\software install\Keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\main.crf ..\main.c]
                          THUMB

                          AREA ||i.AdDaTest||, CODE, READONLY, ALIGN=2

                  AdDaTest PROC
;;;129    }
;;;130    void AdDaTest(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;131    {
000002  b08d              SUB      sp,sp,#0x34
;;;132    	float advalue[13];
;;;133    	int i;
;;;134    	u8 mode=MODE_VOLTAGE;
000004  2600              MOVS     r6,#0
;;;135    	//****************************************************************************//
;;;136    /////////////////////////AD采集通道测试--电压/电流模式////////////////////////////////
;;;137      printfStr("\r\n\r\n***************************AD ch1-ch12 TEST******************************");delay_ms(10);
000006  4830              LDR      r0,|L1.200|
000008  f7fffffe          BL       printfStr
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       delay_ms
;;;138    	for(i=1;i<13;i++)                                             //Ai1-Ai12设置为电压采样模式
000012  2401              MOVS     r4,#1
                  |L1.20|
;;;139    	{
;;;140    		AiChannelSetMux(i,MUX_VOLTAGE);
000014  b2e0              UXTB     r0,r4
000016  2101              MOVS     r1,#1
000018  f7fffffe          BL       AiChannelSetMux
00001c  1c64              ADDS     r4,r4,#1
00001e  2c0d              CMP      r4,#0xd               ;138
000020  dbf8              BLT      |L1.20|
;;;141    	}
;;;142    	
;;;143    	for(i=1;i<9;i++)                                              //A01-A08设置为电压/电流输出模式
000022  2401              MOVS     r4,#1
                  |L1.36|
;;;144    	{
;;;145    		AoChannelSetMux(i,MUX_VOLTAGE);
000024  b2e0              UXTB     r0,r4
000026  2101              MOVS     r1,#1
000028  f7fffffe          BL       AoChannelSetMux
00002c  1c64              ADDS     r4,r4,#1
00002e  2c09              CMP      r4,#9                 ;143
000030  dbf8              BLT      |L1.36|
;;;146    	}
;;;147    	
;;;148    	for(i=1;i<9;i++)                                             //channel Ao1-Ao8输出1~8V电压/1-8ma电流
;;;149    	{
;;;150    		SetAoOut(DAREG[i-1]/100.0,i,mode); 
000032  4d26              LDR      r5,|L1.204|
000034  4f26              LDR      r7,|L1.208|
000036  2401              MOVS     r4,#1                 ;148
                  |L1.56|
000038  eb050044          ADD      r0,r5,r4,LSL #1
00003c  f8300c02          LDRH     r0,[r0,#-2]
000040  f7fffffe          BL       __aeabi_ui2d
000044  2200              MOVS     r2,#0
000046  463b              MOV      r3,r7
000048  f7fffffe          BL       __aeabi_ddiv
00004c  f7fffffe          BL       __aeabi_d2f
000050  b2e1              UXTB     r1,r4
000052  4632              MOV      r2,r6
000054  f7fffffe          BL       SetAoOut
000058  1c64              ADDS     r4,r4,#1
00005a  2c09              CMP      r4,#9                 ;148
00005c  dbec              BLT      |L1.56|
;;;151    	}
;;;152    																																
;;;153    	
;;;154    	for(i=1;i<13;i++)               															//读取模拟通道数值
00005e  2401              MOVS     r4,#1
000060  466d              MOV      r5,sp                 ;132
                  |L1.98|
;;;155    	{
;;;156    		advalue[i]=ReadAdOfChannel(i,mode);
000062  b2e0              UXTB     r0,r4
000064  4631              MOV      r1,r6
000066  f7fffffe          BL       ReadAdOfChannel
00006a  f8450024          STR      r0,[r5,r4,LSL #2]
00006e  1c64              ADDS     r4,r4,#1
000070  2c0d              CMP      r4,#0xd               ;154
000072  dbf6              BLT      |L1.98|
;;;157    	}
;;;158    	
;;;159    	printfStr("\r\nAD Resault: \r\n AD1~12: ");  									//通过串口打印输出
000074  a017              ADR      r0,|L1.212|
000076  f7fffffe          BL       printfStr
;;;160    	delay_ms(3);	
00007a  2003              MOVS     r0,#3
00007c  f7fffffe          BL       delay_ms
;;;161    	for(i=1;i<13;i++)
;;;162    	{
;;;163    		printfFloat(advalue[i]);
;;;164    		printfStr("  ");  delay_ms(2);					
;;;165    		AdREG[i-1]=advalue[i]*100;          //更新modbus 映射寄存器 Ad ch1-ch12
000080  4f1b              LDR      r7,|L1.240|
000082  4e1c              LDR      r6,|L1.244|
000084  2401              MOVS     r4,#1                 ;161
000086  bf00              NOP                            ;163
                  |L1.136|
000088  f8550024          LDR      r0,[r5,r4,LSL #2]     ;163
00008c  f7fffffe          BL       printfFloat
000090  a019              ADR      r0,|L1.248|
000092  f7fffffe          BL       printfStr
000096  2002              MOVS     r0,#2                 ;164
000098  f7fffffe          BL       delay_ms
00009c  f8550024          LDR      r0,[r5,r4,LSL #2]
0000a0  4639              MOV      r1,r7
0000a2  f7fffffe          BL       __aeabi_fmul
0000a6  f7fffffe          BL       __aeabi_f2uiz
0000aa  eb060144          ADD      r1,r6,r4,LSL #1
0000ae  1c64              ADDS     r4,r4,#1
0000b0  f8210c02          STRH     r0,[r1,#-2]
0000b4  2c0d              CMP      r4,#0xd               ;161
0000b6  dbe7              BLT      |L1.136|
;;;166    	}
;;;167    	printfStr("\r\n: ");delay_ms(2);
0000b8  a010              ADR      r0,|L1.252|
0000ba  f7fffffe          BL       printfStr
0000be  2002              MOVS     r0,#2
0000c0  f7fffffe          BL       delay_ms
;;;168    }
0000c4  b00d              ADD      sp,sp,#0x34
0000c6  bdf0              POP      {r4-r7,pc}
;;;169    void DioTest(void)
                          ENDP

                  |L1.200|
                          DCD      ||.conststring||+0x90
                  |L1.204|
                          DCD      DAREG
                  |L1.208|
                          DCD      0x40590000
                  |L1.212|
0000d4  0d0a4144          DCB      "\r\nAD Resault: \r\n AD1~12: ",0
0000d8  20526573
0000dc  61756c74
0000e0  3a200d0a
0000e4  20414431
0000e8  7e31323a
0000ec  2000    
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L1.240|
                          DCD      0x42c80000
                  |L1.244|
                          DCD      AdREG
                  |L1.248|
0000f8  202000            DCB      "  ",0
0000fb  00                DCB      0
                  |L1.252|
0000fc  0d0a3a20          DCB      "\r\n: ",0
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0

                          AREA ||i.DioTest||, CODE, READONLY, ALIGN=2

                  DioTest PROC
;;;168    }
;;;169    void DioTest(void)
000000  b570              PUSH     {r4-r6,lr}
;;;170    {
;;;171    	unsigned char DiMap;
;;;172    	int i;
;;;173    	//****************************************************************************//
;;;174    //////////////////////////DIO端口输入输出测试////////////////////////////////////
;;;175    																																		//设置继电器输出状态
;;;176    	printfStr("\r\n\r\n***************************DIO TEST******************************\r\n");delay_ms(10);
000002  4821              LDR      r0,|L2.136|
000004  f7fffffe          BL       printfStr
000008  200a              MOVS     r0,#0xa
00000a  f7fffffe          BL       delay_ms
;;;177    	for(i=0;i<8;i++)
;;;178    	{
;;;179    		if(DoREG[i]==0)
00000e  4d1f              LDR      r5,|L2.140|
000010  2400              MOVS     r4,#0                 ;177
000012  bf00              NOP      
                  |L2.20|
000014  f8350014          LDRH     r0,[r5,r4,LSL #1]
000018  2800              CMP      r0,#0
;;;180    		{
;;;181    			SetSpdtState(i+1,SpdtOFF);
;;;182    		}
;;;183    		else
;;;184    			SetSpdtState(i+1,SpdtON);
00001a  f1040001          ADD      r0,r4,#1
00001e  b2c0              UXTB     r0,r0
000020  d01a              BEQ      |L2.88|
000022  2101              MOVS     r1,#1
                  |L2.36|
000024  f7fffffe          BL       SetSpdtState
000028  1c64              ADDS     r4,r4,#1
00002a  2c08              CMP      r4,#8                 ;177
00002c  dbf2              BLT      |L2.20|
;;;185    	}
;;;186    	DiMap=GetDiMap();                                              //获取Di输入状态
00002e  f7fffffe          BL       GetDiMap
000032  4604              MOV      r4,r0
;;;187    	
;;;188    	printfStr("DI Resault: \r\n DI1~8: ");                     //打印DI状态到串口输出
000034  a016              ADR      r0,|L2.144|
000036  f7fffffe          BL       printfStr
;;;189    	delay_ms(3);
00003a  2003              MOVS     r0,#3
00003c  f7fffffe          BL       delay_ms
;;;190    	printfStr("\r\nCH1 CH2 CH3 CH4 CH5 CH6 CH7 CH8 \r\n");
000040  a019              ADR      r0,|L2.168|
000042  f7fffffe          BL       printfStr
;;;191    	delay_ms(3);
000046  2003              MOVS     r0,#3
000048  f7fffffe          BL       delay_ms
;;;192    	for(i=0;i<8;i++)
;;;193    	{
;;;194    		if(DiMap&0x01)
;;;195    		{
;;;196    			printfStr("-H- ");delay_ms(1);
;;;197    		}
;;;198    		else
;;;199    		{
;;;200    			printfStr("-L- ");delay_ms(1);
;;;201    		}
;;;202    		DiREG[i]=DiMap&0x01;        //更新modbus 映射寄存器 Di ch1-ch8
00004c  4e20              LDR      r6,|L2.208|
00004e  2500              MOVS     r5,#0                 ;192
                  |L2.80|
000050  07e0              LSLS     r0,r4,#31             ;194
000052  d003              BEQ      |L2.92|
000054  a01f              ADR      r0,|L2.212|
000056  e002              B        |L2.94|
                  |L2.88|
000058  2100              MOVS     r1,#0                 ;181
00005a  e7e3              B        |L2.36|
                  |L2.92|
00005c  a01f              ADR      r0,|L2.220|
                  |L2.94|
00005e  f7fffffe          BL       printfStr
000062  2001              MOVS     r0,#1                 ;200
000064  f7fffffe          BL       delay_ms
000068  f0040001          AND      r0,r4,#1
00006c  f8260015          STRH     r0,[r6,r5,LSL #1]
;;;203    		DiMap>>=1;
000070  0864              LSRS     r4,r4,#1
000072  1c6d              ADDS     r5,r5,#1
000074  2d08              CMP      r5,#8                 ;192
000076  dbeb              BLT      |L2.80|
;;;204    	}
;;;205    	printfStr("\r\n: ");delay_ms(2);
000078  a01a              ADR      r0,|L2.228|
00007a  f7fffffe          BL       printfStr
00007e  e8bd4070          POP      {r4-r6,lr}
000082  2002              MOVS     r0,#2
000084  f7ffbffe          B.W      delay_ms
;;;206    			
;;;207    }
;;;208    void RtdTest(void)
                          ENDP

                  |L2.136|
                          DCD      ||.conststring||+0x48
                  |L2.140|
                          DCD      DoREG
                  |L2.144|
000090  44492052          DCB      "DI Resault: \r\n DI1~8: ",0
000094  65736175
000098  6c743a20
00009c  0d0a2044
0000a0  49317e38
0000a4  3a2000  
0000a7  00                DCB      0
                  |L2.168|
0000a8  0d0a4348          DCB      "\r\nCH1 CH2 CH3 CH4 CH5 CH6 CH7 CH8 \r\n",0
0000ac  31204348
0000b0  32204348
0000b4  33204348
0000b8  34204348
0000bc  35204348
0000c0  36204348
0000c4  37204348
0000c8  38200d0a
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L2.208|
                          DCD      DiREG
                  |L2.212|
0000d4  2d482d20          DCB      "-H- ",0
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L2.220|
0000dc  2d4c2d20          DCB      "-L- ",0
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L2.228|
0000e4  0d0a3a20          DCB      "\r\n: ",0
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0

                          AREA ||i.LedInit||, CODE, READONLY, ALIGN=2

                  LedInit PROC
;;;351    }
;;;352    void LedInit()
000000  b508              PUSH     {r3,lr}
;;;353    {
;;;354    	GPIO_InitTypeDef GPIO_InitStructure;
;;;355    	
;;;356    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB  , ENABLE);
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;357    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00000a  f44f7000          MOV      r0,#0x200
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;358      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;359      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000018  2010              MOVS     r0,#0x10
00001a  f88d0003          STRB     r0,[sp,#3]
;;;360      GPIO_Init(GPIOB, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L3.40|
000022  f7fffffe          BL       GPIO_Init
;;;361    }
000026  bd08              POP      {r3,pc}
;;;362    
                          ENDP

                  |L3.40|
                          DCD      0x40010c00

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;331    }
;;;332    void NVIC_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;333    {
;;;334      NVIC_InitTypeDef NVIC_InitStructure;
;;;335        NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//设置NVIC中断分组2:2位抢占优先级，2位响应优先级
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;336    
;;;337    	 NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
;;;338      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000010  2400              MOVS     r4,#0
000012  f88d4002          STRB     r4,[sp,#2]
;;;339      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000016  2501              MOVS     r5,#1
000018  f88d5003          STRB     r5,[sp,#3]
;;;340      NVIC_Init(&NVIC_InitStructure);
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       NVIC_Init
;;;341      
;;;342    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000022  2026              MOVS     r0,#0x26
000024  f88d0000          STRB     r0,[sp,#0]
;;;343      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000028  f88d4002          STRB     r4,[sp,#2]
;;;344      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00002c  f88d5003          STRB     r5,[sp,#3]
;;;345      NVIC_Init(&NVIC_InitStructure);
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       NVIC_Init
;;;346    
;;;347    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
000036  2027              MOVS     r0,#0x27
000038  f88d0000          STRB     r0,[sp,#0]
;;;348      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00003c  f88d4002          STRB     r4,[sp,#2]
;;;349      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000040  f88d5003          STRB     r5,[sp,#3]
;;;350      NVIC_Init(&NVIC_InitStructure);
000044  4668              MOV      r0,sp
000046  f7fffffe          BL       NVIC_Init
;;;351    }
00004a  bd38              POP      {r3-r5,pc}
;;;352    void LedInit()
                          ENDP


                          AREA ||i.R485Test||, CODE, READONLY, ALIGN=2

                  R485Test PROC
;;;99     }
;;;100    void R485Test(void)
000000  b570              PUSH     {r4-r6,lr}
;;;101    {
;;;102    	//****************************************************************************//
;;;103    /////////////////////////////////////485测试////////////////////////////////////
;;;104    	 printfStr("\r\n\r\n***************************RS4885 TEST******************************\r\n");delay_ms(10);
000002  4816              LDR      r0,|L5.92|
000004  f7fffffe          BL       printfStr
000008  200a              MOVS     r0,#0xa
00000a  f7fffffe          BL       delay_ms
;;;105    	 Uart4851_TestFlag=0;
00000e  4c14              LDR      r4,|L5.96|
;;;106    	 Uart4852_TestFlag=0;
000010  4d14              LDR      r5,|L5.100|
000012  2000              MOVS     r0,#0                 ;105
000014  7020              STRB     r0,[r4,#0]            ;105
000016  7028              STRB     r0,[r5,#0]
;;;107    	 SendStr4852("HRTOUSART1 ");
000018  a013              ADR      r0,|L5.104|
00001a  f7fffffe          BL       SendStr4852
;;;108    	 delay_ms(50);
00001e  2032              MOVS     r0,#0x32
000020  f7fffffe          BL       delay_ms
;;;109    	 SendStr4851("HRTOUSART2 ");
000024  a013              ADR      r0,|L5.116|
000026  f7fffffe          BL       SendStr4851
;;;110    	 delay_ms(50);
00002a  2032              MOVS     r0,#0x32
00002c  f7fffffe          BL       delay_ms
;;;111    	
;;;112    	 if(Uart4851_TestFlag)                 //输出485 ch1 状态
000030  7820              LDRB     r0,[r4,#0]  ; Uart4851_TestFlag
000032  b108              CBZ      r0,|L5.56|
;;;113    	 {
;;;114    		 printfStr("485-1 test succeed!!\r\n");delay_ms(3);
000034  a012              ADR      r0,|L5.128|
000036  e000              B        |L5.58|
                  |L5.56|
;;;115    	 }
;;;116    	 else
;;;117    	 {
;;;118    		 printfStr("485-1 test failed!!\r\n");delay_ms(3);
000038  a017              ADR      r0,|L5.152|
                  |L5.58|
00003a  f7fffffe          BL       printfStr
00003e  2003              MOVS     r0,#3
000040  f7fffffe          BL       delay_ms
;;;119    	 }
;;;120    	 
;;;121    	 if(Uart4852_TestFlag)                 //输出485 ch2 状态
000044  7828              LDRB     r0,[r5,#0]  ; Uart4852_TestFlag
000046  b108              CBZ      r0,|L5.76|
;;;122    	 {
;;;123    		 printfStr("485-2 test succeed!!\r\n");delay_ms(3);
000048  a019              ADR      r0,|L5.176|
00004a  e000              B        |L5.78|
                  |L5.76|
;;;124    	 }
;;;125    	 else
;;;126    	 {
;;;127    		 printfStr("485-2 test failed!!\r\n");delay_ms(3);
00004c  a01e              ADR      r0,|L5.200|
                  |L5.78|
00004e  f7fffffe          BL       printfStr
000052  e8bd4070          POP      {r4-r6,lr}
000056  2003              MOVS     r0,#3
000058  f7ffbffe          B.W      delay_ms
;;;128    	 }
;;;129    }
;;;130    void AdDaTest(void)
                          ENDP

                  |L5.92|
                          DCD      ||.conststring||+0xe0
                  |L5.96|
                          DCD      Uart4851_TestFlag
                  |L5.100|
                          DCD      Uart4852_TestFlag
                  |L5.104|
000068  4852544f          DCB      "HRTOUSART1 ",0
00006c  55534152
000070  54312000
                  |L5.116|
000074  4852544f          DCB      "HRTOUSART2 ",0
000078  55534152
00007c  54322000
                  |L5.128|
000080  3438352d          DCB      "485-1 test succeed!!\r\n",0
000084  31207465
000088  73742073
00008c  75636365
000090  65642121
000094  0d0a00  
000097  00                DCB      0
                  |L5.152|
000098  3438352d          DCB      "485-1 test failed!!\r\n",0
00009c  31207465
0000a0  73742066
0000a4  61696c65
0000a8  6421210d
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L5.176|
0000b0  3438352d          DCB      "485-2 test succeed!!\r\n",0
0000b4  32207465
0000b8  73742073
0000bc  75636365
0000c0  65642121
0000c4  0d0a00  
0000c7  00                DCB      0
                  |L5.200|
0000c8  3438352d          DCB      "485-2 test failed!!\r\n",0
0000cc  32207465
0000d0  73742066
0000d4  61696c65
0000d8  6421210d
0000dc  0a00    
0000de  00                DCB      0
0000df  00                DCB      0

                          AREA ||i.RtdTest||, CODE, READONLY, ALIGN=2

                  RtdTest PROC
;;;207    }
;;;208    void RtdTest(void)
000000  b57f              PUSH     {r0-r6,lr}
;;;209    {
;;;210    	float temp[4]={0};
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  9001              STR      r0,[sp,#4]
000008  9002              STR      r0,[sp,#8]
;;;211    	
;;;212    //*********************************************************************************//
;;;213    //////////////////////////RTD模块测试输出////////////////////////////////////////////
;;;214    	printfStr("\r\n\r\n***************************RTD TEST******************************\r\n");delay_ms(10);
00000a  9003              STR      r0,[sp,#0xc]
00000c  4828              LDR      r0,|L6.176|
00000e  f7fffffe          BL       printfStr
000012  200a              MOVS     r0,#0xa
000014  f7fffffe          BL       delay_ms
;;;215    	RTD_allchannels(temp);                                         //读取RTD通道数值
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       RTD_allchannels
;;;216    		
;;;217    	printfStr("RTD Resault: \r\n RTD_0: ");delay_ms(3);				 //通过串口打印输出
00001e  a025              ADR      r0,|L6.180|
000020  f7fffffe          BL       printfStr
000024  2003              MOVS     r0,#3
000026  f7fffffe          BL       delay_ms
;;;218    	printfFloat(temp[0]);
00002a  9800              LDR      r0,[sp,#0]
00002c  f7fffffe          BL       printfFloat
;;;219    	printfStr("℃\r\n RTD_1: ");delay_ms(2);
000030  a026              ADR      r0,|L6.204|
000032  f7fffffe          BL       printfStr
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       delay_ms
;;;220    	printfFloat(temp[1]);
00003c  9801              LDR      r0,[sp,#4]
00003e  f7fffffe          BL       printfFloat
;;;221    	printfStr("℃\r\n RTD_2: ");delay_ms(2);
000042  a026              ADR      r0,|L6.220|
000044  f7fffffe          BL       printfStr
000048  2002              MOVS     r0,#2
00004a  f7fffffe          BL       delay_ms
;;;222    	printfFloat(temp[2]);
00004e  9802              LDR      r0,[sp,#8]
000050  f7fffffe          BL       printfFloat
;;;223    	printfStr("℃\r\n RTD_3: ");delay_ms(2);
000054  a025              ADR      r0,|L6.236|
000056  f7fffffe          BL       printfStr
00005a  2002              MOVS     r0,#2
00005c  f7fffffe          BL       delay_ms
;;;224    	printfFloat(temp[3]);
000060  9803              LDR      r0,[sp,#0xc]
000062  f7fffffe          BL       printfFloat
;;;225    	printfStr("℃\r\n");delay_ms(2);
000066  a025              ADR      r0,|L6.252|
000068  f7fffffe          BL       printfStr
00006c  2002              MOVS     r0,#2
00006e  f7fffffe          BL       delay_ms
;;;226    	
;;;227    	RTDREG[0]=temp[0]*100;                  //更新modbus 映射寄存器 RTD ch1-ch4
000072  4d24              LDR      r5,|L6.260|
000074  9800              LDR      r0,[sp,#0]
000076  4629              MOV      r1,r5
000078  f7fffffe          BL       __aeabi_fmul
00007c  f7fffffe          BL       __aeabi_f2iz
000080  4c21              LDR      r4,|L6.264|
;;;228    	RTDREG[1]=temp[1]*100;
000082  4629              MOV      r1,r5
000084  8020              STRH     r0,[r4,#0]            ;227
000086  9801              LDR      r0,[sp,#4]
000088  f7fffffe          BL       __aeabi_fmul
00008c  f7fffffe          BL       __aeabi_f2iz
000090  8060              STRH     r0,[r4,#2]
;;;229    	RTDREG[2]=temp[2]*100;
000092  4629              MOV      r1,r5
000094  9802              LDR      r0,[sp,#8]
000096  f7fffffe          BL       __aeabi_fmul
00009a  f7fffffe          BL       __aeabi_f2iz
00009e  80a0              STRH     r0,[r4,#4]
;;;230    	RTDREG[3]=temp[3]*100;
0000a0  4629              MOV      r1,r5
0000a2  9803              LDR      r0,[sp,#0xc]
0000a4  f7fffffe          BL       __aeabi_fmul
0000a8  f7fffffe          BL       __aeabi_f2iz
0000ac  80e0              STRH     r0,[r4,#6]
;;;231    }
0000ae  bd7f              POP      {r0-r6,pc}
;;;232    void printfFloat(float Dat)
                          ENDP

                  |L6.176|
                          DCD      ||.conststring||
                  |L6.180|
0000b4  52544420          DCB      "RTD Resault: \r\n RTD_0: ",0
0000b8  52657361
0000bc  756c743a
0000c0  200d0a20
0000c4  5254445f
0000c8  303a2000
                  |L6.204|
0000cc  a1e60d0a          DCB      161,230,"\r\n RTD_1: ",0
0000d0  20525444
0000d4  5f313a20
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L6.220|
0000dc  a1e60d0a          DCB      161,230,"\r\n RTD_2: ",0
0000e0  20525444
0000e4  5f323a20
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L6.236|
0000ec  a1e60d0a          DCB      161,230,"\r\n RTD_3: ",0
0000f0  20525444
0000f4  5f333a20
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L6.252|
0000fc  a1e60d0a          DCB      161,230,"\r\n",0
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0
                  |L6.260|
                          DCD      0x42c80000
                  |L6.264|
                          DCD      RTDREG

                          AREA ||i.SendStr4851||, CODE, READONLY, ALIGN=2

                  SendStr4851 PROC
;;;277    }
;;;278    void SendStr4851(char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;279    {		
000002  4604              MOV      r4,r0
;;;280    	DE1=0;
000004  480e              LDR      r0,|L7.64|
000006  2500              MOVS     r5,#0
000008  f8c051a0          STR      r5,[r0,#0x1a0]
;;;281    	delay_ms(1);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       delay_ms
;;;282    	Uart1_SendBuffSize=0;
000012  490c              LDR      r1,|L7.68|
;;;283    	while(*str!=0x00)
;;;284    	{
;;;285    		Uart1_Send_buffer[Uart1_SendBuffSize++]=*str;
000014  4b0c              LDR      r3,|L7.72|
000016  700d              STRB     r5,[r1,#0]            ;282
000018  e004              B        |L7.36|
                  |L7.26|
00001a  7808              LDRB     r0,[r1,#0]  ; Uart1_SendBuffSize
00001c  541a              STRB     r2,[r3,r0]
00001e  1c40              ADDS     r0,r0,#1
000020  7008              STRB     r0,[r1,#0]
000022  1c64              ADDS     r4,r4,#1
                  |L7.36|
000024  7822              LDRB     r2,[r4,#0]            ;283
000026  2a00              CMP      r2,#0                 ;283
000028  d1f7              BNE      |L7.26|
;;;286    		str++;
;;;287    	}
;;;288    	Uart1_SCnt=0;
00002a  4808              LDR      r0,|L7.76|
;;;289    	USART_ITConfig(USART1,USART_IT_TXE,ENABLE);			  	//
00002c  2201              MOVS     r2,#1
00002e  f2407127          MOV      r1,#0x727
000032  7005              STRB     r5,[r0,#0]            ;288
000034  e8bd4070          POP      {r4-r6,lr}
000038  4805              LDR      r0,|L7.80|
00003a  f7ffbffe          B.W      USART_ITConfig
;;;290    			
;;;291    }
;;;292    void SendStr4852(char *str)
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      0x42210000
                  |L7.68|
                          DCD      Uart1_SendBuffSize
                  |L7.72|
                          DCD      Uart1_Send_buffer
                  |L7.76|
                          DCD      Uart1_SCnt
                  |L7.80|
                          DCD      0x40013800

                          AREA ||i.SendStr4852||, CODE, READONLY, ALIGN=2

                  SendStr4852 PROC
;;;291    }
;;;292    void SendStr4852(char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;293    {		
000002  4604              MOV      r4,r0
;;;294    	DE2=0;
000004  480e              LDR      r0,|L8.64|
000006  2500              MOVS     r5,#0
000008  f8c0519c          STR      r5,[r0,#0x19c]
;;;295    	delay_ms(1);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       delay_ms
;;;296    	Uart2_SendBuffSize=0;
000012  490c              LDR      r1,|L8.68|
;;;297    	while(*str!=0x00)
;;;298    	{
;;;299    		Uart2_Send_buffer[Uart2_SendBuffSize++]=*str;
000014  4b0c              LDR      r3,|L8.72|
000016  700d              STRB     r5,[r1,#0]            ;296
000018  e004              B        |L8.36|
                  |L8.26|
00001a  7808              LDRB     r0,[r1,#0]  ; Uart2_SendBuffSize
00001c  541a              STRB     r2,[r3,r0]
00001e  1c40              ADDS     r0,r0,#1
000020  7008              STRB     r0,[r1,#0]
000022  1c64              ADDS     r4,r4,#1
                  |L8.36|
000024  7822              LDRB     r2,[r4,#0]            ;297
000026  2a00              CMP      r2,#0                 ;297
000028  d1f7              BNE      |L8.26|
;;;300    		str++;
;;;301    	}
;;;302    	Uart2_SCnt=0;
00002a  4808              LDR      r0,|L8.76|
;;;303    	USART_ITConfig(USART2,USART_IT_TXE,ENABLE);			  	//
00002c  2201              MOVS     r2,#1
00002e  f2407127          MOV      r1,#0x727
000032  7005              STRB     r5,[r0,#0]            ;302
000034  e8bd4070          POP      {r4-r6,lr}
000038  4805              LDR      r0,|L8.80|
00003a  f7ffbffe          B.W      USART_ITConfig
;;;304    			
;;;305    }
;;;306    void TIM2_Int_Init(u16 arr,u16 psc)
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      0x42228000
                  |L8.68|
                          DCD      Uart2_SendBuffSize
                  |L8.72|
                          DCD      Uart2_Send_buffer
                  |L8.76|
                          DCD      Uart2_SCnt
                  |L8.80|
                          DCD      0x40004400

                          AREA ||i.TIM2_Int_Init||, CODE, READONLY, ALIGN=1

                  TIM2_Int_Init PROC
;;;305    }
;;;306    void TIM2_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;307    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;308        TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;309    	NVIC_InitTypeDef NVIC_InitStructure;
;;;310    
;;;311    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); //时钟使能
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;312    
;;;313    	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 
00000e  f8ad5004          STRH     r5,[sp,#4]
;;;314    	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  
000012  f8ad4000          STRH     r4,[sp,#0]
;;;315    	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000016  2400              MOVS     r4,#0
;;;316    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
;;;317    	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000018  f04f4580          MOV      r5,#0x40000000
00001c  f8ad4006          STRH     r4,[sp,#6]            ;315
000020  f8ad4002          STRH     r4,[sp,#2]            ;316
000024  4669              MOV      r1,sp
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       TIM_TimeBaseInit
;;;318     
;;;319    	TIM_ITConfig(  //使能或者失能指定的TIM中断
00002c  2201              MOVS     r2,#1
00002e  4611              MOV      r1,r2
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       TIM_ITConfig
;;;320    		TIM2, //TIM2
;;;321    		TIM_IT_Update ,
;;;322    		ENABLE  //使能
;;;323    		);
;;;324    	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;  //TIM3中断
000036  201c              MOVS     r0,#0x1c
000038  f88d000c          STRB     r0,[sp,#0xc]
;;;325    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  //先占优先级0级
00003c  f88d400d          STRB     r4,[sp,#0xd]
;;;326    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //从优先级3级
000040  2003              MOVS     r0,#3
000042  f88d000e          STRB     r0,[sp,#0xe]
;;;327    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
000046  2001              MOVS     r0,#1
000048  f88d000f          STRB     r0,[sp,#0xf]
;;;328    	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
00004c  a803              ADD      r0,sp,#0xc
00004e  f7fffffe          BL       NVIC_Init
;;;329    
;;;330    	TIM_Cmd(TIM2, ENABLE);  //使能TIMx外设						 
000052  2101              MOVS     r1,#1
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       TIM_Cmd
;;;331    }
00005a  bd7f              POP      {r0-r6,pc}
;;;332    void NVIC_Configuration(void)
                          ENDP


                          AREA ||i.UART_Configuration||, CODE, READONLY, ALIGN=2

                  UART_Configuration PROC
;;;362    
;;;363    void UART_Configuration(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;364    {
000004  b086              SUB      sp,sp,#0x18
;;;365    	USART_InitTypeDef USART_InitStructure;
;;;366    	
;;;367    	GPIO_InitTypeDef GPIO_InitStructure;
;;;368    
;;;369    	
;;;370    	RCC_APB2PeriphClockCmd(USART1_GPIO_CLK  , ENABLE);
000006  2101              MOVS     r1,#1
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;371    	RCC_APB2PeriphClockCmd(USART2_GPIO_CLK  , ENABLE);
00000e  2101              MOVS     r1,#1
000010  2020              MOVS     r0,#0x20
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;372    	RCC_APB2PeriphClockCmd(USART3_GPIO_CLK  , ENABLE);
000016  2101              MOVS     r1,#1
000018  2020              MOVS     r0,#0x20
00001a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;373    	
;;;374    	RCC_APB2PeriphClockCmd(USART1_CLK  , ENABLE);
00001e  2101              MOVS     r1,#1
000020  0388              LSLS     r0,r1,#14
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;375    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO  , ENABLE);
000026  2101              MOVS     r1,#1
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;376    	
;;;377    	RCC_APB1PeriphClockCmd(USART2_CLK  , ENABLE);
00002e  2101              MOVS     r1,#1
000030  0448              LSLS     r0,r1,#17
000032  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;378    	RCC_APB1PeriphClockCmd(USART3_CLK  , ENABLE);
000036  2101              MOVS     r1,#1
000038  0488              LSLS     r0,r1,#18
00003a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;379    	GPIO_PinRemapConfig(GPIO_FullRemap_USART3, ENABLE);  
00003e  2101              MOVS     r1,#1
000040  484d              LDR      r0,|L10.376|
000042  f7fffffe          BL       GPIO_PinRemapConfig
;;;380    	GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);  
000046  2101              MOVS     r1,#1
000048  2008              MOVS     r0,#8
00004a  f7fffffe          BL       GPIO_PinRemapConfig
;;;381      /*串口1 RX管脚配置*/
;;;382      /* Configure USART1 Rx as input floating */
;;;383      GPIO_InitStructure.GPIO_Pin = USART1_RxPin;
00004e  f44f6080          MOV      r0,#0x400
000052  f8ad0000          STRH     r0,[sp,#0]
;;;384      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000056  2004              MOVS     r0,#4
;;;385      GPIO_Init(USART1_GPIO, &GPIO_InitStructure);
000058  f8df8120          LDR      r8,|L10.380|
00005c  f88d0003          STRB     r0,[sp,#3]            ;384
000060  4669              MOV      r1,sp
000062  4640              MOV      r0,r8
000064  f7fffffe          BL       GPIO_Init
;;;386    
;;;387      /*串口2 RX管脚配置*/
;;;388      /* Configure USART2 Rx as input floating */
;;;389      GPIO_InitStructure.GPIO_Pin = USART2_RxPin;
000068  2040              MOVS     r0,#0x40
;;;390      GPIO_Init(USART2_GPIO, &GPIO_InitStructure);  
00006a  4f45              LDR      r7,|L10.384|
00006c  f8ad0000          STRH     r0,[sp,#0]            ;389
000070  4669              MOV      r1,sp
000072  4638              MOV      r0,r7
000074  f7fffffe          BL       GPIO_Init
;;;391    
;;;392      /*串口3 RX管脚配置*/
;;;393      /* Configure USART3 Rx as input floating */
;;;394      GPIO_InitStructure.GPIO_Pin = USART3_RxPin;
000078  157c              ASRS     r4,r7,#21
00007a  f8ad4000          STRH     r4,[sp,#0]
;;;395      GPIO_Init(USART3_GPIO, &GPIO_InitStructure);
00007e  4669              MOV      r1,sp
000080  4638              MOV      r0,r7
000082  f7fffffe          BL       GPIO_Init
;;;396    
;;;397    
;;;398    
;;;399      /*串口1 TX管脚配置*/ 
;;;400      /* Configure USART1 Tx as alternate function push-pull */
;;;401      GPIO_InitStructure.GPIO_Pin = USART1_TxPin;
000086  f8ad4000          STRH     r4,[sp,#0]
;;;402      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00008a  2403              MOVS     r4,#3
00008c  f88d4002          STRB     r4,[sp,#2]
;;;403      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000090  2018              MOVS     r0,#0x18
000092  f88d0003          STRB     r0,[sp,#3]
;;;404      GPIO_Init(USART1_GPIO, &GPIO_InitStructure);
000096  4669              MOV      r1,sp
000098  4640              MOV      r0,r8
00009a  f7fffffe          BL       GPIO_Init
;;;405      
;;;406      GPIO_InitStructure.GPIO_Pin = USART2_TxPin;
00009e  2020              MOVS     r0,#0x20
0000a0  f8ad0000          STRH     r0,[sp,#0]
;;;407      GPIO_Init(USART2_GPIO, &GPIO_InitStructure);
0000a4  4669              MOV      r1,sp
0000a6  4638              MOV      r0,r7
0000a8  f7fffffe          BL       GPIO_Init
;;;408    	
;;;409    	GPIO_InitStructure.GPIO_Pin = USART3_TxPin;
0000ac  15bd              ASRS     r5,r7,#22
0000ae  f8ad5000          STRH     r5,[sp,#0]
;;;410      GPIO_Init(USART3_GPIO, &GPIO_InitStructure);
0000b2  4669              MOV      r1,sp
0000b4  4638              MOV      r0,r7
0000b6  f7fffffe          BL       GPIO_Init
;;;411    	
;;;412    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
0000ba  2080              MOVS     r0,#0x80
0000bc  f8ad0000          STRH     r0,[sp,#0]
;;;413      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000c0  f88d4002          STRB     r4,[sp,#2]
;;;414      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000c4  2610              MOVS     r6,#0x10
0000c6  f88d6003          STRB     r6,[sp,#3]
;;;415      GPIO_Init(GPIOD, &GPIO_InitStructure);
0000ca  4669              MOV      r1,sp
0000cc  4638              MOV      r0,r7
0000ce  f7fffffe          BL       GPIO_Init
;;;416    	
;;;417    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
0000d2  f8ad5000          STRH     r5,[sp,#0]
;;;418      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000d6  f88d4002          STRB     r4,[sp,#2]
;;;419      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000da  f88d6003          STRB     r6,[sp,#3]
;;;420      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000de  4669              MOV      r1,sp
0000e0  4640              MOV      r0,r8
0000e2  f7fffffe          BL       GPIO_Init
;;;421    	
;;;422      DE1=1;
0000e6  4927              LDR      r1,|L10.388|
0000e8  2001              MOVS     r0,#1
0000ea  f8c101a0          STR      r0,[r1,#0x1a0]
;;;423    	DE2=1;
0000ee  4926              LDR      r1,|L10.392|
0000f0  f8c1019c          STR      r0,[r1,#0x19c]
;;;424    	
;;;425    /* USART1 and USART2 configuration */
;;;426    
;;;427      /* USART1 and USART2 configured as follow:
;;;428            - BaudRate = 9600 baud  
;;;429            - Word Length = 8 Bits
;;;430            - One Stop Bit
;;;431            - No parity
;;;432            - Hardware flow control disabled (RTS and CTS signals)
;;;433            - Receive and transmit enabled
;;;434      */
;;;435      USART_InitStructure.USART_BaudRate = 9600;               /*设置波特率为115200*/
0000f4  f44f5016          MOV      r0,#0x2580
;;;436      USART_InitStructure.USART_WordLength = USART_WordLength_8b;/*设置数据位为8*/
0000f8  9001              STR      r0,[sp,#4]
0000fa  2000              MOVS     r0,#0
0000fc  f8ad0008          STRH     r0,[sp,#8]
;;;437      USART_InitStructure.USART_StopBits = USART_StopBits_1;     /*设置停止位为1位*/
000100  f8ad000a          STRH     r0,[sp,#0xa]
;;;438      USART_InitStructure.USART_Parity = USART_Parity_No;        /*无奇偶校验*/
000104  f8ad000c          STRH     r0,[sp,#0xc]
;;;439      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;/*无硬件流控*/
000108  f8ad0010          STRH     r0,[sp,#0x10]
;;;440      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;  /*发送和接收*/
00010c  200c              MOVS     r0,#0xc
;;;441    
;;;442      /*配置串口1 */
;;;443      USART_Init(USART1, &USART_InitStructure);
00010e  4c1f              LDR      r4,|L10.396|
000110  f8ad000e          STRH     r0,[sp,#0xe]          ;440
000114  a901              ADD      r1,sp,#4
000116  4620              MOV      r0,r4
000118  f7fffffe          BL       USART_Init
;;;444    
;;;445      /*配置串口2*/
;;;446      USART_Init(USART2, &USART_InitStructure);
00011c  4d1c              LDR      r5,|L10.400|
00011e  a901              ADD      r1,sp,#4
000120  4628              MOV      r0,r5
000122  f7fffffe          BL       USART_Init
;;;447      /*配置串口3*/
;;;448    	USART_InitStructure.USART_BaudRate = 115200;
000126  f44f30e1          MOV      r0,#0x1c200
;;;449      USART_Init(USART3, &USART_InitStructure);
00012a  4e1a              LDR      r6,|L10.404|
00012c  9001              STR      r0,[sp,#4]
00012e  a901              ADD      r1,sp,#4
000130  4630              MOV      r0,r6
000132  f7fffffe          BL       USART_Init
;;;450    
;;;451      			    
;;;452      /*使能串口1的发送和接收中断*/
;;;453      USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
000136  f2405725          MOV      r7,#0x525
00013a  2201              MOVS     r2,#1
00013c  4639              MOV      r1,r7
00013e  4620              MOV      r0,r4
000140  f7fffffe          BL       USART_ITConfig
;;;454    //  USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;455      /*使能串口2的发送和接收中断*/
;;;456      USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000144  2201              MOVS     r2,#1
000146  4639              MOV      r1,r7
000148  4628              MOV      r0,r5
00014a  f7fffffe          BL       USART_ITConfig
;;;457    //  USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
;;;458      USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
00014e  2201              MOVS     r2,#1
000150  4639              MOV      r1,r7
000152  4630              MOV      r0,r6
000154  f7fffffe          BL       USART_ITConfig
;;;459    //  USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
;;;460    
;;;461      /* 使能串口1 */
;;;462      USART_Cmd(USART1, ENABLE);
000158  2101              MOVS     r1,#1
00015a  4620              MOV      r0,r4
00015c  f7fffffe          BL       USART_Cmd
;;;463      /* 使能串口2 */
;;;464      USART_Cmd(USART2, ENABLE);
000160  2101              MOVS     r1,#1
000162  4628              MOV      r0,r5
000164  f7fffffe          BL       USART_Cmd
;;;465      /* 使能串口3 */
;;;466      USART_Cmd(USART3, ENABLE);
000168  2101              MOVS     r1,#1
00016a  4630              MOV      r0,r6
00016c  f7fffffe          BL       USART_Cmd
;;;467    
;;;468    }
000170  b006              ADD      sp,sp,#0x18
000172  e8bd81f0          POP      {r4-r8,pc}
;;;469    /*******************************************************************************
                          ENDP

000176  0000              DCW      0x0000
                  |L10.376|
                          DCD      0x00140030
                  |L10.380|
                          DCD      0x40010800
                  |L10.384|
                          DCD      0x40011400
                  |L10.388|
                          DCD      0x42210000
                  |L10.392|
                          DCD      0x42228000
                  |L10.396|
                          DCD      0x40013800
                  |L10.400|
                          DCD      0x40004400
                  |L10.404|
                          DCD      0x40004800

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;63     
;;;64     int main(void)
000000  f7fffffe          BL       NVIC_Configuration
;;;65     {
;;;66     	NVIC_Configuration();
;;;67     	delay_init();
000004  f7fffffe          BL       delay_init
;;;68     	delay_ms(500);
000008  f44f75fa          MOV      r5,#0x1f4
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       delay_ms
;;;69     	RTD_init();
000012  f7fffffe          BL       RTD_init
;;;70     	stm32ads1115_1_init();
000016  f7fffffe          BL       stm32ads1115_1_init
;;;71     	DAC8554_GPIO_Config();
00001a  f7fffffe          BL       DAC8554_GPIO_Config
;;;72     	MuxGpioCfg();
00001e  f7fffffe          BL       MuxGpioCfg
;;;73     	DioCfg();
000022  f7fffffe          BL       DioCfg
;;;74     	UART_Configuration();
000026  f7fffffe          BL       UART_Configuration
;;;75     	LedInit();
00002a  f7fffffe          BL       LedInit
;;;76     	TIM2_Int_Init(20,7199); //定时器初始化为5ms中断一次
00002e  f641411f          MOV      r1,#0x1c1f
000032  2014              MOVS     r0,#0x14
000034  f7fffffe          BL       TIM2_Int_Init
;;;77     	
;;;78     	PWM1_Init(100);                     //设置PWM1输出周期100*100us           
000038  2064              MOVS     r0,#0x64
00003a  f7fffffe          BL       PWM1_Init
;;;79     	PWM1_SetHighTime(70);               //设置PWM1输出高电平时间为70*100us 
00003e  2046              MOVS     r0,#0x46
000040  f7fffffe          BL       PWM1_SetHighTime
;;;80     	
;;;81     	PWM2_Init(100);                     //设置PWM2输出周期100*100us  
000044  2064              MOVS     r0,#0x64
000046  f7fffffe          BL       PWM2_Init
;;;82     	PWM2_SetHighTime(30);               //设置PWM2输出高电平时间为30*100us 
00004a  201e              MOVS     r0,#0x1e
00004c  f7fffffe          BL       PWM2_SetHighTime
000050  2600              MOVS     r6,#0
;;;83     	
;;;84     
;;;85     
;;;86     	while (1)
;;;87     	{	
;;;88     		delay_ms(500);
;;;89     	
;;;90     		LED=0;
000052  4c08              LDR      r4,|L11.116|
;;;91     		//R485Test();              //485电路测试 应该在硬件上将两路485连到一起
;;;92     		AdDaTest();              //AD和DA 测试
;;;93     		DioTest();               //Di和继电器测试
;;;94     		RtdTest();               //RTD模块测试
;;;95     	  LED=1;
000054  2701              MOVS     r7,#1
                  |L11.86|
000056  4628              MOV      r0,r5                 ;88
000058  f7fffffe          BL       delay_ms
00005c  f8c461a4          STR      r6,[r4,#0x1a4]        ;90
000060  f7fffffe          BL       AdDaTest
000064  f7fffffe          BL       DioTest
000068  f7fffffe          BL       RtdTest
00006c  f8c471a4          STR      r7,[r4,#0x1a4]
000070  e7f1              B        |L11.86|
;;;96     		
;;;97     
;;;98     	}
;;;99     }
;;;100    void R485Test(void)
                          ENDP

000072  0000              DCW      0x0000
                  |L11.116|
                          DCD      0x42218000

                          AREA ||i.printfFloat||, CODE, READONLY, ALIGN=2

                  printfFloat PROC
;;;231    }
;;;232    void printfFloat(float Dat)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;233    {		
;;;234    	int64_t  temp1,temp2;
;;;235    	u8 Sflag;
;;;236    	if(Dat<0)
;;;237    	{
;;;238    		temp1=((int64_t)(-Dat))%100000;
000004  4d66              LDR      r5,|L12.416|
;;;239    		temp2=((int64_t)((-Dat)*100000.0))%100000;
000006  4e67              LDR      r6,|L12.420|
000008  4604              MOV      r4,r0                 ;233
00000a  f1104fff          CMN      r0,#0x7f800000        ;236
00000e  d31b              BCC      |L12.72|
000010  f0804400          EOR      r4,r0,#0x80000000     ;238
000014  4620              MOV      r0,r4                 ;238
000016  f7fffffe          BL       __aeabi_f2lz
00001a  462a              MOV      r2,r5                 ;238
00001c  2300              MOVS     r3,#0                 ;238
00001e  f7fffffe          BL       __aeabi_ldivmod
000022  4617              MOV      r7,r2                 ;238
000024  4698              MOV      r8,r3                 ;238
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       __aeabi_f2d
00002c  2200              MOVS     r2,#0
00002e  4633              MOV      r3,r6
000030  f7fffffe          BL       __aeabi_dmul
000034  f7fffffe          BL       __aeabi_d2lz
000038  462a              MOV      r2,r5
00003a  2300              MOVS     r3,#0
00003c  f7fffffe          BL       __aeabi_ldivmod
000040  4615              MOV      r5,r2
000042  461e              MOV      r6,r3
;;;240    		Sflag='-';
000044  202d              MOVS     r0,#0x2d
000046  e017              B        |L12.120|
                  |L12.72|
;;;241    	}
;;;242    	else
;;;243    	{
;;;244    		temp1=((int64_t)(Dat))%100000;
000048  f7fffffe          BL       __aeabi_f2lz
00004c  462a              MOV      r2,r5
00004e  2300              MOVS     r3,#0
000050  f7fffffe          BL       __aeabi_ldivmod
000054  4617              MOV      r7,r2
000056  4698              MOV      r8,r3
;;;245    		temp2=((int64_t)((Dat)*100000.0))%100000;
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       __aeabi_f2d
00005e  2200              MOVS     r2,#0
000060  4633              MOV      r3,r6
000062  f7fffffe          BL       __aeabi_dmul
000066  f7fffffe          BL       __aeabi_d2lz
00006a  462a              MOV      r2,r5
00006c  2300              MOVS     r3,#0
00006e  f7fffffe          BL       __aeabi_ldivmod
000072  4615              MOV      r5,r2
000074  461e              MOV      r6,r3
;;;246    		Sflag='+';
000076  202b              MOVS     r0,#0x2b
                  |L12.120|
;;;247    	}
;;;248    	Uart3_SendBuffSize=12;
000078  4a4b              LDR      r2,|L12.424|
00007a  210c              MOVS     r1,#0xc
;;;249    	Uart3_Send_buffer[0]=Sflag;
00007c  4c4b              LDR      r4,|L12.428|
00007e  7011              STRB     r1,[r2,#0]            ;248
;;;250    	Uart3_Send_buffer[1]=temp1/10000+'0';
000080  f2427910          MOV      r9,#0x2710
000084  7020              STRB     r0,[r4,#0]            ;249
000086  464a              MOV      r2,r9
000088  2300              MOVS     r3,#0
00008a  4638              MOV      r0,r7
00008c  4641              MOV      r1,r8
00008e  f7fffffe          BL       __aeabi_ldivmod
000092  3030              ADDS     r0,r0,#0x30
000094  7060              STRB     r0,[r4,#1]
;;;251    	Uart3_Send_buffer[2]=temp1%10000/1000+'0';
000096  4610              MOV      r0,r2
000098  4619              MOV      r1,r3
00009a  f44f7a7a          MOV      r10,#0x3e8
00009e  4652              MOV      r2,r10
0000a0  f04f0300          MOV      r3,#0
0000a4  f7fffffe          BL       __aeabi_ldivmod
0000a8  3030              ADDS     r0,r0,#0x30
0000aa  70a0              STRB     r0,[r4,#2]
;;;252    	Uart3_Send_buffer[3]=temp1%1000/100+'0';
0000ac  4652              MOV      r2,r10
0000ae  f04f0300          MOV      r3,#0
0000b2  4638              MOV      r0,r7
0000b4  4641              MOV      r1,r8
0000b6  f7fffffe          BL       __aeabi_ldivmod
0000ba  4610              MOV      r0,r2
0000bc  4619              MOV      r1,r3
0000be  2264              MOVS     r2,#0x64
0000c0  2300              MOVS     r3,#0
0000c2  f7fffffe          BL       __aeabi_ldivmod
0000c6  3030              ADDS     r0,r0,#0x30
0000c8  70e0              STRB     r0,[r4,#3]
;;;253    	Uart3_Send_buffer[4]=temp1%100/10+'0';
0000ca  f04f0264          MOV      r2,#0x64
0000ce  f04f0300          MOV      r3,#0
0000d2  4638              MOV      r0,r7
0000d4  4641              MOV      r1,r8
0000d6  f7fffffe          BL       __aeabi_ldivmod
0000da  4610              MOV      r0,r2
0000dc  4619              MOV      r1,r3
0000de  220a              MOVS     r2,#0xa
0000e0  2300              MOVS     r3,#0
0000e2  f7fffffe          BL       __aeabi_ldivmod
0000e6  3030              ADDS     r0,r0,#0x30
0000e8  7120              STRB     r0,[r4,#4]
;;;254      Uart3_Send_buffer[5]=temp1%10+'0';
0000ea  f04f020a          MOV      r2,#0xa
0000ee  f04f0300          MOV      r3,#0
0000f2  4638              MOV      r0,r7
0000f4  4641              MOV      r1,r8
0000f6  f7fffffe          BL       __aeabi_ldivmod
0000fa  2030              MOVS     r0,#0x30
0000fc  1810              ADDS     r0,r2,r0
0000fe  7160              STRB     r0,[r4,#5]
;;;255    	Uart3_Send_buffer[6]='.';
000100  f04f002e          MOV      r0,#0x2e
000104  71a0              STRB     r0,[r4,#6]
;;;256    	Uart3_Send_buffer[7]=temp2/10000+'0';
000106  464a              MOV      r2,r9
000108  f04f0300          MOV      r3,#0
00010c  4628              MOV      r0,r5
00010e  4631              MOV      r1,r6
000110  f7fffffe          BL       __aeabi_ldivmod
000114  3030              ADDS     r0,r0,#0x30
000116  71e0              STRB     r0,[r4,#7]
;;;257    	Uart3_Send_buffer[8]=temp2%10000/1000+'0';
000118  4610              MOV      r0,r2
00011a  4619              MOV      r1,r3
00011c  4652              MOV      r2,r10
00011e  f04f0300          MOV      r3,#0
000122  f7fffffe          BL       __aeabi_ldivmod
000126  3030              ADDS     r0,r0,#0x30
000128  7220              STRB     r0,[r4,#8]
;;;258    	Uart3_Send_buffer[9]=temp2%1000/100+'0';
00012a  4652              MOV      r2,r10
00012c  f04f0300          MOV      r3,#0
000130  4628              MOV      r0,r5
000132  4631              MOV      r1,r6
000134  f7fffffe          BL       __aeabi_ldivmod
000138  4610              MOV      r0,r2
00013a  4619              MOV      r1,r3
00013c  2264              MOVS     r2,#0x64
00013e  2300              MOVS     r3,#0
000140  f7fffffe          BL       __aeabi_ldivmod
000144  3030              ADDS     r0,r0,#0x30
000146  7260              STRB     r0,[r4,#9]
;;;259    	Uart3_Send_buffer[10]=temp2%100/10+'0';
000148  f04f0264          MOV      r2,#0x64
00014c  f04f0300          MOV      r3,#0
000150  4628              MOV      r0,r5
000152  4631              MOV      r1,r6
000154  f7fffffe          BL       __aeabi_ldivmod
000158  4610              MOV      r0,r2
00015a  4619              MOV      r1,r3
00015c  220a              MOVS     r2,#0xa
00015e  2300              MOVS     r3,#0
000160  f7fffffe          BL       __aeabi_ldivmod
000164  3030              ADDS     r0,r0,#0x30
000166  72a0              STRB     r0,[r4,#0xa]
;;;260      Uart3_Send_buffer[11]=temp2%10+'0';
000168  f04f020a          MOV      r2,#0xa
00016c  f04f0300          MOV      r3,#0
000170  4628              MOV      r0,r5
000172  4631              MOV      r1,r6
000174  f7fffffe          BL       __aeabi_ldivmod
000178  2030              MOVS     r0,#0x30
00017a  1810              ADDS     r0,r2,r0
;;;261    	Uart3_SCnt=0;
00017c  490c              LDR      r1,|L12.432|
00017e  72e0              STRB     r0,[r4,#0xb]          ;260
000180  f04f0000          MOV      r0,#0
000184  7008              STRB     r0,[r1,#0]
;;;262    	USART_ITConfig(USART3,USART_IT_TXE,ENABLE);			  	//
000186  f04f0201          MOV      r2,#1
00018a  f2407127          MOV      r1,#0x727
00018e  4809              LDR      r0,|L12.436|
000190  f7fffffe          BL       USART_ITConfig
;;;263    	delay_ms(2);
000194  e8bd47f0          POP      {r4-r10,lr}
000198  2002              MOVS     r0,#2
00019a  f7ffbffe          B.W      delay_ms
;;;264    			
;;;265    }
;;;266    void printfStr(char *str)
                          ENDP

00019e  0000              DCW      0x0000
                  |L12.416|
                          DCD      0x000186a0
                  |L12.420|
                          DCD      0x40f86a00
                  |L12.424|
                          DCD      Uart3_SendBuffSize
                  |L12.428|
                          DCD      Uart3_Send_buffer
                  |L12.432|
                          DCD      Uart3_SCnt
                  |L12.436|
                          DCD      0x40004800

                          AREA ||i.printfStr||, CODE, READONLY, ALIGN=2

                  printfStr PROC
;;;265    }
;;;266    void printfStr(char *str)
000000  b430              PUSH     {r4,r5}
;;;267    {		
;;;268    	Uart3_SendBuffSize=0;
000002  4a0b              LDR      r2,|L13.48|
000004  2300              MOVS     r3,#0
;;;269    	while(*str!=0x00)
;;;270    	{
;;;271    		Uart3_Send_buffer[Uart3_SendBuffSize++]=*str;
000006  4d0b              LDR      r5,|L13.52|
000008  7013              STRB     r3,[r2,#0]            ;268
00000a  e004              B        |L13.22|
                  |L13.12|
00000c  7811              LDRB     r1,[r2,#0]  ; Uart3_SendBuffSize
00000e  546c              STRB     r4,[r5,r1]
000010  1c49              ADDS     r1,r1,#1
000012  7011              STRB     r1,[r2,#0]
000014  1c40              ADDS     r0,r0,#1
                  |L13.22|
000016  7804              LDRB     r4,[r0,#0]            ;269
000018  2c00              CMP      r4,#0                 ;269
00001a  d1f7              BNE      |L13.12|
;;;272    		str++;
;;;273    	}
;;;274    	Uart3_SCnt=0;
00001c  4806              LDR      r0,|L13.56|
;;;275    	USART_ITConfig(USART3,USART_IT_TXE,ENABLE);			  	//
00001e  2201              MOVS     r2,#1
000020  f2407127          MOV      r1,#0x727
000024  7003              STRB     r3,[r0,#0]            ;274
000026  bc30              POP      {r4,r5}
000028  4804              LDR      r0,|L13.60|
00002a  f7ffbffe          B.W      USART_ITConfig
;;;276    			
;;;277    }
;;;278    void SendStr4851(char *str)
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      Uart3_SendBuffSize
                  |L13.52|
                          DCD      Uart3_Send_buffer
                  |L13.56|
                          DCD      Uart3_SCnt
                  |L13.60|
                          DCD      0x40004800

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  0d0a0d0a          DCB      "\r\n\r\n***************************RTD TEST************"
000004  2a2a2a2a
000008  2a2a2a2a
00000c  2a2a2a2a
000010  2a2a2a2a
000014  2a2a2a2a
000018  2a2a2a2a
00001c  2a2a2a52
000020  54442054
000024  4553542a
000028  2a2a2a2a
00002c  2a2a2a2a
000030  2a2a2a  
000033  2a2a2a2a          DCB      "******************\r\n",0
000037  2a2a2a2a
00003b  2a2a2a2a
00003f  2a2a2a2a
000043  2a2a0d0a
000047  00      
000048  0d0a0d0a          DCB      "\r\n\r\n***************************DIO TEST************"
00004c  2a2a2a2a
000050  2a2a2a2a
000054  2a2a2a2a
000058  2a2a2a2a
00005c  2a2a2a2a
000060  2a2a2a2a
000064  2a2a2a44
000068  494f2054
00006c  4553542a
000070  2a2a2a2a
000074  2a2a2a2a
000078  2a2a2a  
00007b  2a2a2a2a          DCB      "******************\r\n",0
00007f  2a2a2a2a
000083  2a2a2a2a
000087  2a2a2a2a
00008b  2a2a0d0a
00008f  00      
000090  0d0a0d0a          DCB      "\r\n\r\n***************************AD ch1-ch12 TEST****"
000094  2a2a2a2a
000098  2a2a2a2a
00009c  2a2a2a2a
0000a0  2a2a2a2a
0000a4  2a2a2a2a
0000a8  2a2a2a2a
0000ac  2a2a2a41
0000b0  44206368
0000b4  312d6368
0000b8  31322054
0000bc  4553542a
0000c0  2a2a2a  
0000c3  2a2a2a2a          DCB      "**************************",0
0000c7  2a2a2a2a
0000cb  2a2a2a2a
0000cf  2a2a2a2a
0000d3  2a2a2a2a
0000d7  2a2a2a2a
0000db  2a2a00  
0000de  00                DCB      0
0000df  00                DCB      0
0000e0  0d0a0d0a          DCB      "\r\n\r\n***************************RS4885 TEST*********"
0000e4  2a2a2a2a
0000e8  2a2a2a2a
0000ec  2a2a2a2a
0000f0  2a2a2a2a
0000f4  2a2a2a2a
0000f8  2a2a2a2a
0000fc  2a2a2a52
000100  53343838
000104  35205445
000108  53542a2a
00010c  2a2a2a2a
000110  2a2a2a  
000113  2a2a2a2a          DCB      "*********************\r\n",0
000117  2a2a2a2a
00011b  2a2a2a2a
00011f  2a2a2a2a
000123  2a2a2a2a
000127  2a0d0a00

                          AREA ||.data||, DATA, ALIGN=0

                  count
000000  00                DCB      0x00

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  count1
                          DCD      0x000000ff

                          AREA ||area_number.19||, DATA, ALIGN=1

                          EXPORTAS ||area_number.19||, ||.data||
                  GPIO_InitStructure
                          DCDU     0x00000000

                          AREA ||area_number.20||, DATA, ALIGN=0

                          EXPORTAS ||area_number.20||, ||.data||
                  HSEStartUpStatus
000000  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
