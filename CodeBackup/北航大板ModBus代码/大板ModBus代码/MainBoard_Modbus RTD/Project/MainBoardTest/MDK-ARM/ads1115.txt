; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\ads1115.o --asm_dir=.\ --list_dir=.\ --depend=.\ads1115.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I.\RTE\_MainBoardForRTD -I"D:\software install\Keil\ARM\CMSIS\5.1.0\CMSIS\Include" -I"D:\software install\Keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\ads1115.crf ..\ADS1115.c]
                          THUMB

                          AREA ||i.AD_init||, CODE, READONLY, ALIGN=2

                  AD_init PROC
;;;30     //---------------------------------------------------------//
;;;31     void AD_init(unsigned char id,unsigned char write_address,unsigned char byte1,unsigned char byte2)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;32     {
000004  461d              MOV      r5,r3
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
00000a  4604              MOV      r4,r0
;;;33     	__disable_irq();   // 关闭总中断
00000c  b672              CPSID    i
;;;34     	IIC_Start();
00000e  f7fffffe          BL       IIC_Start
;;;35     	//产生起始条件
;;;36     	IIC_Send_Byte(id);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       IIC_Send_Byte
                  |L1.24|
;;;37     	//向设备发送设备地址
;;;38     	while( IIC_Wait_Ack());
000018  f7fffffe          BL       IIC_Wait_Ack
00001c  2800              CMP      r0,#0
00001e  d1fb              BNE      |L1.24|
;;;39     	//等待ACK
;;;40     	IIC_Send_Byte(write_address) ;//配置寄存器
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       IIC_Send_Byte
;;;41     	//寄存器地址
;;;42     	while( IIC_Wait_Ack());
000026  bf00              NOP      
                  |L1.40|
000028  f7fffffe          BL       IIC_Wait_Ack
00002c  2800              CMP      r0,#0
00002e  d1fb              BNE      |L1.40|
;;;43     	delay_us(4);
000030  2004              MOVS     r0,#4
000032  f7fffffe          BL       delay_us
;;;44     	//等待ACK
;;;45     	IIC_Send_Byte(byte1) ;//c-an0 d-an1 e-an2 f-an3  0->6.144 2->4.096,高字节配置
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       IIC_Send_Byte
                  |L1.60|
;;;46     	//发送数据
;;;47     	while(IIC_Wait_Ack());
00003c  f7fffffe          BL       IIC_Wait_Ack
000040  2800              CMP      r0,#0
000042  d1fb              BNE      |L1.60|
;;;48     	//发送完成
;;;49     	IIC_Send_Byte(byte2);//低字节 最高转换速度
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       IIC_Send_Byte
;;;50     	while(IIC_Wait_Ack());
00004a  bf00              NOP      
                  |L1.76|
00004c  f7fffffe          BL       IIC_Wait_Ack
000050  2800              CMP      r0,#0
000052  d1fb              BNE      |L1.76|
;;;51     	//发送完成
;;;52     	IIC_Stop();
000054  f7fffffe          BL       IIC_Stop
;;;53     	//产生结束信号
;;;54     	__enable_irq();    // 开启总中断
000058  b662              CPSIE    i
;;;55     }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;56     //----------------------------------------------------//
                          ENDP


                          AREA ||i.I2C_ADpoint||, CODE, READONLY, ALIGN=2

                  I2C_ADpoint PROC
;;;56     //----------------------------------------------------//
;;;57     void I2C_ADpoint(unsigned char id,unsigned char write_address)
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;59     	__disable_irq();   // 关闭总中断
000006  b672              CPSID    i
;;;60     	IIC_Start();
000008  f7fffffe          BL       IIC_Start
;;;61     	//产生起始条件
;;;62     	IIC_Send_Byte(id);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       IIC_Send_Byte
;;;63     	//向设备发送设备地址
;;;64     	while(IIC_Wait_Ack());
000012  bf00              NOP      
                  |L2.20|
000014  f7fffffe          BL       IIC_Wait_Ack
000018  2800              CMP      r0,#0
00001a  d1fb              BNE      |L2.20|
;;;65     	//等待ACK
;;;66     	IIC_Send_Byte(write_address);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       IIC_Send_Byte
;;;67     	//寄存器地址
;;;68     	while(IIC_Wait_Ack());
000022  bf00              NOP      
                  |L2.36|
000024  f7fffffe          BL       IIC_Wait_Ack
000028  2800              CMP      r0,#0
00002a  d1fb              BNE      |L2.36|
;;;69     
;;;70     	IIC_Stop();
00002c  f7fffffe          BL       IIC_Stop
;;;71     	//产生结束信号
;;;72     	__enable_irq();    // 开启总中断
000030  b662              CPSIE    i
;;;73     }
000032  bd70              POP      {r4-r6,pc}
;;;74     
                          ENDP


                          AREA ||i.I2C_Read2||, CODE, READONLY, ALIGN=2

                  I2C_Read2 PROC
;;;123    //----------------------------------------------------------//
;;;124    void I2C_Read2(unsigned char  id, unsigned char read_address)
000000  b510              PUSH     {r4,lr}
;;;125    {  
000002  4604              MOV      r4,r0
;;;126    	__disable_irq();   // 关闭总中断
000004  b672              CPSID    i
;;;127      	IIC_Start();
000006  f7fffffe          BL       IIC_Start
;;;128      	//产生起始信号
;;;129      	IIC_Send_Byte(id);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       IIC_Send_Byte
                  |L3.16|
;;;130    	//发送地址
;;;131      	while(IIC_Wait_Ack());
000010  f7fffffe          BL       IIC_Wait_Ack
000014  2800              CMP      r0,#0
000016  d1fb              BNE      |L3.16|
;;;132    	//等待ACK
;;;133      	//IIC_Send_Byte(read_address);
;;;134    	//发送读得地址
;;;135      	//while(IIC_Wait_Ack());
;;;136    	
;;;137      	 BUF[1] = IIC_Read_Byte(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       IIC_Read_Byte
00001e  4c06              LDR      r4,|L3.56|
000020  7060              STRB     r0,[r4,#1]
;;;138    	//重新发送
;;;139      	delay_us(5);
000022  2005              MOVS     r0,#5
000024  f7fffffe          BL       delay_us
;;;140    	BUF[2] = IIC_Read_Byte(1);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       IIC_Read_Byte
00002e  70a0              STRB     r0,[r4,#2]
;;;141    	IIC_Stop();
000030  f7fffffe          BL       IIC_Stop
;;;142    		
;;;143        __enable_irq();    // 开启总中断
000034  b662              CPSIE    i
;;;144    		
;;;145    }
000036  bd10              POP      {r4,pc}
;;;146    float ReadAdOfChannel(unsigned char  Channel,unsigned char CurrentFlag)
                          ENDP

                  |L3.56|
                          DCD      ||.data||+0x10

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=2

                  I2C_ReadByte PROC
;;;82     
;;;83     unsigned char I2C_ReadByte(unsigned char  id, unsigned char read_address)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {  
;;;85     	unsigned char temp; 	
;;;86     
;;;87     	while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));
000004  4c31              LDR      r4,|L4.204|
000006  4688              MOV      r8,r1                 ;84
000008  4606              MOV      r6,r0                 ;84
00000a  f44f3500          MOV      r5,#0x20000
                  |L4.14|
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2C_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d1f9              BNE      |L4.14|
;;;88       	//等待I2C
;;;89       	I2C_GenerateSTART(I2C1, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       I2C_GenerateSTART
;;;90       	//产生起始信号
;;;91       	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
000022  4d2b              LDR      r5,|L4.208|
                  |L4.36|
000024  4620              MOV      r0,r4
000026  4629              MOV      r1,r5
000028  f7fffffe          BL       I2C_CheckEvent
00002c  2800              CMP      r0,#0
00002e  d0f9              BEQ      |L4.36|
;;;92         //EV5
;;;93       	I2C_Send7bitAddress(I2C1, id, I2C_Direction_Transmitter);
000030  2200              MOVS     r2,#0
000032  4631              MOV      r1,r6
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_Send7bitAddress
;;;94     	//发送地址
;;;95       	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
00003a  4f26              LDR      r7,|L4.212|
                  |L4.60|
00003c  4620              MOV      r0,r4
00003e  4639              MOV      r1,r7
000040  f7fffffe          BL       I2C_CheckEvent
000044  2800              CMP      r0,#0
000046  d0f9              BEQ      |L4.60|
;;;96       	//EV6
;;;97       	I2C_Cmd(I2C1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_Cmd
;;;98      	//重新设置可以清楚EV6
;;;99       	I2C_SendData(I2C1, read_address);  
000050  4641              MOV      r1,r8
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       I2C_SendData
;;;100    	//发送读地址
;;;101      	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
000058  4f1e              LDR      r7,|L4.212|
00005a  1cbf              ADDS     r7,r7,#2
                  |L4.92|
00005c  4639              MOV      r1,r7
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       I2C_CheckEvent
000064  2800              CMP      r0,#0
000066  d0f9              BEQ      |L4.92|
;;;102      	//EV8 
;;;103      	I2C_GenerateSTART(I2C1, ENABLE);
000068  2101              MOVS     r1,#1
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       I2C_GenerateSTART
                  |L4.112|
;;;104    	//重新发送
;;;105      	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
000070  4629              MOV      r1,r5
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       I2C_CheckEvent
000078  2800              CMP      r0,#0
00007a  d0f9              BEQ      |L4.112|
;;;106      	//EV5
;;;107      	I2C_Send7bitAddress(I2C1, id, I2C_Direction_Receiver);
00007c  2201              MOVS     r2,#1
00007e  4631              MOV      r1,r6
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       I2C_Send7bitAddress
;;;108      	//发送读地址
;;;109      	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
000086  4d12              LDR      r5,|L4.208|
000088  1c6d              ADDS     r5,r5,#1
                  |L4.138|
00008a  4629              MOV      r1,r5
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       I2C_CheckEvent
000092  2800              CMP      r0,#0
000094  d0f9              BEQ      |L4.138|
;;;110      	//EV6  
;;;111        I2C_AcknowledgeConfig(I2C1, DISABLE);
000096  2100              MOVS     r1,#0
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       I2C_AcknowledgeConfig
;;;112        I2C_GenerateSTOP(I2C1, ENABLE);
00009e  2101              MOVS     r1,#1
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       I2C_GenerateSTOP
;;;113    	//关闭应答和停止条件产生
;;;114        while(!(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)));
0000a6  4d0a              LDR      r5,|L4.208|
0000a8  353f              ADDS     r5,r5,#0x3f
                  |L4.170|
0000aa  4629              MOV      r1,r5
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       I2C_CheckEvent
0000b2  2800              CMP      r0,#0
0000b4  d0f9              BEQ      |L4.170|
;;;115    	      
;;;116        temp = I2C_ReceiveData(I2C1);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       I2C_ReceiveData
0000bc  4605              MOV      r5,r0
;;;117       
;;;118      	I2C_AcknowledgeConfig(I2C1, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       I2C_AcknowledgeConfig
;;;119    		
;;;120        return temp;
0000c6  4628              MOV      r0,r5
;;;121    }
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;122    
                          ENDP

                  |L4.204|
                          DCD      0x40005400
                  |L4.208|
                          DCD      0x00030001
                  |L4.212|
                          DCD      0x00070082

                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=2

                  I2C_WriteByte PROC
;;;10     
;;;11     void I2C_WriteByte(unsigned char id,unsigned char write_address,unsigned char byte)
000000  b570              PUSH     {r4-r6,lr}
;;;12     {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;13     	IIC_Start();
000008  f7fffffe          BL       IIC_Start
;;;14     	//产生起始条件
;;;15     	IIC_Send_Byte(id);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       IIC_Send_Byte
;;;16     	//向设备发送设备地址
;;;17     	while(IIC_Wait_Ack());
000012  bf00              NOP      
                  |L5.20|
000014  f7fffffe          BL       IIC_Wait_Ack
000018  2800              CMP      r0,#0
00001a  d1fb              BNE      |L5.20|
;;;18     	//等待ACK
;;;19     	IIC_Send_Byte(write_address);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       IIC_Send_Byte
;;;20     	//寄存器地址
;;;21     	while(IIC_Wait_Ack());
000022  bf00              NOP      
                  |L5.36|
000024  f7fffffe          BL       IIC_Wait_Ack
000028  2800              CMP      r0,#0
00002a  d1fb              BNE      |L5.36|
;;;22     	//等待ACK
;;;23     	IIC_Send_Byte(byte);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       IIC_Send_Byte
;;;24     	//发送数据
;;;25     	while(IIC_Wait_Ack());
000032  bf00              NOP      
                  |L5.52|
000034  f7fffffe          BL       IIC_Wait_Ack
000038  2800              CMP      r0,#0
00003a  d1fb              BNE      |L5.52|
;;;26     	//发送完成
;;;27     	IIC_Stop();
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f7ffbffe          B.W      IIC_Stop
;;;28     	//产生结束信号
;;;29     }
;;;30     //---------------------------------------------------------//
                          ENDP


                          AREA ||i.ReadAdOfChannel||, CODE, READONLY, ALIGN=2

                  ReadAdOfChannel PROC
;;;145    }
;;;146    float ReadAdOfChannel(unsigned char  Channel,unsigned char CurrentFlag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
000004  000f              MOVS     r7,r1
;;;148    	float resaultVoltageOrCurrent=0;
000006  f04f0600          MOV      r6,#0
;;;149    	
;;;150    	
;;;151    	int16_t CigH=0xc2;
00000a  f04f02c2          MOV      r2,#0xc2
00000e  d100              BNE      |L6.18|
;;;152    	switch(CurrentFlag)
;;;153    	{
;;;154    		case 0:CigH=0xce;break;  //FS=+-0.256
000010  22ce              MOVS     r2,#0xce
                  |L6.18|
;;;155    		case 1:CigH=0xc2;break;  //FS=+-4.096
;;;156    		default:break;
;;;157    	}
;;;158    
;;;159    	switch(Channel)
;;;160    	{
;;;161    		case 1:AD_init(0x90,0x01,CigH|0x00,0xe2);
;;;162    		       delay_ms(2);
;;;163    					 I2C_ADpoint(0x90,0x00);
;;;164    					 delay_ms(2);
;;;165    		       I2C_Read2(0x91,0x00);
;;;166    		       resault = (BUF[1] << 8) | BUF[2];
000012  4d44              LDR      r5,|L6.292|
000014  280d              CMP      r0,#0xd               ;159
000016  f1a50410          SUB      r4,r5,#0x10
00001a  d229              BCS      |L6.112|
00001c  e8dff000          TBB      [pc,r0]               ;159
000020  2807191c          DCB      0x28,0x07,0x19,0x1c
000024  1f352d30          DCB      0x1f,0x35,0x2d,0x30
000028  334f474a          DCB      0x33,0x4f,0x47,0x4a
00002c  4d00              DCB      0x4d,0x00
                  |L6.46|
00002e  23e2              MOVS     r3,#0xe2              ;161
000030  2101              MOVS     r1,#1                 ;161
000032  2090              MOVS     r0,#0x90              ;161
000034  f7fffffe          BL       AD_init
000038  2002              MOVS     r0,#2                 ;162
00003a  f7fffffe          BL       delay_ms
00003e  2100              MOVS     r1,#0                 ;163
000040  2090              MOVS     r0,#0x90              ;163
000042  f7fffffe          BL       I2C_ADpoint
000046  2002              MOVS     r0,#2                 ;164
000048  f7fffffe          BL       delay_ms
00004c  2100              MOVS     r1,#0                 ;165
00004e  2091              MOVS     r0,#0x91              ;165
;;;167    					 break;
000050  e008              B        |L6.100|
;;;168    		case 2:AD_init(0x90,0x01,CigH|0x10,0xe2);
000052  f0420210          ORR      r2,r2,#0x10
;;;169    		       delay_ms(2);
;;;170    					 I2C_ADpoint(0x90,0x00);
;;;171    					 delay_ms(2);
;;;172    		       I2C_Read2(0x91,0x00);
;;;173    		       resault = (BUF[1] << 8) | BUF[2];
;;;174    					 break;
000056  e7ea              B        |L6.46|
;;;175    		case 3:AD_init(0x90,0x01,CigH|0x20,0xe2);
000058  f0420220          ORR      r2,r2,#0x20
;;;176    		       delay_ms(2);
;;;177    					 I2C_ADpoint(0x90,0x00);
;;;178    					 delay_ms(2);
;;;179    		       I2C_Read2(0x91,0x00);
;;;180    		       resault = (BUF[1] << 8) | BUF[2];
;;;181    					 break;
00005c  e7e7              B        |L6.46|
;;;182    	  case 4:AD_init(0x90,0x01,CigH|0x30,0xe2);
00005e  f0420230          ORR      r2,r2,#0x30
;;;183    		       delay_ms(2);
;;;184    					 I2C_ADpoint(0x90,0x00);
;;;185    					 delay_ms(2);
;;;186    		       I2C_Read2(0x91,0x00);
;;;187    		       resault = (BUF[1] << 8) | BUF[2];
;;;188    					 break;
000062  e7e4              B        |L6.46|
                  |L6.100|
000064  f7fffffe          BL       I2C_Read2
000068  f8b50001          LDRH     r0,[r5,#1]            ;166  ; BUF
00006c  ba40              REV16    r0,r0                 ;166
00006e  8020              STRH     r0,[r4,#0]            ;166
                  |L6.112|
;;;189    		case 5:AD_init(0x92,0x01,CigH|0x00,0xe2);
;;;190    		       delay_ms(2);
;;;191    					 I2C_ADpoint(0x92,0x00);
;;;192    					 delay_ms(2);
;;;193    		       I2C_Read2(0x93,0x00);
;;;194    		       resault = (BUF[1] << 8) | BUF[2];
;;;195    					 break;
;;;196    		case 6:AD_init(0x92,0x01,CigH|0x10,0xe2);
;;;197    		       delay_ms(2);
;;;198    					 I2C_ADpoint(0x92,0x00);
;;;199    					 delay_ms(2);
;;;200    		       I2C_Read2(0x93,0x00);
;;;201    		       resault = (BUF[1] << 8) | BUF[2];
;;;202    					 break;
;;;203    		case 7:AD_init(0x92,0x01,CigH|0x20,0xe2);
;;;204    		       delay_ms(2);
;;;205    					 I2C_ADpoint(0x92,0x00);
;;;206    					 delay_ms(2);
;;;207    		       I2C_Read2(0x93,0x00);
;;;208    		       resault = (BUF[1] << 8) | BUF[2];
;;;209    					 break;
;;;210    	  case 8:AD_init(0x92,0x01,CigH|0x30,0xe2);
;;;211    		       delay_ms(2);
;;;212    					 I2C_ADpoint(0x92,0x00);
;;;213    					 delay_ms(2);
;;;214    		       I2C_Read2(0x93,0x00);
;;;215    		       resault = (BUF[1] << 8) | BUF[2];
;;;216    					 break;
;;;217    		case 9:AD_init(0x94,0x01,CigH|0x00,0xe2);
;;;218    		       delay_ms(2);
;;;219    					 I2C_ADpoint(0x94,0x00);
;;;220    					 delay_ms(2);
;;;221    		       I2C_Read2(0x95,0x00);
;;;222    		       resault = (BUF[1] << 8) | BUF[2];
;;;223    					 break;
;;;224    		case 10:AD_init(0x94,0x01,CigH|0x10,0xe2);
;;;225    		       delay_ms(2);
;;;226    					 I2C_ADpoint(0x94,0x00);
;;;227    					 delay_ms(2);
;;;228    		       I2C_Read2(0x95,0x00);
;;;229    		       resault = (BUF[1] << 8) | BUF[2];
;;;230    					 break;
;;;231    		case 11:AD_init(0x94,0x01,CigH|0x20,0xe2);
;;;232    		       delay_ms(2);
;;;233    					 I2C_ADpoint(0x94,0x00);
;;;234    					 delay_ms(2);
;;;235    		       I2C_Read2(0x95,0x00);
;;;236    		       resault = (BUF[1] << 8) | BUF[2];
;;;237    					 break;
;;;238    	  case 12:AD_init(0x94,0x01,CigH|0x30,0xe2);
;;;239    		       delay_ms(2);
;;;240    					 I2C_ADpoint(0x94,0x00);
;;;241    					 delay_ms(2);
;;;242    		       I2C_Read2(0x95,0x00);
;;;243    		       resault = (BUF[1] << 8) | BUF[2];
;;;244    					 break;
;;;245    		default:break;
;;;246    	}
;;;247    	switch(CurrentFlag)
;;;248    	{ 
;;;249    		case 0: resaultVoltageOrCurrent=0.256*51*resault/32767.0;break;    //FS=+-0.256
000070  4d2d              LDR      r5,|L6.296|
000072  b3b7              CBZ      r7,|L6.226|
000074  2f01              CMP      r7,#1                 ;247
000076  d152              BNE      |L6.286|
000078  e03f              B        |L6.250|
00007a  f0420210          ORR      r2,r2,#0x10           ;196
00007e  e004              B        |L6.138|
000080  f0420220          ORR      r2,r2,#0x20           ;203
000084  e001              B        |L6.138|
000086  f0420230          ORR      r2,r2,#0x30           ;210
                  |L6.138|
00008a  23e2              MOVS     r3,#0xe2              ;210
00008c  2101              MOVS     r1,#1                 ;210
00008e  2092              MOVS     r0,#0x92              ;210
000090  f7fffffe          BL       AD_init
000094  2002              MOVS     r0,#2                 ;211
000096  f7fffffe          BL       delay_ms
00009a  2100              MOVS     r1,#0                 ;212
00009c  2092              MOVS     r0,#0x92              ;212
00009e  f7fffffe          BL       I2C_ADpoint
0000a2  2002              MOVS     r0,#2                 ;213
0000a4  f7fffffe          BL       delay_ms
0000a8  2100              MOVS     r1,#0                 ;214
0000aa  2093              MOVS     r0,#0x93              ;214
0000ac  e7da              B        |L6.100|
0000ae  f0420210          ORR      r2,r2,#0x10           ;224
0000b2  e004              B        |L6.190|
0000b4  f0420220          ORR      r2,r2,#0x20           ;231
0000b8  e001              B        |L6.190|
0000ba  f0420230          ORR      r2,r2,#0x30           ;238
                  |L6.190|
0000be  23e2              MOVS     r3,#0xe2              ;238
0000c0  2101              MOVS     r1,#1                 ;238
0000c2  2094              MOVS     r0,#0x94              ;238
0000c4  f7fffffe          BL       AD_init
0000c8  2002              MOVS     r0,#2                 ;239
0000ca  f7fffffe          BL       delay_ms
0000ce  2100              MOVS     r1,#0                 ;240
0000d0  2094              MOVS     r0,#0x94              ;240
0000d2  f7fffffe          BL       I2C_ADpoint
0000d6  2002              MOVS     r0,#2                 ;241
0000d8  f7fffffe          BL       delay_ms
0000dc  2100              MOVS     r1,#0                 ;242
0000de  2095              MOVS     r0,#0x95              ;242
0000e0  e7c0              B        |L6.100|
                  |L6.226|
0000e2  e7ff              B        |L6.228|
                  |L6.228|
0000e4  f9b40000          LDRSH    r0,[r4,#0]  ; resault
0000e8  f7fffffe          BL       __aeabi_i2d
0000ec  4a0f              LDR      r2,|L6.300|
0000ee  4b10              LDR      r3,|L6.304|
0000f0  f7fffffe          BL       __aeabi_dmul
0000f4  2200              MOVS     r2,#0
0000f6  462b              MOV      r3,r5
0000f8  e00c              B        |L6.276|
                  |L6.250|
;;;250    		case 1: resaultVoltageOrCurrent=4.096*1000*resault/32767.0/200.0;break;//FS=+-4.096
0000fa  f9b40000          LDRSH    r0,[r4,#0]  ; resault
0000fe  f7fffffe          BL       __aeabi_i2d
000102  220c              MOVS     r2,#0xc
000104  f7fffffe          BL       __ARM_scalbn
000108  2200              MOVS     r2,#0
00010a  462b              MOV      r3,r5
00010c  f7fffffe          BL       __aeabi_ddiv
000110  2200              MOVS     r2,#0
000112  4b08              LDR      r3,|L6.308|
                  |L6.276|
000114  f7fffffe          BL       __aeabi_ddiv
000118  f7fffffe          BL       __aeabi_d2f
00011c  4606              MOV      r6,r0                 ;249
                  |L6.286|
;;;251    		default:resaultVoltageOrCurrent=0;break;
;;;252    	}
;;;253    	return resaultVoltageOrCurrent;
00011e  4630              MOV      r0,r6
;;;254    }
000120  e8bd81f0          POP      {r4-r8,pc}
;;;255    //-----------------------------------------------//
                          ENDP

                  |L6.292|
                          DCD      ||.data||+0x10
                  |L6.296|
                          DCD      0x40dfffc0
                  |L6.300|
                          DCD      0x083126ea
                  |L6.304|
                          DCD      0x402a1cac
                  |L6.308|
                          DCD      0x40690000

                          AREA ||i.read_ADS1115_1||, CODE, READONLY, ALIGN=2

                  read_ADS1115_1 PROC
;;;255    //-----------------------------------------------//
;;;256    void read_ADS1115_1()
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;257    {
;;;258    	 /*******************************AD1***********************************************/
;;;259    	   AD_init(0x90,0x01,0xc2,0xe2);
000004  23e2              MOVS     r3,#0xe2
000006  22c2              MOVS     r2,#0xc2
000008  2101              MOVS     r1,#1
00000a  2090              MOVS     r0,#0x90
00000c  f7fffffe          BL       AD_init
;;;260    	   //器件地址90，配置寄存器01，寄存器高位，寄存器低位e2
;;;261    	   //高字节配置：c-an0 d-an1 e-an2 f-an3 ; 0->6.144 2->4.096 4->2.048
;;;262    	 delay_ms(1);	
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       delay_ms
;;;263    	   I2C_ADpoint(0x90,0x00);
000016  2100              MOVS     r1,#0
000018  2090              MOVS     r0,#0x90
00001a  f7fffffe          BL       I2C_ADpoint
;;;264         delay_ms(2);	
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       delay_ms
;;;265         I2C_Read2(0x91,0x00);
000024  2100              MOVS     r1,#0
000026  2091              MOVS     r0,#0x91
000028  f7fffffe          BL       I2C_Read2
;;;266    	 valu_stm32ads1115_1 = (BUF[1] << 8) | BUF[2]; 
00002c  4d30              LDR      r5,|L7.240|
;;;267    	 if(valu_stm32ads1115_1>32768)valu_stm32ads1115_1=valu_stm32ads1115_1-65536;
00002e  f44f4700          MOV      r7,#0x8000
000032  f1a50410          SUB      r4,r5,#0x10           ;266
000036  f8b50001          LDRH     r0,[r5,#1]            ;266  ; BUF
00003a  ba40              REV16    r0,r0                 ;266
00003c  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
00003e  42b8              CMP      r0,r7
000040  dd02              BLE      |L7.72|
000042  f5a03080          SUB      r0,r0,#0x10000
000046  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
                  |L7.72|
;;;268         s1 = ((float)valu_stm32ads1115_1/(float)0x7fff) *4.096*10.02/4.12;                //S1 AI1 通道电压值
000048  f7fffffe          BL       __aeabi_i2f
00004c  f8dfb0a4          LDR      r11,|L7.244|
000050  4659              MOV      r1,r11
000052  f7fffffe          BL       __aeabi_fdiv
000056  f7fffffe          BL       __aeabi_f2d
00005a  4e28              LDR      r6,|L7.252|
00005c  4a26              LDR      r2,|L7.248|
00005e  4633              MOV      r3,r6
000060  f7fffffe          BL       __aeabi_dmul
000064  f8df8098          LDR      r8,|L7.256|
000068  f8df9098          LDR      r9,|L7.260|
00006c  4642              MOV      r2,r8
00006e  464b              MOV      r3,r9
000070  f7fffffe          BL       __aeabi_dmul
000074  f8dfa090          LDR      r10,|L7.264|
000078  4b24              LDR      r3,|L7.268|
00007a  4652              MOV      r2,r10
00007c  f7fffffe          BL       __aeabi_ddiv
000080  f7fffffe          BL       __aeabi_d2f
;;;269        // if(valu_stm32ads1115_1>0x7fff)valu_stm32ads1115_1-=0xffff;	 
;;;270    	
;;;271    	/********************************AD2**********************************************/
;;;272    	AD_init(0x90,0x01,0xd2,0xe2);
000084  60a0              STR      r0,[r4,#8]  ; s1
000086  23e2              MOVS     r3,#0xe2
000088  22d2              MOVS     r2,#0xd2
00008a  2101              MOVS     r1,#1
00008c  2090              MOVS     r0,#0x90
00008e  f7fffffe          BL       AD_init
;;;273    	   //器件地址90，配置寄存器01，寄存器高位，寄存器低位e2
;;;274    	   //高字节配置：c-an0 d-an1 e-an2 f-an3 ; 0->6.144 2->4.096 4->2.048
;;;275    	 delay_ms(1);	
000092  2001              MOVS     r0,#1
000094  f7fffffe          BL       delay_ms
;;;276    	   I2C_ADpoint(0x90,0x00);
000098  2100              MOVS     r1,#0
00009a  2090              MOVS     r0,#0x90
00009c  f7fffffe          BL       I2C_ADpoint
;;;277         delay_ms(2);	
0000a0  2002              MOVS     r0,#2
0000a2  f7fffffe          BL       delay_ms
;;;278         I2C_Read2(0x91,0x00);
0000a6  2100              MOVS     r1,#0
0000a8  2091              MOVS     r0,#0x91
0000aa  f7fffffe          BL       I2C_Read2
;;;279    	 valu_stm32ads1115_1 = (BUF[1] << 8) | BUF[2]; 
0000ae  f8b50001          LDRH     r0,[r5,#1]  ; BUF
0000b2  ba40              REV16    r0,r0
;;;280    	 if(valu_stm32ads1115_1>32768)valu_stm32ads1115_1=valu_stm32ads1115_1-65536;
0000b4  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
0000b6  42b8              CMP      r0,r7
0000b8  dd02              BLE      |L7.192|
0000ba  f5a03080          SUB      r0,r0,#0x10000
0000be  6060              STR      r0,[r4,#4]  ; valu_stm32ads1115_1
                  |L7.192|
;;;281         s2 = ((float)valu_stm32ads1115_1/(float)0x7fff) *4.096*10.02/4.12;                 //S2 AI2 通道电压值
0000c0  f7fffffe          BL       __aeabi_i2f
0000c4  4659              MOV      r1,r11
0000c6  f7fffffe          BL       __aeabi_fdiv
0000ca  f7fffffe          BL       __aeabi_f2d
0000ce  4a0a              LDR      r2,|L7.248|
0000d0  4633              MOV      r3,r6
0000d2  f7fffffe          BL       __aeabi_dmul
0000d6  4642              MOV      r2,r8
0000d8  464b              MOV      r3,r9
0000da  f7fffffe          BL       __aeabi_dmul
0000de  4652              MOV      r2,r10
0000e0  4b0a              LDR      r3,|L7.268|
0000e2  f7fffffe          BL       __aeabi_ddiv
0000e6  f7fffffe          BL       __aeabi_d2f
0000ea  60e0              STR      r0,[r4,#0xc]  ; s2
;;;282        // if(valu_stm32ads1115_1>0x7fff)valu_stm32ads1115_1-=0xffff;	
;;;283    }
0000ec  e8bd9ff0          POP      {r4-r12,pc}
;;;284    
                          ENDP

                  |L7.240|
                          DCD      ||.data||+0x10
                  |L7.244|
                          DCD      0x46fffe00
                  |L7.248|
                          DCD      0xd2f1a9fc
                  |L7.252|
                          DCD      0x4010624d
                  |L7.256|
                          DCD      0x70a3d70a
                  |L7.260|
                          DCD      0x40240a3d
                  |L7.264|
                          DCD      0x47ae147b
                  |L7.268|
                          DCD      0x40107ae1

                          AREA ||i.stm32ads1115_1_init||, CODE, READONLY, ALIGN=1

                  stm32ads1115_1_init PROC
;;;284    
;;;285    void stm32ads1115_1_init(void)
000000  f7ffbffe          B.W      IIC_Init
;;;286    {
;;;287    	IIC_Init();
;;;288    }
;;;289    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  resault
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  valu_stm32ads1115_1
                          DCD      0x00000000
                  ||s1||
                          DCD      0x00000000
                  ||s2||
                          DCD      0x00000000
                  BUF
                          %        8
