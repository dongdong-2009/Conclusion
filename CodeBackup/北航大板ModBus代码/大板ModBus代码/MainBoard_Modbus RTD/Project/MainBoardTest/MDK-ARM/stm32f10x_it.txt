; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32f10x_it.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I.\RTE\_MainBoardForRTD -I"D:\software install\Keil\ARM\CMSIS\5.1.0\CMSIS\Include" -I"D:\software install\Keil\Keil\STM32F1xx_DFP\2.2.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm32f10x_it.crf ..\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
                  |L1.0|
;;;83       */
;;;84     void BusFault_Handler(void)
000000  e7fe              B        |L1.0|
;;;85     {
;;;86       /* Go to infinite loop when Bus Fault exception occurs */
;;;87       while (1)
;;;88       {
;;;89       }
;;;90     }
;;;91     
                          ENDP


                          AREA ||i.DealModBus||, CODE, READONLY, ALIGN=2

                  DealModBus PROC
;;;269    
;;;270    void DealModBus(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;271    {
;;;272    	
;;;273    	u16 REG0X03[24];//功能吗0x03对应的寄存器地址为0x0001-0x00019  AD12路+RTD4路+DI8路=24
;;;274    	u16 REG0X06[16];//功能吗0x06对应的寄存器地址为0x0001-0x00010  DA8路+DO8路=16
;;;275    	u16 DatLength=0;
;;;276    	u16 StartRegAdd=0;
;;;277    	u8 i,sendLen;
;;;278    	if(Uart1_receive_buffer[0]!=modbus_deviceId)  //核对本机地址
000004  4c71              LDR      r4,|L2.460|
000006  b095              SUB      sp,sp,#0x54           ;271
000008  7820              LDRB     r0,[r4,#0]  ; Uart1_receive_buffer
00000a  2805              CMP      r0,#5
00000c  d17e              BNE      |L2.268|
;;;279    	{
;;;280    		return; //地址错误
;;;281    	}
;;;282    	SumCal=crc16(&Uart1_receive_buffer[0],Uart1_RCnt-2);//计算出校验和
00000e  4d70              LDR      r5,|L2.464|
000010  7828              LDRB     r0,[r5,#0]  ; Uart1_RCnt
000012  1e80              SUBS     r0,r0,#2
000014  b2c1              UXTB     r1,r0
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       crc16
00001c  496d              LDR      r1,|L2.468|
00001e  8048              STRH     r0,[r1,#2]
;;;283    	SumRec=(Uart1_receive_buffer[Uart1_RCnt-2]<<8)+Uart1_receive_buffer[Uart1_RCnt-1];//这里默认接收到的校验和也是低八位在前，高八位在后
000020  782a              LDRB     r2,[r5,#0]  ; Uart1_RCnt
000022  4422              ADD      r2,r2,r4
000024  f8123c01          LDRB     r3,[r2,#-1]
000028  f8122c02          LDRB     r2,[r2,#-2]
00002c  eb032202          ADD      r2,r3,r2,LSL #8
000030  b292              UXTH     r2,r2
000032  800a              STRH     r2,[r1,#0]
;;;284    	if(SumCal!=SumRec)
000034  4290              CMP      r0,r2
000036  d169              BNE      |L2.268|
;;;285    	{		
;;;286    		         //校验和错误
;;;287    		return ;
;;;288    	}
;;;289    	
;;;290    	for(i=0;i<12;i++)            //AD寄存器地址对于0x0001~0x000C
;;;291    	{
;;;292    		REG0X03[i]=AdREG[i];
000038  4a67              LDR      r2,|L2.472|
00003a  2100              MOVS     r1,#0                 ;290
00003c  ea4f000d          MOV.W    r0,sp                 ;273
                  |L2.64|
000040  f8323011          LDRH     r3,[r2,r1,LSL #1]
000044  f8203011          STRH     r3,[r0,r1,LSL #1]
000048  1c49              ADDS     r1,r1,#1
00004a  b2c9              UXTB     r1,r1                 ;290
00004c  290c              CMP      r1,#0xc               ;290
00004e  d3f7              BCC      |L2.64|
;;;293    	}
;;;294    	for(i=0;i<4;i++)            //RTD寄存器地址对于0x000D~0x0011
;;;295    	{
;;;296    		REG0X03[12+i]=RTDREG[i];
000050  4a62              LDR      r2,|L2.476|
000052  2100              MOVS     r1,#0                 ;294
                  |L2.84|
000054  eb000541          ADD      r5,r0,r1,LSL #1
000058  f8323011          LDRH     r3,[r2,r1,LSL #1]
00005c  1c49              ADDS     r1,r1,#1
00005e  b2c9              UXTB     r1,r1                 ;294
000060  832b              STRH     r3,[r5,#0x18]
000062  2904              CMP      r1,#4                 ;294
000064  d3f6              BCC      |L2.84|
;;;297    	}
;;;298    	for(i=0;i<8;i++)            //DI寄存器地址对于0x00012~0x0019
;;;299    	{
;;;300    		REG0X03[16+i]=DiREG[i];
000066  4a5e              LDR      r2,|L2.480|
000068  2100              MOVS     r1,#0                 ;298
00006a  bf00              NOP      
                  |L2.108|
00006c  f8323011          LDRH     r3,[r2,r1,LSL #1]
000070  eb000541          ADD      r5,r0,r1,LSL #1
000074  1c49              ADDS     r1,r1,#1
000076  b2c9              UXTB     r1,r1                 ;298
000078  842b              STRH     r3,[r5,#0x20]
00007a  2908              CMP      r1,#8                 ;298
00007c  d3f6              BCC      |L2.108|
;;;301    	}
;;;302    	
;;;303    	for(i=0;i<8;i++)            //DA寄存器地址对于0x0001~0x0008
;;;304    	{
;;;305    		REG0X06[i]=DAREG[i];
00007e  4e59              LDR      r6,|L2.484|
000080  2100              MOVS     r1,#0                 ;303
000082  ad0c              ADD      r5,sp,#0x30           ;274
                  |L2.132|
000084  f8362011          LDRH     r2,[r6,r1,LSL #1]
000088  f8252011          STRH     r2,[r5,r1,LSL #1]
00008c  1c49              ADDS     r1,r1,#1
00008e  b2c9              UXTB     r1,r1                 ;303
000090  2908              CMP      r1,#8                 ;303
000092  d3f7              BCC      |L2.132|
;;;306    	}
;;;307    	for(i=0;i<8;i++)            //DO寄存器地址对于0x0009~0x0010
;;;308    	{
;;;309    		REG0X06[8+i]=DoREG[i];
000094  4f54              LDR      r7,|L2.488|
000096  2100              MOVS     r1,#0                 ;307
                  |L2.152|
000098  eb050341          ADD      r3,r5,r1,LSL #1
00009c  f8372011          LDRH     r2,[r7,r1,LSL #1]
0000a0  1c49              ADDS     r1,r1,#1
0000a2  b2c9              UXTB     r1,r1                 ;307
0000a4  821a              STRH     r2,[r3,#0x10]
0000a6  2908              CMP      r1,#8                 ;307
0000a8  d3f6              BCC      |L2.152|
;;;310    	}
;;;311    	
;;;312    	StartRegAdd=Uart1_receive_buffer[2]*256+Uart1_receive_buffer[3];//计算其实寄存器地址
0000aa  78e1              LDRB     r1,[r4,#3]  ; Uart1_receive_buffer
0000ac  78a2              LDRB     r2,[r4,#2]  ; Uart1_receive_buffer
0000ae  468b              MOV      r11,r1
0000b0  eb012102          ADD      r1,r1,r2,LSL #8
;;;313    	DatLength=Uart1_receive_buffer[4]*256+Uart1_receive_buffer[5];  //计算寄存器地址长度
0000b4  9214              STR      r2,[sp,#0x50]
0000b6  7962              LDRB     r2,[r4,#5]  ; Uart1_receive_buffer
0000b8  7923              LDRB     r3,[r4,#4]  ; Uart1_receive_buffer
;;;314    	 
;;;315    	
;;;316    	sendLen=0;
;;;317    	Uart1_Send_buffer[sendLen++]=modbus_deviceId;
0000ba  f8df9130          LDR      r9,|L2.492|
0000be  f04f0805          MOV      r8,#5
0000c2  4692              MOV      r10,r2                ;313
0000c4  f8898000          STRB     r8,[r9,#0]
;;;318    	Uart1_Send_buffer[sendLen++]=Uart1_receive_buffer[1];
0000c8  7864              LDRB     r4,[r4,#1]  ; Uart1_receive_buffer
0000ca  eb022e03          ADD      lr,r2,r3,LSL #8       ;313
0000ce  b289              UXTH     r1,r1                 ;312
0000d0  fa1ff28e          UXTH     r2,lr                 ;313
0000d4  46cc              MOV      r12,r9                ;317
0000d6  f04f0801          MOV      r8,#1                 ;317
0000da  f8894001          STRB     r4,[r9,#1]
;;;319    	
;;;320    	
;;;321    	switch(Uart1_receive_buffer[1])     //功能码
0000de  2c03              CMP      r4,#3
0000e0  d048              BEQ      |L2.372|
0000e2  2c06              CMP      r4,#6
0000e4  d063              BEQ      |L2.430|
;;;322    	{
;;;323    		case 0x03:
;;;324    							if((StartRegAdd+DatLength)>24)return;
;;;325    							Uart1_Send_buffer[sendLen++]=DatLength*2;
;;;326    							for(i=0;i<DatLength;i++)                     //读取单个或者多个寄存器
;;;327    							{
;;;328    								Uart1_Send_buffer[sendLen++]=REG0X03[StartRegAdd+i]>>8;
;;;329    								Uart1_Send_buffer[sendLen++]=REG0X03[StartRegAdd+i];
;;;330    							}
;;;331    			        break;
;;;332    		case 0x06:						                                //写单个寄存器
;;;333    							if(StartRegAdd>=12)return;
;;;334    							REG0X06[StartRegAdd]=Uart1_receive_buffer[4]*256+Uart1_receive_buffer[5];
;;;335    							Uart1_Send_buffer[sendLen++]=Uart1_receive_buffer[2];
;;;336    							Uart1_Send_buffer[sendLen++]=Uart1_receive_buffer[3];
;;;337    							Uart1_Send_buffer[sendLen++]=Uart1_receive_buffer[4];
;;;338    							Uart1_Send_buffer[sendLen++]=Uart1_receive_buffer[5];
;;;339    							break;
;;;340    		default:                           //不支持的功能吗
;;;341    							Uart1_Send_buffer[sendLen++]=Uart1_receive_buffer[2];
;;;342    							Uart1_Send_buffer[sendLen++]=Uart1_receive_buffer[3];
0000e6  f88cb003          STRB     r11,[r12,#3]
;;;343    							Uart1_Send_buffer[sendLen++]=Uart1_receive_buffer[4];
0000ea  f88c3004          STRB     r3,[r12,#4]
;;;344    							Uart1_Send_buffer[sendLen++]=Uart1_receive_buffer[5];
0000ee  2406              MOVS     r4,#6
0000f0  f88ca005          STRB     r10,[r12,#5]
;;;345    							Uart1_Send_buffer[1]=0x80;//功能码最高位置1
0000f4  2180              MOVS     r1,#0x80
0000f6  f88c1001          STRB     r1,[r12,#1]
;;;346    							Uart1_Send_buffer[2]=0x01; //设置异常码为01-无效功能
0000fa  f8898002          STRB     r8,[r9,#2]
                  |L2.254|
;;;347    							break; 
;;;348    	}
;;;349    	SumCal=crc16(&Uart1_Send_buffer[0],sendLen);//计算出校验和
0000fe  4621              MOV      r1,r4
000100  483a              LDR      r0,|L2.492|
000102  f7fffffe          BL       crc16
000106  4933              LDR      r1,|L2.468|
000108  8048              STRH     r0,[r1,#2]
;;;350    	Uart1_Send_buffer[sendLen++]=SumCal>>8;//crc低字节
00010a  e000              B        |L2.270|
                  |L2.268|
00010c  e02f              B        |L2.366|
                  |L2.270|
00010e  0a01              LSRS     r1,r0,#8
000110  f8091004          STRB     r1,[r9,r4]
000114  1c64              ADDS     r4,r4,#1
000116  b2e1              UXTB     r1,r4
;;;351      Uart1_Send_buffer[sendLen++]=SumCal&0xff;//crc高字节
;;;352    	
;;;353    	RS485MOED_S;                              //485输出
000118  f44f7880          MOV      r8,#0x100
00011c  f8090001          STRB     r0,[r9,r1]            ;351
000120  1c49              ADDS     r1,r1,#1              ;351
000122  f8df90cc          LDR      r9,|L2.496|
000126  b2cc              UXTB     r4,r1                 ;351
000128  4641              MOV      r1,r8
00012a  4648              MOV      r0,r9
00012c  f7fffffe          BL       GPIO_ResetBits
;;;354      zh_USART_SendString(&Uart1_Send_buffer[0],sendLen);//发送响应帧
000130  4621              MOV      r1,r4
000132  482e              LDR      r0,|L2.492|
000134  f7fffffe          BL       zh_USART_SendString
;;;355      delay_nms(2);
000138  2002              MOVS     r0,#2
00013a  f7fffffe          BL       delay_nms
;;;356    	RS485MOED_R;                              //485接收
00013e  4641              MOV      r1,r8
000140  4648              MOV      r0,r9
000142  f7fffffe          BL       GPIO_SetBits
;;;357    	
;;;358    	for(i=0;i<8;i++)            //DA寄存器地址对于0x0001~0x0008
000146  2000              MOVS     r0,#0
                  |L2.328|
;;;359    	{
;;;360    		DAREG[i]=REG0X06[i];
000148  f8351010          LDRH     r1,[r5,r0,LSL #1]
00014c  f8261010          STRH     r1,[r6,r0,LSL #1]
000150  1c40              ADDS     r0,r0,#1
000152  b2c0              UXTB     r0,r0                 ;358
000154  2808              CMP      r0,#8                 ;358
000156  d3f7              BCC      |L2.328|
;;;361    	}
;;;362    	for(i=0;i<8;i++)            //DO寄存器地址对于0x0009~0x0010
000158  f05f0000          MOVS.W   r0,#0
                  |L2.348|
;;;363    	{
;;;364    		DoREG[i]=REG0X06[8+i];
00015c  eb050140          ADD      r1,r5,r0,LSL #1
000160  8a09              LDRH     r1,[r1,#0x10]
000162  f8271010          STRH     r1,[r7,r0,LSL #1]
000166  1c40              ADDS     r0,r0,#1
000168  b2c0              UXTB     r0,r0                 ;362
00016a  2808              CMP      r0,#8                 ;362
00016c  d3f6              BCC      |L2.348|
                  |L2.366|
;;;365    	}
;;;366    	
;;;367    }
00016e  b015              ADD      sp,sp,#0x54
000170  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.372|
000174  188b              ADDS     r3,r1,r2              ;324
000176  2b18              CMP      r3,#0x18              ;324
000178  d8f9              BHI      |L2.366|
00017a  0053              LSLS     r3,r2,#1              ;325
00017c  f88c3002          STRB     r3,[r12,#2]           ;325
000180  2403              MOVS     r4,#3                 ;325
000182  2300              MOVS     r3,#0                 ;326
000184  4682              MOV      r10,r0                ;273
000186  e00f              B        |L2.424|
                  |L2.392|
000188  eb010803          ADD      r8,r1,r3              ;328
00018c  f83a0018          LDRH     r0,[r10,r8,LSL #1]    ;328
000190  ea4f2810          LSR      r8,r0,#8              ;328
000194  f80c8004          STRB     r8,[r12,r4]           ;328
000198  1c64              ADDS     r4,r4,#1              ;328
00019a  b2e4              UXTB     r4,r4                 ;328
00019c  f80c0004          STRB     r0,[r12,r4]           ;329
0001a0  1c64              ADDS     r4,r4,#1              ;329
0001a2  1c5b              ADDS     r3,r3,#1              ;329
0001a4  b2e4              UXTB     r4,r4                 ;329
0001a6  b2db              UXTB     r3,r3                 ;326
                  |L2.424|
0001a8  4293              CMP      r3,r2                 ;326
0001aa  d3ed              BCC      |L2.392|
0001ac  e7a7              B        |L2.254|
                  |L2.430|
0001ae  290c              CMP      r1,#0xc               ;333
0001b0  d2dd              BCS      |L2.366|
0001b2  f825e011          STRH     lr,[r5,r1,LSL #1]     ;334
0001b6  9914              LDR      r1,[sp,#0x50]         ;335
0001b8  f88c1002          STRB     r1,[r12,#2]           ;335
0001bc  f88cb003          STRB     r11,[r12,#3]          ;336
0001c0  f88c3004          STRB     r3,[r12,#4]           ;337
0001c4  f889a005          STRB     r10,[r9,#5]           ;338
0001c8  2406              MOVS     r4,#6                 ;338
0001ca  e798              B        |L2.254|
;;;368    /**
                          ENDP

                  |L2.460|
                          DCD      Uart1_receive_buffer
                  |L2.464|
                          DCD      Uart1_RCnt
                  |L2.468|
                          DCD      ||.data||
                  |L2.472|
                          DCD      AdREG
                  |L2.476|
                          DCD      RTDREG
                  |L2.480|
                          DCD      DiREG
                  |L2.484|
                          DCD      DAREG
                  |L2.488|
                          DCD      DoREG
                  |L2.492|
                          DCD      Uart1_Send_buffer
                  |L2.496|
                          DCD      0x40010800

                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;118      */
;;;119    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;120    {
;;;121    }
;;;122    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L4.0|
;;;57       */
;;;58     void HardFault_Handler(void)
000000  e7fe              B        |L4.0|
;;;59     {
;;;60       /* Go to infinite loop when Hard Fault exception occurs */
;;;61       while (1)
;;;62       {
;;;63       }
;;;64     }
;;;65     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
                  |L5.0|
;;;70       */
;;;71     void MemManage_Handler(void)
000000  e7fe              B        |L5.0|
;;;72     {
;;;73       /* Go to infinite loop when Memory Manage exception occurs */
;;;74       while (1)
;;;75       {
;;;76       }
;;;77     }
;;;78     
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;48       */
;;;49     void NMI_Handler(void)
000000  4770              BX       lr
;;;50     {
;;;51     }
;;;52     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;127      */
;;;128    void PendSV_Handler(void)
000000  4770              BX       lr
;;;129    {
;;;130    }
;;;131    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;109      */
;;;110    void SVC_Handler(void)
000000  4770              BX       lr
;;;111    {
;;;112    }
;;;113    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;136      */
;;;137    void SysTick_Handler(void)
000000  4770              BX       lr
;;;138    {
;;;139    }
;;;140    
                          ENDP


                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM2_IRQHandler PROC
;;;468    
;;;469    void TIM2_IRQHandler(void)   //TIM3中断
000000  b570              PUSH     {r4-r6,lr}
;;;470    {
;;;471    	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 
000002  2101              MOVS     r1,#1
000004  078c              LSLS     r4,r1,#30
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       TIM_GetITStatus
00000c  2800              CMP      r0,#0
00000e  d013              BEQ      |L10.56|
;;;472    		{
;;;473    		   TIM_ClearITPendingBit(TIM2, TIM_IT_Update  );  //清除TIMx的中断待处理位:TIM 中断源 
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_ClearITPendingBit
;;;474    			 TimerOverFlag=1;
000018  4908              LDR      r1,|L10.60|
00001a  2001              MOVS     r0,#1
00001c  7008              STRB     r0,[r1,#0]
;;;475    			 if(BegainRxFlag==1)
00001e  4908              LDR      r1,|L10.64|
000020  780a              LDRB     r2,[r1,#0]  ; BegainRxFlag
000022  2a01              CMP      r2,#1
000024  d108              BNE      |L10.56|
;;;476    			 {
;;;477    				 BegainRxFlag=0;
;;;478    				 BusyFlag=1;
000026  4d07              LDR      r5,|L10.68|
000028  2400              MOVS     r4,#0                 ;477
00002a  700c              STRB     r4,[r1,#0]            ;477
00002c  7028              STRB     r0,[r5,#0]
;;;479    				 DealModBus();                 //modbus处理
00002e  f7fffffe          BL       DealModBus
;;;480    				 Uart1_RCnt=0;
000032  4805              LDR      r0,|L10.72|
000034  7004              STRB     r4,[r0,#0]
;;;481    				 BusyFlag=0;
000036  702c              STRB     r4,[r5,#0]
                  |L10.56|
;;;482    			 }
;;;483    		}
;;;484    }
000038  bd70              POP      {r4-r6,pc}
;;;485    
                          ENDP

00003a  0000              DCW      0x0000
                  |L10.60|
                          DCD      TimerOverFlag
                  |L10.64|
                          DCD      BegainRxFlag
                  |L10.68|
                          DCD      BusyFlag
                  |L10.72|
                          DCD      Uart1_RCnt

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;160    
;;;161    void USART1_IRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;162    { 
;;;163      if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
000004  4e2a              LDR      r6,|L11.176|
000006  f2405125          MOV      r1,#0x525
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       USART_GetITStatus
;;;164      {
;;;165    		if(BusyFlag)return;
;;;166    		
;;;167    		TIM_Cmd(TIM2, DISABLE);  //关闭定时器
000010  2400              MOVS     r4,#0
000012  f04f4780          MOV      r7,#0x40000000
;;;168    		TIM_SetCounter(TIM2,0);//清除计时
;;;169    		
;;;170    		Uart1_receive_buffer[Uart1_RCnt]=USART_ReceiveData(USART1);		//连续发送
;;;171    		if(TimerOverFlag) //如果时间溢出 代表新的modbus 数据包开始
;;;172    		{
;;;173    			TimerOverFlag=0;
;;;174    			BegainRxFlag=1;
000016  2501              MOVS     r5,#1
000018  b308              CBZ      r0,|L11.94|
00001a  4826              LDR      r0,|L11.180|
00001c  7800              LDRB     r0,[r0,#0]            ;165  ; BusyFlag
00001e  2800              CMP      r0,#0                 ;165
000020  d144              BNE      |L11.172|
000022  2100              MOVS     r1,#0                 ;167
000024  4638              MOV      r0,r7                 ;167
000026  f7fffffe          BL       TIM_Cmd
00002a  2100              MOVS     r1,#0                 ;168
00002c  4638              MOV      r0,r7                 ;168
00002e  f7fffffe          BL       TIM_SetCounter
000032  4630              MOV      r0,r6                 ;170
000034  f7fffffe          BL       USART_ReceiveData
000038  4920              LDR      r1,|L11.188|
00003a  4602              MOV      r2,r0                 ;170
00003c  4b1e              LDR      r3,|L11.184|
00003e  7808              LDRB     r0,[r1,#0]            ;170  ; Uart1_RCnt
000040  541a              STRB     r2,[r3,r0]            ;170
000042  4b1f              LDR      r3,|L11.192|
000044  4a1f              LDR      r2,|L11.196|
000046  f893c000          LDRB     r12,[r3,#0]           ;171  ; TimerOverFlag
00004a  f1bc0f00          CMP      r12,#0                ;171
00004e  d002              BEQ      |L11.86|
000050  701c              STRB     r4,[r3,#0]            ;173
000052  7015              STRB     r5,[r2,#0]
;;;175    			Uart1_RCnt++;
000054  e001              B        |L11.90|
                  |L11.86|
;;;176    		}
;;;177    		else if(BegainRxFlag)
000056  7812              LDRB     r2,[r2,#0]  ; BegainRxFlag
000058  b10a              CBZ      r2,|L11.94|
                  |L11.90|
00005a  1c40              ADDS     r0,r0,#1
;;;178    		{
;;;179    			Uart1_RCnt++;
00005c  7008              STRB     r0,[r1,#0]
                  |L11.94|
;;;180    		}
;;;181      }
;;;182      if(USART_GetITStatus(USART1, USART_IT_TXE) != RESET)
00005e  f2407827          MOV      r8,#0x727
000062  4641              MOV      r1,r8
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       USART_GetITStatus
00006a  b1c8              CBZ      r0,|L11.160|
;;;183      { 	 
;;;184    	 if(Uart1_SCnt<Uart1_SendBuffSize)
00006c  4a16              LDR      r2,|L11.200|
00006e  4917              LDR      r1,|L11.204|
000070  7810              LDRB     r0,[r2,#0]  ; Uart1_SCnt
000072  7809              LDRB     r1,[r1,#0]  ; Uart1_SendBuffSize
000074  4288              CMP      r0,r1
000076  d207              BCS      |L11.136|
;;;185    	 {
;;;186    	 	USART_SendData(USART1,Uart1_Send_buffer[Uart1_SCnt++]);
000078  4915              LDR      r1,|L11.208|
00007a  5c09              LDRB     r1,[r1,r0]
00007c  1c40              ADDS     r0,r0,#1
00007e  7010              STRB     r0,[r2,#0]
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       USART_SendData
000086  e00b              B        |L11.160|
                  |L11.136|
;;;187    	 }
;;;188    	 else
;;;189    	 {
;;;190    		Uart1_SCnt=0;
000088  7014              STRB     r4,[r2,#0]
;;;191    		 delay_ms(5);
00008a  2005              MOVS     r0,#5
00008c  f7fffffe          BL       delay_ms
;;;192    		 DE1=1;
000090  4810              LDR      r0,|L11.212|
000092  f8c051a0          STR      r5,[r0,#0x1a0]
;;;193    		 
;;;194    		USART_ITConfig(USART1,USART_IT_TXE,DISABLE);			  	//发送完成 关闭中断
000096  2200              MOVS     r2,#0
000098  4641              MOV      r1,r8
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       USART_ITConfig
                  |L11.160|
;;;195    	 }	 
;;;196      }
;;;197    	TIM_Cmd(TIM2, ENABLE);  //关闭定时器
0000a0  4638              MOV      r0,r7
0000a2  e8bd41f0          POP      {r4-r8,lr}
0000a6  2101              MOVS     r1,#1
0000a8  f7ffbffe          B.W      TIM_Cmd
                  |L11.172|
;;;198    }
0000ac  e8bd81f0          POP      {r4-r8,pc}
;;;199    /*ModBus 计算CRC码的步骤为：
                          ENDP

                  |L11.176|
                          DCD      0x40013800
                  |L11.180|
                          DCD      BusyFlag
                  |L11.184|
                          DCD      Uart1_receive_buffer
                  |L11.188|
                          DCD      Uart1_RCnt
                  |L11.192|
                          DCD      TimerOverFlag
                  |L11.196|
                          DCD      BegainRxFlag
                  |L11.200|
                          DCD      Uart1_SCnt
                  |L11.204|
                          DCD      Uart1_SendBuffSize
                  |L11.208|
                          DCD      Uart1_Send_buffer
                  |L11.212|
                          DCD      0x42210000

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;372      */
;;;373    void USART2_IRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;374    {
;;;375       if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
000004  4e3b              LDR      r6,|L12.244|
000006  f2405125          MOV      r1,#0x525
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       USART_GetITStatus
;;;376      {
;;;377    //	 USART_ClearITPendingBit(USART2,USART_IT_RXNE);
;;;378    //	 if(Uart2_RCnt<SendBuffSize)
;;;379    //	 {
;;;380    //		Uart2_receive_buffer[Uart2_RCnt]=USART_ReceiveData(USART2);		//连续发送
;;;381    //		Uart2_RCnt++;
;;;382    //		}
;;;383    //	else
;;;384    //			{
;;;385    //	   	Uart2_RCnt=0;	
;;;386    //		}
;;;387    		Uart2_receive_buffer[Uart2_RCnt]=USART_ReceiveData(USART2);		//连续发送
000010  2501              MOVS     r5,#1
000012  2400              MOVS     r4,#0
000014  b308              CBZ      r0,|L12.90|
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       USART_ReceiveData
00001c  4937              LDR      r1,|L12.252|
00001e  4603              MOV      r3,r0
000020  4835              LDR      r0,|L12.248|
000022  780a              LDRB     r2,[r1,#0]  ; Uart2_RCnt
;;;388    		switch(Uart2_RCnt)
000024  2a0a              CMP      r2,#0xa
000026  5483              STRB     r3,[r0,r2]            ;387
000028  d23c              BCS      |L12.164|
00002a  e8dff002          TBB      [pc,r2]
00002e  050a              DCB      0x05,0x0a
000030  11171c21          DCB      0x11,0x17,0x1c,0x21
000034  262b3035          DCB      0x26,0x2b,0x30,0x35
;;;389    		{
;;;390    			case 0:if(Uart2_receive_buffer[Uart2_RCnt]=='H')Uart2_RCnt++;
000038  7800              LDRB     r0,[r0,#0]
00003a  2848              CMP      r0,#0x48
00003c  d132              BNE      |L12.164|
00003e  700d              STRB     r5,[r1,#0]
000040  e030              B        |L12.164|
;;;391    							else Uart2_RCnt=0;break;
;;;392    			case 1:if(Uart2_receive_buffer[Uart2_RCnt]=='R')Uart2_RCnt++;
000042  7840              LDRB     r0,[r0,#1]
000044  2852              CMP      r0,#0x52
000046  d101              BNE      |L12.76|
000048  2002              MOVS     r0,#2
00004a  e005              B        |L12.88|
                  |L12.76|
;;;393    							else Uart2_RCnt=0;break;
00004c  700c              STRB     r4,[r1,#0]
00004e  e029              B        |L12.164|
;;;394    			case 2:if(Uart2_receive_buffer[Uart2_RCnt]=='T')Uart2_RCnt++;
000050  7880              LDRB     r0,[r0,#2]
000052  2854              CMP      r0,#0x54
000054  d1fa              BNE      |L12.76|
000056  2003              MOVS     r0,#3
                  |L12.88|
000058  7008              STRB     r0,[r1,#0]            ;392
                  |L12.90|
00005a  e023              B        |L12.164|
;;;395    							else Uart2_RCnt=0;break;
;;;396    			case 3:if(Uart2_receive_buffer[Uart2_RCnt]=='O')Uart2_RCnt++;
00005c  78c0              LDRB     r0,[r0,#3]
00005e  284f              CMP      r0,#0x4f
000060  d1f4              BNE      |L12.76|
000062  2004              MOVS     r0,#4
000064  e7f8              B        |L12.88|
;;;397    							else Uart2_RCnt=0;break;
;;;398    			case 4:if(Uart2_receive_buffer[Uart2_RCnt]=='U')Uart2_RCnt++;
000066  7900              LDRB     r0,[r0,#4]
000068  2855              CMP      r0,#0x55
00006a  d1ef              BNE      |L12.76|
00006c  2005              MOVS     r0,#5
00006e  e7f3              B        |L12.88|
;;;399    							else Uart2_RCnt=0;break;
;;;400    			case 5:if(Uart2_receive_buffer[Uart2_RCnt]=='S')Uart2_RCnt++;
000070  7940              LDRB     r0,[r0,#5]
000072  2853              CMP      r0,#0x53
000074  d1ea              BNE      |L12.76|
000076  2006              MOVS     r0,#6
000078  e7ee              B        |L12.88|
;;;401    							else Uart2_RCnt=0;break;
;;;402    			case 6:if(Uart2_receive_buffer[Uart2_RCnt]=='A')Uart2_RCnt++;
00007a  7980              LDRB     r0,[r0,#6]
00007c  2841              CMP      r0,#0x41
00007e  d1e5              BNE      |L12.76|
000080  2007              MOVS     r0,#7
000082  e7e9              B        |L12.88|
;;;403    							else Uart2_RCnt=0;break;
;;;404    			case 7:if(Uart2_receive_buffer[Uart2_RCnt]=='R')Uart2_RCnt++;
000084  79c0              LDRB     r0,[r0,#7]
000086  2852              CMP      r0,#0x52
000088  d1e0              BNE      |L12.76|
00008a  2008              MOVS     r0,#8
00008c  e7e4              B        |L12.88|
;;;405    							else Uart2_RCnt=0;break;
;;;406    			case 8:if(Uart2_receive_buffer[Uart2_RCnt]=='T')Uart2_RCnt++;
00008e  7a00              LDRB     r0,[r0,#8]
000090  2854              CMP      r0,#0x54
000092  d1db              BNE      |L12.76|
000094  2009              MOVS     r0,#9
000096  e7df              B        |L12.88|
;;;407    							else Uart2_RCnt=0;break;
;;;408    			case 9:if(Uart2_receive_buffer[Uart2_RCnt]=='2'){Uart2_RCnt=0;Uart4852_TestFlag=1;}
000098  7a40              LDRB     r0,[r0,#9]
00009a  2832              CMP      r0,#0x32
00009c  d1d6              BNE      |L12.76|
00009e  4818              LDR      r0,|L12.256|
0000a0  700c              STRB     r4,[r1,#0]
0000a2  7005              STRB     r5,[r0,#0]
                  |L12.164|
;;;409    							else Uart2_RCnt=0;break;
;;;410    			default:break;
;;;411    		}
;;;412      }
;;;413      
;;;414      if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)
0000a4  f2407727          MOV      r7,#0x727
0000a8  4639              MOV      r1,r7
0000aa  4630              MOV      r0,r6
0000ac  f7fffffe          BL       USART_GetITStatus
0000b0  2800              CMP      r0,#0
0000b2  d01c              BEQ      |L12.238|
;;;415      { 	 
;;;416    	 if(Uart2_SCnt<Uart2_SendBuffSize)
0000b4  4a13              LDR      r2,|L12.260|
0000b6  4914              LDR      r1,|L12.264|
0000b8  7810              LDRB     r0,[r2,#0]  ; Uart2_SCnt
0000ba  7809              LDRB     r1,[r1,#0]  ; Uart2_SendBuffSize
0000bc  4288              CMP      r0,r1
0000be  d208              BCS      |L12.210|
;;;417    	 {
;;;418    	 	USART_SendData(USART2,Uart2_Send_buffer[Uart2_SCnt++]);
0000c0  4912              LDR      r1,|L12.268|
0000c2  5c09              LDRB     r1,[r1,r0]
0000c4  1c40              ADDS     r0,r0,#1
0000c6  7010              STRB     r0,[r2,#0]
0000c8  4630              MOV      r0,r6
0000ca  e8bd41f0          POP      {r4-r8,lr}
0000ce  f7ffbffe          B.W      USART_SendData
                  |L12.210|
;;;419    	 }
;;;420    	 else
;;;421    	 {
;;;422    		Uart2_SCnt=0;
0000d2  7014              STRB     r4,[r2,#0]
;;;423    		 delay_ms(5);
0000d4  2005              MOVS     r0,#5
0000d6  f7fffffe          BL       delay_ms
;;;424    		 DE2=1;
0000da  480d              LDR      r0,|L12.272|
0000dc  f8c0519c          STR      r5,[r0,#0x19c]
;;;425    		USART_ITConfig(USART2,USART_IT_TXE,DISABLE);			  	//发送完成 关闭中断
0000e0  4639              MOV      r1,r7
0000e2  4630              MOV      r0,r6
0000e4  e8bd41f0          POP      {r4-r8,lr}
0000e8  2200              MOVS     r2,#0
0000ea  f7ffbffe          B.W      USART_ITConfig
                  |L12.238|
;;;426    	 }	 
;;;427      }
;;;428    }
0000ee  e8bd81f0          POP      {r4-r8,pc}
;;;429    void USART3_IRQHandler(void)
                          ENDP

0000f2  0000              DCW      0x0000
                  |L12.244|
                          DCD      0x40004400
                  |L12.248|
                          DCD      Uart2_receive_buffer
                  |L12.252|
                          DCD      Uart2_RCnt
                  |L12.256|
                          DCD      Uart4852_TestFlag
                  |L12.260|
                          DCD      Uart2_SCnt
                  |L12.264|
                          DCD      Uart2_SendBuffSize
                  |L12.268|
                          DCD      Uart2_Send_buffer
                  |L12.272|
                          DCD      0x42228000

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;428    }
;;;429    void USART3_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;430    {
;;;431       if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
000002  4d1f              LDR      r5,|L13.128|
000004  f2405125          MOV      r1,#0x525
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_GetITStatus
00000e  2400              MOVS     r4,#0
000010  b1b0              CBZ      r0,|L13.64|
;;;432      {
;;;433    //	 USART_ClearITPendingBit(USART3,USART_IT_RXNE);
;;;434    //	 if(Uart3_RCnt<SendBuffSize)
;;;435    //	 {
;;;436    //		Uart3_receive_buffer[Uart3_RCnt]=USART_ReceiveData(USART3);		//连续发送
;;;437    //		Uart3_RCnt++;
;;;438    //	}
;;;439    //	else
;;;440    //	{
;;;441    //	   	Uart3_RCnt=0;	
;;;442    //	}
;;;443    		
;;;444    		Uart3_receive_buffer[Uart3_RCnt]=USART_ReceiveData(USART3);		//连续发送
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USART_ReceiveData
000018  491b              LDR      r1,|L13.136|
00001a  4a1a              LDR      r2,|L13.132|
00001c  780b              LDRB     r3,[r1,#0]  ; Uart3_RCnt
00001e  54d0              STRB     r0,[r2,r3]
000020  2001              MOVS     r0,#1
;;;445    		switch(Uart3_RCnt)
000022  b113              CBZ      r3,|L13.42|
000024  2b01              CMP      r3,#1
000026  d10b              BNE      |L13.64|
000028  e004              B        |L13.52|
                  |L13.42|
;;;446    		{
;;;447    			case 0:if(Uart3_receive_buffer[Uart3_RCnt]=='O')Uart3_RCnt++;break;
00002a  7812              LDRB     r2,[r2,#0]
00002c  2a4f              CMP      r2,#0x4f
00002e  d107              BNE      |L13.64|
000030  7008              STRB     r0,[r1,#0]
000032  e005              B        |L13.64|
                  |L13.52|
;;;448    			case 1:if(Uart3_receive_buffer[Uart3_RCnt]=='K')Wifi_TestFlag=1;Uart3_RCnt=0;break;
000034  7852              LDRB     r2,[r2,#1]
000036  2a4b              CMP      r2,#0x4b
000038  d101              BNE      |L13.62|
00003a  4a14              LDR      r2,|L13.140|
00003c  7010              STRB     r0,[r2,#0]
                  |L13.62|
00003e  700c              STRB     r4,[r1,#0]
                  |L13.64|
;;;449    			default:break;
;;;450    		}
;;;451      }
;;;452      
;;;453      if(USART_GetITStatus(USART3, USART_IT_TXE) != RESET)
000040  f2407627          MOV      r6,#0x727
000044  4631              MOV      r1,r6
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       USART_GetITStatus
00004c  2800              CMP      r0,#0
00004e  d016              BEQ      |L13.126|
;;;454      { 	 
;;;455    	 if(Uart3_SCnt<Uart3_SendBuffSize)
000050  480f              LDR      r0,|L13.144|
000052  4910              LDR      r1,|L13.148|
000054  7802              LDRB     r2,[r0,#0]  ; Uart3_SCnt
000056  7809              LDRB     r1,[r1,#0]  ; Uart3_SendBuffSize
000058  428a              CMP      r2,r1
00005a  d208              BCS      |L13.110|
;;;456    	 {
;;;457    	 	USART_SendData(USART3,Uart3_Send_buffer[Uart3_SCnt++]);
00005c  490e              LDR      r1,|L13.152|
00005e  5c89              LDRB     r1,[r1,r2]
000060  1c52              ADDS     r2,r2,#1
000062  7002              STRB     r2,[r0,#0]
000064  4628              MOV      r0,r5
000066  e8bd4070          POP      {r4-r6,lr}
00006a  f7ffbffe          B.W      USART_SendData
                  |L13.110|
;;;458    	 }
;;;459    	 else
;;;460    	 {
;;;461    		Uart3_SCnt=0;
00006e  7004              STRB     r4,[r0,#0]
;;;462    		USART_ITConfig(USART3,USART_IT_TXE,DISABLE);			  	//发送完成 关闭中断
000070  4631              MOV      r1,r6
000072  4628              MOV      r0,r5
000074  e8bd4070          POP      {r4-r6,lr}
000078  2200              MOVS     r2,#0
00007a  f7ffbffe          B.W      USART_ITConfig
                  |L13.126|
;;;463    	 }	 
;;;464      }
;;;465    }
00007e  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP

                  |L13.128|
                          DCD      0x40004800
                  |L13.132|
                          DCD      Uart3_receive_buffer
                  |L13.136|
                          DCD      Uart3_RCnt
                  |L13.140|
                          DCD      Wifi_TestFlag
                  |L13.144|
                          DCD      Uart3_SCnt
                  |L13.148|
                          DCD      Uart3_SendBuffSize
                  |L13.152|
                          DCD      Uart3_Send_buffer

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
                  |L14.0|
;;;96       */
;;;97     void UsageFault_Handler(void)
000000  e7fe              B        |L14.0|
;;;98     {
;;;99       /* Go to infinite loop when Usage Fault exception occurs */
;;;100      while (1)
;;;101      {
;;;102      }
;;;103    }
;;;104    
                          ENDP


                          AREA ||i.crc16||, CODE, READONLY, ALIGN=2

                  crc16 PROC
;;;220    //调用方式crc16（指向数据的指针，需要校验的数据长度）
;;;221    u16 crc16(u8 *ptr,u8 len)
000000  b570              PUSH     {r4-r6,lr}
;;;222    {
;;;223    	unsigned long wcrc=0XFFFF;//预置16位crc寄存器，初值全部为1
000002  f64f72ff          MOV      r2,#0xffff
;;;224    	int i=0,j=0;//定义计数
000006  2400              MOVS     r4,#0
;;;225    	for(i=0;i<len;i++)//循环计算每个数据
;;;226    		{
;;;227    			wcrc^=*ptr++;//将八位数据与crc寄存器亦或.指针地址增加，指向下个数据
;;;228    			for(j=0;j<8;j++)//循环计算数据的
;;;229    				{
;;;230    					if(wcrc&0X0001)//判断右移出的是不是1，如果是1则与多项式进行异或。
;;;231    						{
;;;232    							wcrc=wcrc>>1^0XA001;//先将数据右移一位再与上面的多项式进行异或
000008  f24a0501          MOV      r5,#0xa001
00000c  e00e              B        |L15.44|
00000e  bf00              NOP                            ;227
                  |L15.16|
000010  f8103b01          LDRB     r3,[r0],#1            ;227
000014  405a              EORS     r2,r2,r3              ;227
000016  2300              MOVS     r3,#0                 ;228
                  |L15.24|
000018  07d6              LSLS     r6,r2,#31             ;230
00001a  d002              BEQ      |L15.34|
00001c  ea850252          EOR      r2,r5,r2,LSR #1
000020  e000              B        |L15.36|
                  |L15.34|
;;;233    						}
;;;234    					else//如果不是1，则直接移出
;;;235    						{
;;;236    							wcrc>>=1;//直接移出
000022  0852              LSRS     r2,r2,#1
                  |L15.36|
000024  1c5b              ADDS     r3,r3,#1
000026  2b08              CMP      r3,#8                 ;228
000028  dbf6              BLT      |L15.24|
00002a  1c64              ADDS     r4,r4,#1              ;228
                  |L15.44|
00002c  428c              CMP      r4,r1                 ;225
00002e  dbef              BLT      |L15.16|
;;;237    						}
;;;238    				}
;;;239    		}
;;;240    	return wcrc<<8|wcrc>>8;//低八位在前，高八位在后
000030  0210              LSLS     r0,r2,#8
000032  ea402012          ORR      r0,r0,r2,LSR #8
000036  b280              UXTH     r0,r0
;;;241    }
000038  bd70              POP      {r4-r6,pc}
;;;242    
                          ENDP


                          AREA ||i.delay_nms||, CODE, READONLY, ALIGN=1

                  delay_nms PROC
;;;242    
;;;243    void delay_nms(u16 time)
000000  f64263df          MOV      r3,#0x2edf
;;;244    {    
000004  e003              B        |L16.14|
                  |L16.6|
000006  4619              MOV      r1,r3
                  |L16.8|
;;;245    	 u16 i=0;  
;;;246    	 while(time--)
;;;247    	 {
;;;248    			i=12000;  //自己定义
;;;249    			while(i--) ;    
000008  1e49              SUBS     r1,r1,#1
00000a  b289              UXTH     r1,r1
00000c  d2fc              BCS      |L16.8|
                  |L16.14|
00000e  1e40              SUBS     r0,r0,#1              ;246
000010  b280              UXTH     r0,r0                 ;246
000012  d2f8              BCS      |L16.6|
;;;250    	 }
;;;251    }
000014  4770              BX       lr
;;;252    
                          ENDP


                          AREA ||i.zh_USART_SendData||, CODE, READONLY, ALIGN=2

                  zh_USART_SendData PROC
;;;252    
;;;253    void zh_USART_SendData(u8 ch)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
;;;255       
;;;256        while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);//等待上一个字节发送完毕
000002  4c07              LDR      r4,|L17.32|
000004  4605              MOV      r5,r0                 ;254
                  |L17.6|
000006  2140              MOVS     r1,#0x40
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L17.6|
;;;257        USART_SendData(USART1,ch);   
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  e8bd4070          POP      {r4-r6,lr}
00001a  f7ffbffe          B.W      USART_SendData
;;;258    }
;;;259    //发送len个字节
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      0x40013800

                          AREA ||i.zh_USART_SendString||, CODE, READONLY, ALIGN=1

                  zh_USART_SendString PROC
;;;259    //发送len个字节
;;;260    void zh_USART_SendString(u8* s,u8 len)
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;262    	  
;;;263        int i;
;;;264        for(i=0;i<len;i++)
000006  2400              MOVS     r4,#0
000008  e003              B        |L18.18|
                  |L18.10|
;;;265        {
;;;266            zh_USART_SendData(s[i]);
00000a  5d30              LDRB     r0,[r6,r4]
00000c  f7fffffe          BL       zh_USART_SendData
000010  1c64              ADDS     r4,r4,#1
                  |L18.18|
000012  42ac              CMP      r4,r5                 ;264
000014  dbf9              BLT      |L18.10|
;;;267        }
;;;268    }
000016  bd70              POP      {r4-r6,pc}
;;;269    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  SumRec
000000  0000              DCW      0x0000
                  SumCal
000002  0000              DCW      0x0000
